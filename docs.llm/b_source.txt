Excluding patterns: 
Documentation for LLMs
Excluding patterns: 
Excluding patterns: -not -path */__pycache__/* -not -path */__tests__/* -not -path */.git/* -not -path */.idea/* -not -path */.next/* -not -path */.venv/* -not -path */.vscode/* -not -path */*.spec.py -not -path */*.spec.ts -not -path */*.spec.tsx -not -path */*.test.py -not -path */*.test.ts -not -path */*.test.tsx -not -path */*test.py -not -path */*test.ts -not -path */*test.tsx -not -path */build/* -not -path */dist/* -not -path */me.ts -not -path */node_modules/* -not -path */test_*.py -not -path */test.ts -not -path */test.ts -not -path */tests/* -not -path */venv/*
=== File: packages/b_declarations/src/core/index.ts ===
// b_path:: packages/b_declarations/src/core/index.ts
export * from "./registry";


=== File: packages/b_declarations/src/core/registry.ts ===
// b_path:: packages/b_declarations/src/core/registry.ts
import type { PropertyDefinition } from "../types";

/**
 * Property registry - maps CSS property names to their definitions.
 * This allows runtime lookup of property parsers and metadata.
 *
 * ⚠️ **Initialization Pattern**:
 * The registry is populated via side-effect imports when property definition
 * modules are loaded. Each property calls `defineProperty()` during module
 * initialization, which automatically registers it with the global registry.
 *
 * The `@b/declarations` package ensures all properties are registered by
 * importing them in `properties/index.ts`, which marks the registry as
 * initialized after all definitions are loaded.
 *
 * **For library consumers**: Just import from `@b/declarations` and the
 * registry will be ready. No manual initialization required.
 *
 * @example
 * ```typescript
 * import { getPropertyDefinition } from "@b/declarations";
 *
 * const def = getPropertyDefinition("background-color");
 * // Registry is automatically populated via side-effect imports
 * ```
 */
class PropertyRegistry {
  private properties = new Map<string, PropertyDefinition>();
  private initialized = false;

  /**
   * Register a property definition.
   */
  register(definition: PropertyDefinition): void {
    this.properties.set(definition.name, definition);
  }

  /**
   * Get a property definition by name.
   */
  get(name: string): PropertyDefinition | undefined {
    return this.properties.get(name);
  }

  /**
   * Check if a property is registered.
   */
  has(name: string): boolean {
    return this.properties.has(name);
  }

  /**
   * Get all registered property names.
   */
  getPropertyNames(): string[] {
    return Array.from(this.properties.keys());
  }

  /**
   * Clear all registered properties (useful for testing).
   */
  clear(): void {
    this.properties.clear();
    this.initialized = false;
  }

  /**
   * Mark registry as initialized.
   * Called by property definitions during module load.
   * @internal
   */
  markInitialized(): void {
    this.initialized = true;
  }

  /**
   * Check if registry has been initialized.
   * @internal
   */
  isInitialized(): boolean {
    return this.initialized;
  }
}

/**
 * Global property registry instance.
 *
 * **Initialization**: The registry is populated via side-effect imports.
 * Each property definition module calls `defineProperty()` during load,
 * which registers it with this global instance. The `properties/index.ts`
 * module imports all property definitions and marks initialization complete.
 *
 * This pattern ensures:
 * - Zero-config usage for library consumers
 * - Properties are registered once during module load
 * - No circular dependency issues
 * - Lazy evaluation only for dynamic imports
 */
export const propertyRegistry = new PropertyRegistry();

/**
 * Helper to define and register a property.
 */
export function defineProperty<T>(definition: PropertyDefinition<T>): PropertyDefinition<T> {
  propertyRegistry.register(definition as PropertyDefinition<unknown>);
  return definition;
}

/**
 * Check if a property name is a custom property (--*)
 */
export function isCustomProperty(name: string): boolean {
  return name.startsWith("--") && name.length > 2;
}

/**
 * Get property definition with custom property fallback.
 *
 * The registry is automatically populated when property definitions are imported.
 * Property modules call `defineProperty()` during module initialization,
 * which registers them with the global registry.
 *
 * @example
 * ```typescript
 * import { getPropertyDefinition } from "@b/declarations";
 *
 * const bgColor = getPropertyDefinition("background-color");
 * const customProp = getPropertyDefinition("--my-color");
 * // Properties are available after module import
 * ```
 */
export function getPropertyDefinition(name: string): PropertyDefinition | undefined {
  // First, try a direct lookup.
  const definition = propertyRegistry.get(name);
  if (definition) return definition;

  // If not found and it's a custom property, get the generic '--*' definition.
  if (isCustomProperty(name)) {
    return propertyRegistry.get("--*");
  }

  return undefined;
}


=== File: packages/b_declarations/src/declaration-list-generator.ts ===
// b_path:: packages/b_declarations/src/declaration-list-generator.ts
import { createError, generateOk, type GenerateResult, type Issue } from "@b/types";
import { generateDeclaration } from "./generator";
import type { DeclarationResult } from "./types";

/**
 * Generate CSS declaration list from array of DeclarationResult.
 * Produces semicolon-separated declarations.
 *
 * @param declarations - Array of DeclarationResult to generate from
 * @returns GenerateResult with semicolon-separated string
 *
 * @example
 * ```ts
 * const result = generateDeclarationList([
 *   { property: "color", ir: colorIR },
 *   { property: "font-size", ir: fontSizeIR }
 * ]);
 * // Result: "color: red; font-size: 16px"
 * ```
 */
export function generateDeclarationList(declarations: DeclarationResult[]): GenerateResult {
  // Handle empty array
  if (declarations.length === 0) {
    return generateOk("");
  }

  const results: string[] = [];
  const allIssues: Issue[] = [];

  // Generate each declaration
  for (const decl of declarations) {
    // Note: Don't pass important flag here to avoid double appending
    const result = generateDeclaration({
      property: decl.property as never,
      ir: decl.ir as never,
    });

    if (result.ok) {
      // Append !important based on DeclarationResult flag
      const cssText = decl.important ? `${result.value} !important` : result.value;
      results.push(cssText);
    }

    if (result.issues.length > 0) {
      allIssues.push(...result.issues);
    }
  }

  // If no declarations generated successfully, return error
  if (results.length === 0) {
    return {
      ok: false,
      issues: allIssues.length > 0 ? allIssues : [createError("invalid-ir", "Failed to generate any declarations")],
    };
  }

  // Join with semicolons
  const css = results.join("; ");

  return {
    ok: true,
    value: css,
    issues: allIssues,
  };
}


=== File: packages/b_declarations/src/declaration-list-parser.ts ===
// b_path:: packages/b_declarations/src/declaration-list-parser.ts
import { createError, createWarning, parseErr, parseOk, type ParseResult, type Issue } from "@b/types";
import { parseDeclaration } from "./parser";
import type { DeclarationResult } from "./types";
import * as csstree from "@eslint/css-tree";

/**
 * Parse a CSS declaration list (semicolon-separated declarations).
 * Commonly used for inline styles or batch parsing.
 *
 * Handles partial failures: continues parsing on invalid declarations,
 * collects all successful results and all issues.
 *
 * @param css - Declaration list string (no braces)
 * @returns ParseResult with array of DeclarationResult
 *
 * @example
 * ```ts
 * const result = parseDeclarationList("color: red; font-size: 16px; margin: 10px");
 * if (result.ok) {
 *   console.log(`Parsed ${result.value.length} declarations`);
 * }
 * ```
 */
export function parseDeclarationList(css: string): ParseResult<DeclarationResult[]> {
  const trimmed = css.trim();

  // Handle empty input
  if (trimmed === "") {
    return parseOk([]);
  }

  // Parse with css-tree using declarationList context
  let ast: csstree.DeclarationList;
  try {
    ast = csstree.parse(trimmed, {
      context: "declarationList",
      positions: true,
    }) as csstree.DeclarationList;
  } catch (e: unknown) {
    const error = e as Error;
    return parseErr(
      "declaration-list",
      createError("invalid-syntax", `Failed to parse declaration list: ${error.message}`),
    );
  }

  // Collect results and issues
  const declarations: DeclarationResult[] = [];
  const allIssues: Issue[] = [];
  const seenProperties = new Set<string>();

  // Iterate over declaration nodes
  if (!ast.children) {
    return parseOk([]);
  }

  ast.children.forEach((node) => {
    if (node.type !== "Declaration") {
      allIssues.push(createError("invalid-syntax", `Unexpected node type: ${node.type}`));
      return;
    }

    // Extract property and value from AST node
    const property = node.property;
    const valueNode = node.value;
    const important = Boolean(node.important);

    if (!valueNode) {
      allIssues.push(createError("missing-value", `Missing value for property: ${property}`, { property }));
      return;
    }

    const value = csstree.generate(valueNode).trim();

    // Parse the declaration using existing infrastructure
    const result = parseDeclaration({ property, value, important });

    if (result.ok) {
      // Check for duplicate property
      if (seenProperties.has(property)) {
        allIssues.push(
          createWarning("duplicate-property", `Property "${property}" declared multiple times. Last value wins.`, {
            property,
          }),
        );
      }
      seenProperties.add(property);
      declarations.push(result.value);
    }

    // Collect all issues (both errors and warnings)
    allIssues.push(...result.issues);
  });

  const hasErrors = allIssues.some((issue) => issue.severity === "error");

  // If we have declarations AND no errors, it's a success.
  // If we have no declarations but also no issues, it's an empty-but-valid success.
  if ((declarations.length > 0 && !hasErrors) || (declarations.length === 0 && allIssues.length === 0)) {
    return {
      ok: true,
      value: declarations,
      issues: allIssues,
    };
  }

  // Otherwise, it's a failure (either partial or total).
  return {
    ok: false,
    value: declarations, // Still return partial value
    issues: allIssues,
  };
}


=== File: packages/b_declarations/src/generator.ts ===
// b_path:: packages/b_declarations/src/generator.ts
import { generateOk, generateErr, createError, type GenerateResult, type Issue } from "@b/types";
import { getPropertyDefinition } from "./core";
import type { PropertyIRMap, RegisteredProperty, PropertyGenerator } from "./types";

/**
 * Input for generating a CSS declaration from IR.
 *
 * Generic version allows type-safe property names and IR types.
 */

export interface GenerateDeclarationInput<TProperty extends RegisteredProperty> {
  property: TProperty;
  ir: PropertyIRMap[TProperty];
  important?: boolean;
}

/**
 * Generate a CSS declaration string from its IR representation.
 *
 * @param input - Property name and IR to generate from
 * @returns GenerateResult with CSS declaration string or issues
 *
 * @example
 * ```ts
 * // Type-safe usage
 * const result = generateDeclaration({
 *   property: "background-image" as const,
 *   ir: { kind: "list", layers: [...] }
 * });
 *
 * if (result.ok) {
 *   console.log(result.value); // "background-image: url(img.png), linear-gradient(...)"
 * }
 * ```
 */
export function generateDeclaration<TProperty extends RegisteredProperty>(
  input: GenerateDeclarationInput<TProperty>,
): GenerateResult {
  const { property, ir, important } = input;

  // Look up property definition (with custom property fallback)
  const definition = getPropertyDefinition(property);

  if (!definition) {
    return generateErr(
      createError("invalid-ir", `Unknown CSS property: ${property}`, {
        property,
        suggestion: "Check property name spelling or ensure property is registered",
      }),
      property,
    );
  }

  // Check if property has a generator
  if (!definition.generator) {
    return generateErr(
      createError("missing-required-field", `Property ${property} does not have a generator registered`, {
        property,
        suggestion: "Add a generator function to the property definition",
      }),
      property,
    );
  }

  // We need to tell TypeScript that the generator we retrieved (which is `(ir: unknown) => ...` at a glance)
  // is the correct one for the IR we have. This is a safe assertion because our registration
  // process will guarantee it.
  const generator = definition.generator as PropertyGenerator<PropertyIRMap[TProperty]>;
  const rawResult = generator(ir);
  const result = ensureProperty(rawResult, property);

  if (!result.ok) {
    return result;
  }

  // Format as CSS declaration: "property: value"
  // Append !important if specified
  const declaration = important ? `${property}: ${result.value} !important` : `${property}: ${result.value}`;

  return {
    ...generateOk(declaration, property),
    issues: result.issues,
  };
}

function ensureProperty(result: GenerateResult, property: string): GenerateResult {
  const stampedIssues = stampIssues(result.issues, property);

  if (result.ok) {
    return {
      ok: true,
      value: result.value,
      issues: stampedIssues,
      property,
    };
  }

  return {
    ok: false,
    issues: stampedIssues,
    property,
  };
}

function stampIssues(issues: Issue[], property: string): Issue[] {
  return issues.map((issue) => (issue.property ? issue : { ...issue, property }));
}


=== File: packages/b_declarations/src/index.ts ===
// b_path:: packages/b_declarations/src/index.ts
// @b/declarations - CSS declaration schemas and parsers

export * from "./core";
export * from "./types";
export * from "./utils";
export * from "./parser";
export * from "./generator";
export * from "./properties";
export * from "./declaration-list-parser";
export * from "./declaration-list-generator";


=== File: packages/b_declarations/src/parser.ts ===
// b_path:: packages/b_declarations/src/parser.ts
import * as csstree from "@eslint/css-tree";
import * as Keywords from "@b/keywords";
import {
  createError,
  parseErr,
  parseOk,
  forwardParseErr,
  type ParseResult,
  type Issue,
  type GenerateResult,
} from "@b/types";
import { getPropertyDefinition, isCustomProperty } from "./core";
import type { CSSDeclaration, DeclarationResult } from "./types";
import { generateDeclaration } from "./generator";

/**
 * Parse a CSS declaration string or object into its IR representation.
 *
 * AST-native architecture: Single-pass parsing with direct AST traversal.
 * 1. Parses CSS to AST with css-tree (positions enabled)
 * 2. Passes AST node directly to property parser
 * 3. Errors naturally include location data from AST
 *
 * @param input - CSS declaration string (e.g., "color: red;" or "color: red") or object
 * @returns Result with the parsed IR or an error
 *
 * @example
 * ```ts
 * // From string
 * const result = parseDeclaration("background-image: url(img.png);");
 *
 * // From object
 * const result = parseDeclaration({
 *   property: "background-image",
 *   value: "url(img.png)"
 * });
 * ```
 */
export function parseDeclaration(input: string | CSSDeclaration): ParseResult<DeclarationResult> {
  let property: string;
  let value: string;
  let important = false;

  // Parse string input into property and value components
  // Accepts two formats:
  // 1. String: "property: value" or "property: value;"
  // 2. Object: { property: "property", value: "value" }
  if (typeof input === "string") {
    const parsed = parseDeclarationString(input);
    if (!parsed.ok) {
      return forwardParseErr<DeclarationResult>(parsed);
    }
    property = parsed.value.property;
    value = parsed.value.value;
    important = parsed.value.important ?? false;
  } else {
    property = input.property;
    value = input.value;
    important = Boolean(input.important);
  }

  // ✨ UNIVERSAL CSS-WIDE KEYWORD CHECK ✨
  // CSS-wide keywords (inherit, initial, unset, revert, revert-layer) are universal
  // and apply to ALL properties. Check once here instead of in every property parser.
  // This is architecturally correct: browsers handle these keywords at the top level
  // before delegating to property-specific parsing logic.

  if (!isCustomProperty(property)) {
    const trimmedValue = value.trim().toLowerCase();
    const wideKeywordCheck = Keywords.cssWide.safeParse(trimmedValue);
    if (wideKeywordCheck.success) {
      return parseOk({
        property,
        ir: { kind: "keyword", value: wideKeywordCheck.data } as never,
        ...(important ? { important: true } : {}),
      });
    }
  } // ✨ END UNIVERSAL CHECK ✨

  // Step 1: Look up property definition (with custom property fallback)
  const definition = getPropertyDefinition(property);

  if (!definition) {
    return parseErr("declaration", createError("invalid-value", `Unknown CSS property: ${property}`));
  }

  // Step 2: Pre-validate keywords if allowedKeywords is defined
  const preValidationIssues: Issue[] = [];

  if (definition.allowedKeywords && !isCustomProperty(property)) {
    const trimmedValue = value.trim().toLowerCase();

    // For multi-value properties, validate each comma-separated value
    if (definition.multiValue) {
      const values = trimmedValue.split(/\s*,\s*/);
      for (const val of values) {
        // Only validate bare identifiers - skip CSS functions (var, calc, etc)
        if (val && /^[a-z-]+$/i.test(val) && !definition.allowedKeywords.includes(val)) {
          preValidationIssues.push(
            createError(
              "invalid-value",
              `Invalid keyword '${val}' for ${property}. Expected one of: ${definition.allowedKeywords.join(", ")}`,
            ),
          );
        }
      }
    } else {
      // Single-value keyword property - only validate bare identifiers
      if (/^[a-z-]+$/i.test(trimmedValue) && !definition.allowedKeywords.includes(trimmedValue)) {
        preValidationIssues.push(
          createError(
            "invalid-value",
            `Invalid keyword '${trimmedValue}' for ${property}. Expected one of: ${definition.allowedKeywords.join(", ")}`,
          ),
        );
      }
    }
  }

  // Step 3: Parse based on property type
  let parseResult: ParseResult<unknown>;

  // Dispatch to appropriate parser based on property definition
  if (definition.rawValue) {
    // Raw value properties: Pass string directly without AST parsing
    // Examples: custom properties (--*), intentionally opaque values
    parseResult = unsafeCallParser(definition.parser, value);
  } else if (definition.multiValue) {
    // Multi-value property: Pass raw string to parser (will split on commas)
    parseResult = unsafeCallParser(definition.parser, value);
  } else {
    // Single-value property: Parse to AST first
    let valueAst: csstree.Value;
    try {
      valueAst = csstree.parse(value, {
        context: "value",
        positions: true,
      }) as csstree.Value;
    } catch (e: unknown) {
      // Fatal syntax error for single-value property
      const error = e as Error;
      return parseErr("declaration", createError("invalid-syntax", error.message));
    }

    // Pass validated AST to parser
    parseResult = unsafeCallParser(definition.parser, valueAst);
  }

  // Step 4: Collect all issues
  const allIssues: Issue[] = [...preValidationIssues, ...parseResult.issues];

  // Step 5: Try generation to get semantic warnings (even if parse failed but has partial IR)
  if (parseResult.value) {
    try {
      const genResult = unsafeGenerateDeclaration(property, parseResult.value);

      if (genResult.issues.length > 0) {
        // Add generator warnings (deduplicate by message to avoid duplicates)
        const existingMessages = new Set(allIssues.map((issue) => issue.message));
        const newIssues = genResult.issues.filter((issue) => !existingMessages.has(issue.message));
        allIssues.push(...newIssues);
      }
    } catch (_err) {
      // Generator threw - ignore, we still have parse result
    }
  }

  // Step 6: Enrich all issues with property context
  const enrichedIssues = allIssues.map((issue) => ({
    ...issue,
    property,
  }));

  // Step 7: Return result
  if (!parseResult.ok) {
    const partialDeclaration =
      parseResult.value !== undefined
        ? withImportant<DeclarationResult>({ property, ir: parseResult.value as never }, important)
        : undefined;

    return {
      ok: false,
      value: partialDeclaration,
      issues: enrichedIssues,
      property,
    };
  }

  return {
    ...parseOk(withImportant<DeclarationResult>({ property, ir: parseResult.value as never }, important)),
    issues: enrichedIssues,
  };
}

/**
 * Parse a CSS declaration string into property and value.
 * Handles both formats: "property: value;" and "property: value"
 *
 * @internal
 */
function parseDeclarationString(input: string): ParseResult<CSSDeclaration> {
  const trimmed = input.trim();

  // Remove trailing semicolon if present
  const cleaned = trimmed.endsWith(";") ? trimmed.slice(0, -1) : trimmed;

  // Split on first colon
  const colonIndex = cleaned.indexOf(":");

  if (colonIndex === -1) {
    return parseErr(
      "declaration",
      createError("invalid-syntax", `Invalid CSS declaration: missing colon in "${input}"`),
    );
  }

  const property = cleaned.slice(0, colonIndex).trim();
  let value = cleaned.slice(colonIndex + 1).trim();

  if (!property) {
    return parseErr(
      "declaration",
      createError("missing-value", `Invalid CSS declaration: empty property in "${input}"`),
    );
  }

  if (!value) {
    return parseErr("declaration", createError("missing-value", `Invalid CSS declaration: empty value in "${input}"`));
  }

  const importantPattern = /\s*!important$/i;
  let important = false;

  if (importantPattern.test(value)) {
    important = true;
    value = value.replace(importantPattern, "").trim();
  }

  if (!value) {
    return parseErr("declaration", createError("missing-value", `Invalid CSS declaration: empty value in "${input}"`));
  }

  return parseOk({ property, value, important });
}

/**
 * Internal unsafe dispatch function for calling property parsers.
 *
 * This function isolates the `as never` type assertion required because TypeScript
 * cannot connect a dynamic property string to the specific parser signature.
 *
 * **⚠️ TYPE SAFETY BOUNDARY:**
 * The risk is that the parser and input might not match. This is mitigated by:
 * - PropertyRegistry ensures parsers are registered with correct types
 * - Runtime multiValue check ensures correct input type (string vs AST)
 * - This function makes the type-safety boundary explicit and auditable
 *
 * @internal
 */
function unsafeCallParser(parser: unknown, input: unknown): ParseResult<unknown> {
  // The `as never` cast is necessary here. The parser function signature is generic,
  // but we're calling it with a dynamically determined input type.
  // We cast both parser and input to bypass TypeScript's strict type checking.
  return (parser as (input: never) => ParseResult<unknown>)(input as never);
}

/**
 * Internal unsafe dispatch function for calling generateDeclaration.
 *
 * This function isolates the `as never` type assertion required because TypeScript
 * cannot infer the generic TProperty type from a runtime string value.
 *
 * **⚠️ TYPE SAFETY BOUNDARY:**
 * The risk is that property and IR might not match. This is mitigated by:
 * - The IR was just parsed by the property's parser, so it should match
 * - PropertyRegistry ensures type consistency at registration time
 * - This function makes the type-safety boundary explicit and auditable
 *
 * @internal
 */
function unsafeGenerateDeclaration(property: string, ir: unknown): GenerateResult {
  // The `as never` casts are necessary here. TypeScript cannot connect
  // the runtime string `property` to the specific generic type TProperty.
  return generateDeclaration({
    property: property as never,
    ir: ir as never,
  });
}

/**
 * Conditionally adds the important flag to a declaration result.
 * Only adds the field if important is true.
 *
 * @internal
 */
function withImportant<T extends DeclarationResult>(decl: T, important: boolean): T {
  return important ? { ...decl, important: true } : decl;
}


=== File: packages/b_declarations/src/properties/background-attachment/definition.ts ===
// b_path:: packages/b_declarations/src/properties/background-attachment/definition.ts
import { defineProperty } from "../../core";
import { parseBackgroundAttachment } from "./parser";
import { generateBackgroundAttachment } from "./generator";
import type { BackgroundAttachmentIR } from "./types";
import { BACKGROUND_ATTACHMENT } from "@b/keywords";

/**
 * background-attachment property definition.
 */
export const backgroundAttachment = defineProperty<BackgroundAttachmentIR>({
  name: "background-attachment",
  syntax: "<attachment>#",
  allowedKeywords: BACKGROUND_ATTACHMENT,
  parser: parseBackgroundAttachment,
  multiValue: true,
  generator: generateBackgroundAttachment,
  inherited: false,
  initial: "scroll",
});


=== File: packages/b_declarations/src/properties/background-attachment/generator.ts ===
// b_path:: packages/b_declarations/src/properties/background-attachment/generator.ts
import { generateOk, type GenerateResult } from "@b/types";
import * as Generators from "@b/generators";
import { generateValue } from "../../utils";
import type { BackgroundAttachmentIR } from "./types";

/**
 * Generate CSS for background-attachment property.
 * Returns value-only (no property prefix).
 */
export function generateBackgroundAttachment(ir: BackgroundAttachmentIR): GenerateResult {
  if (ir.kind === "keyword") {
    return generateOk(ir.value);
  }

  const layerStrings: string[] = [];
  for (const layer of ir.values) {
    const result = generateValue(layer, Generators.Background.Attachment.generate);
    if (!result.ok) return result;
    layerStrings.push(result.value);
  }

  return generateOk(layerStrings.join(", "));
}


=== File: packages/b_declarations/src/properties/background-attachment/index.ts ===
// b_path:: packages/b_declarations/src/properties/background-attachment/index.ts
export * from "./types";
export * from "./parser";
export * from "./generator";
export * from "./definition";


=== File: packages/b_declarations/src/properties/background-attachment/parser.ts ===
// b_path:: packages/b_declarations/src/properties/background-attachment/parser.ts
import type { ParseResult } from "@b/types";
import * as Parsers from "@b/parsers";
import { createMultiValueParser } from "../../utils";
import type { BackgroundAttachmentIR, AttachmentValue } from "./types";
import type * as csstree from "@eslint/css-tree";

export const parseBackgroundAttachment = createMultiValueParser<AttachmentValue, BackgroundAttachmentIR>({
  propertyName: "background-attachment",

  itemParser(valueNode: csstree.Value): ParseResult<AttachmentValue> {
    return Parsers.Background.Attachment.parse(valueNode);
  },

  aggregator(layers: AttachmentValue[]): BackgroundAttachmentIR {
    return { kind: "list", values: layers };
  },
});


=== File: packages/b_declarations/src/properties/background-attachment/types.ts ===
// b_path:: packages/b_declarations/src/properties/background-attachment/types.ts
import { z } from "zod";
import * as Keywords from "@b/keywords";
import { cssValueSchema } from "@b/types";

/**
 * Concrete background-attachment values per CSS spec.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/background-attachment
 */
const backgroundAttachmentSchema = Keywords.backgroundAttachment;

/**
 * background-attachment value with universal CSS function support.
 * Can be a concrete keyword OR a CssValue (var(), calc(), etc.)
 */
const backgroundAttachmentValueSchema = z.union([backgroundAttachmentSchema, cssValueSchema]);

export type AttachmentValue = z.infer<typeof backgroundAttachmentValueSchema>;

/**
 * The final IR schema for the entire `background-attachment` property.
 * This is the top-level property type.
 * It's a discriminated union of a keyword OR a list of component values.
 */
export const backgroundAttachmentIRSchema = z.discriminatedUnion("kind", [
  // OPTION A: The entire property is a CSS-wide keyword.
  z.object({
    kind: z.literal("keyword"),
    value: Keywords.cssWide, // The vocabulary is CSS-wide keywords.
  }),

  // OPTION B: The entire property is a list of <attachment> values.
  z.object({
    kind: z.literal("list"),
    values: z.array(backgroundAttachmentValueSchema).min(1),
  }),
]);

export type BackgroundAttachmentIR = z.infer<typeof backgroundAttachmentIRSchema>;


=== File: packages/b_declarations/src/properties/background-blend-mode/definition.ts ===
// b_path:: packages/b_declarations/src/properties/background-blend-mode/definition.ts

import { defineProperty } from "../../core";
import { parseBackgroundBlendMode } from "./parser";
import { generateBackgroundBlendMode } from "./generator";
import type { BackgroundBlendModeIR } from "./types";

export const backgroundBlendMode = defineProperty<BackgroundBlendModeIR>({
  name: "background-blend-mode",
  syntax: "<blend-mode>#",
  parser: parseBackgroundBlendMode,
  multiValue: true,
  generator: generateBackgroundBlendMode,
  inherited: false,
  initial: "normal",
});


=== File: packages/b_declarations/src/properties/background-blend-mode/generator.ts ===
// b_path:: packages/b_declarations/src/properties/background-blend-mode/generator.ts

import { generateOk, type GenerateResult } from "@b/types";
import * as Generators from "@b/generators";
import { generateValue } from "../../utils";
import type { BackgroundBlendModeIR } from "./types";

export function generateBackgroundBlendMode(ir: BackgroundBlendModeIR): GenerateResult {
  if (ir.kind === "keyword") {
    return generateOk(ir.value);
  }

  const layerStrings: string[] = [];
  for (const value of ir.values) {
    const result = generateValue(value, Generators.BlendMode.generate);
    if (!result.ok) return result;
    layerStrings.push(result.value);
  }

  return generateOk(layerStrings.join(", "));
}


=== File: packages/b_declarations/src/properties/background-blend-mode/index.ts ===
// b_path:: packages/b_declarations/src/properties/background-blend-mode/index.ts

export * from "./types";
export * from "./parser";
export * from "./generator";
export * from "./definition";


=== File: packages/b_declarations/src/properties/background-blend-mode/parser.ts ===
// b_path:: packages/b_declarations/src/properties/background-blend-mode/parser.ts

import type { ParseResult } from "@b/types";
import * as Parsers from "@b/parsers";
import { createMultiValueParser } from "../../utils";
import type { BackgroundBlendModeIR, BackgroundBlendModeValue } from "./types";
import type * as csstree from "@eslint/css-tree";

export const parseBackgroundBlendMode = createMultiValueParser<BackgroundBlendModeValue, BackgroundBlendModeIR>({
  propertyName: "background-blend-mode",

  itemParser(valueNode: csstree.Value): ParseResult<BackgroundBlendModeValue> {
    return Parsers.BlendMode.parse(valueNode);
  },

  aggregator(values: BackgroundBlendModeValue[]): BackgroundBlendModeIR {
    return { kind: "list", values };
  },
});


=== File: packages/b_declarations/src/properties/background-blend-mode/types.ts ===
// b_path:: packages/b_declarations/src/properties/background-blend-mode/types.ts

import { z } from "zod";
import * as Keywords from "@b/keywords";
import { cssValueSchema } from "@b/types";

/**
 * background-blend-mode value with universal CSS function support.
 */
const backgroundBlendModeValueSchema = z.union([Keywords.blendMode, cssValueSchema]);

export type BackgroundBlendModeValue = z.infer<typeof backgroundBlendModeValueSchema>;

/**
 * The final IR for the entire `background-blend-mode` property.
 */
export const backgroundBlendModeIRSchema = z.discriminatedUnion("kind", [
  z.object({
    kind: z.literal("keyword"),
    value: Keywords.cssWide,
  }),
  z.object({
    kind: z.literal("list"),
    values: z.array(backgroundBlendModeValueSchema).min(1),
  }),
]);

export type BackgroundBlendModeIR = z.infer<typeof backgroundBlendModeIRSchema>;


=== File: packages/b_declarations/src/properties/background-clip/definition.ts ===
// b_path:: packages/b_declarations/src/properties/background-clip/definition.ts
import { defineProperty } from "../../core";
import { parseBackgroundClip } from "./parser";
import { generateBackgroundClip } from "./generator";
import type { BackgroundClipIR } from "./types";
import { BACKGROUND_CLIP } from "@b/keywords";

/**
 * background-clip property definition.
 */
export const backgroundClip = defineProperty<BackgroundClipIR>({
  name: "background-clip",
  syntax: "<box>#",
  allowedKeywords: BACKGROUND_CLIP,
  parser: parseBackgroundClip,
  multiValue: true,
  generator: generateBackgroundClip,
  inherited: false,
  initial: "border-box",
});


=== File: packages/b_declarations/src/properties/background-clip/generator.ts ===
// b_path:: packages/b_declarations/src/properties/background-clip/generator.ts
import { generateOk, type GenerateResult } from "@b/types";
import * as Generators from "@b/generators";
import { generateValue } from "../../utils";
import type { BackgroundClipIR } from "./types";

/**
 * Generate CSS for background-clip property.
 * Returns value-only (no property prefix).
 */
export function generateBackgroundClip(ir: BackgroundClipIR): GenerateResult {
  if (ir.kind === "keyword") {
    return generateOk(ir.value);
  }

  const layerStrings: string[] = [];
  for (const layer of ir.values) {
    const result = generateValue(layer, Generators.Background.Clip.generate);
    if (!result.ok) return result;
    layerStrings.push(result.value);
  }

  return generateOk(layerStrings.join(", "));
}


=== File: packages/b_declarations/src/properties/background-clip/index.ts ===
// b_path:: packages/b_declarations/src/properties/background-clip/index.ts
export * from "./types";
export * from "./parser";
export * from "./generator";
export * from "./definition";


=== File: packages/b_declarations/src/properties/background-clip/parser.ts ===
// b_path:: packages/b_declarations/src/properties/background-clip/parser.ts
import type * as csstree from "@eslint/css-tree";
import type { ParseResult } from "@b/types";
import type { BackgroundClip } from "@b/keywords";
import * as Parsers from "@b/parsers";
import { createMultiValueParser } from "../../utils";
import type { BackgroundClipIR } from "./types";

export const parseBackgroundClip = createMultiValueParser<BackgroundClip, BackgroundClipIR>({
  propertyName: "background-clip",

  itemParser(valueNode: csstree.Value): ParseResult<BackgroundClip> {
    return Parsers.Background.Clip.parse(valueNode);
  },

  aggregator(layers: BackgroundClip[]): BackgroundClipIR {
    return { kind: "list", values: layers };
  },
});


=== File: packages/b_declarations/src/properties/background-clip/types.ts ===
// b_path:: packages/b_declarations/src/properties/background-clip/types.ts

import { z } from "zod";
import * as Keywords from "@b/keywords";
import { cssValueSchema } from "@b/types";

/**
 * Concrete background-clip values per CSS spec.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip
 */
const backgroundClipSchema = Keywords.backgroundClip;

/**
 * background-clip value with universal CSS function support.
 * Can be a concrete keyword OR a CssValue (var(), calc(), etc.)
 */
const backgroundClipValueSchema = z.union([backgroundClipSchema, cssValueSchema]);

/**
 * The final IR schema for the entire `background-clip` property.
 * This is the top-level property type.
 */
export const backgroundClipIRSchema = z.discriminatedUnion("kind", [
  // OPTION A: The entire property is a CSS-wide keyword.
  z.object({
    kind: z.literal("keyword"),
    value: Keywords.cssWide,
  }),

  // OPTION B: The entire property is a list of <box> values.
  z.object({
    kind: z.literal("list"),
    values: z.array(backgroundClipValueSchema).min(1),
  }),
]);

/**
 * Authoritative type for the `background-clip` property's IR,
 * inferred directly from the schema.
 */
export type BackgroundClipIR = z.infer<typeof backgroundClipIRSchema>;


=== File: packages/b_declarations/src/properties/background-color/definition.ts ===
// b_path:: packages/b_declarations/src/properties/background-color/definition.ts

import { defineProperty } from "../../core";
import { parseBackgroundColor } from "./parser";
import { generateBackgroundColor } from "./generator";
import type { BackgroundColorIR } from "./types";

export const backgroundColor = defineProperty<BackgroundColorIR>({
  name: "background-color",
  syntax: "<color>",
  parser: parseBackgroundColor,
  generator: generateBackgroundColor,
  inherited: false,
  initial: "transparent",
});


=== File: packages/b_declarations/src/properties/background-color/generator.ts ===
// b_path:: packages/b_declarations/src/properties/background-color/generator.ts

import { generateOk, type GenerateResult } from "@b/types";
import * as Generators from "@b/generators";
import type { BackgroundColorIR } from "./types";

export function generateBackgroundColor(ir: BackgroundColorIR): GenerateResult {
  if (ir.kind === "keyword") {
    return generateOk(ir.value);
  }

  const result = Generators.Color.generate(ir.value);
  return result;
}


=== File: packages/b_declarations/src/properties/background-color/index.ts ===
// b_path:: packages/b_declarations/src/properties/background-color/index.ts

export * from "./types";
export * from "./parser";
export * from "./generator";
export * from "./definition";


=== File: packages/b_declarations/src/properties/background-color/parser.ts ===
// b_path:: packages/b_declarations/src/properties/background-color/parser.ts

import type { ParseResult } from "@b/types";
import * as Parsers from "@b/parsers";
import type * as csstree from "@eslint/css-tree";
import type { BackgroundColorIR } from "./types";

export function parseBackgroundColor(ast: csstree.Value): ParseResult<BackgroundColorIR> {
  const firstNode = ast.children.first;

  if (!firstNode) {
    return {
      ok: false,
      property: "background-color",
      value: undefined,
      issues: [{ code: "missing-value", severity: "error", message: "Empty value for background-color" }],
    };
  }

  const colorResult = Parsers.Color.parseNode(firstNode);

  if (colorResult.ok) {
    return {
      ok: true,
      property: "background-color",
      value: { kind: "value", value: colorResult.value },
      issues: colorResult.issues,
    };
  }

  return colorResult as ParseResult<BackgroundColorIR>;
}


=== File: packages/b_declarations/src/properties/background-color/types.ts ===
// b_path:: packages/b_declarations/src/properties/background-color/types.ts

import { z } from "zod";
import { colorSchema } from "@b/types";
import * as Keywords from "@b/keywords";

/**
 * The final IR for the entire `background-color` property.
 */
export const backgroundColorIRSchema = z.discriminatedUnion("kind", [
  z.object({
    kind: z.literal("keyword"),
    value: Keywords.cssWide,
  }),
  z.object({
    kind: z.literal("value"),
    value: colorSchema,
  }),
]);

export type BackgroundColorIR = z.infer<typeof backgroundColorIRSchema>;


=== File: packages/b_declarations/src/properties/background-image/definition.ts ===
// b_path:: packages/b_declarations/src/properties/background-image/definition.ts
import { defineProperty } from "../../core";
import { parseBackgroundImage } from "./parser";
import { generateBackgroundImage } from "./generator";
import type { BackgroundImageIR } from "./types";

/**
 * background-image property definition.
 */
export const backgroundImage = defineProperty<BackgroundImageIR>({
  name: "background-image",
  syntax: "<bg-image>#",
  parser: parseBackgroundImage,
  multiValue: true, // Multi-value parser: handles comma-separated layers
  generator: generateBackgroundImage,
  inherited: false,
  initial: "none",
});


=== File: packages/b_declarations/src/properties/background-image/generator.ts ===
// b_path:: packages/b_declarations/src/properties/background-image/generator.ts
import type { Issue, GenerateResult } from "@b/types";
import * as Generators from "@b/generators";
import { generateValue } from "../../utils";
import type { BackgroundImageIR } from "./types";

/**
 * Generate a background-image CSS value from its IR representation.
 * Returns value-only (no property prefix).
 */
export function generateBackgroundImage(ir: BackgroundImageIR): GenerateResult {
  if (ir.kind === "keyword") {
    return {
      ok: true,
      value: ir.value,
      issues: [],
    };
  }

  const layerStrings: string[] = [];
  const allIssues: Issue[] = [];

  for (let i = 0; i < ir.values.length; i++) {
    const layer = ir.values[i];
    const layerResult = generateValue(layer, (l) => Generators.Image.generate(l));
    if (!layerResult.ok) {
      return layerResult;
    }
    layerStrings.push(layerResult.value);
    allIssues.push(...layerResult.issues);
  }

  return {
    ok: true,
    value: layerStrings.join(", "),
    issues: allIssues,
  };
}


=== File: packages/b_declarations/src/properties/background-image/index.ts ===
// b_path:: packages/b_declarations/src/properties/background-image/index.ts
export * from "./definition";
export * from "./generator";
export * from "./parser";
export * from "./types";


=== File: packages/b_declarations/src/properties/background-image/parser.ts ===
// b_path:: packages/b_declarations/src/properties/background-image/parser.ts

import { parseOk, type ParseResult } from "@b/types";
import * as Parsers from "@b/parsers";
import { createMultiValueParser } from "../../utils";
import type { BackgroundImageIR } from "./types";
import type { Image } from "@b/types";
import type * as csstree from "@eslint/css-tree";

export const parseBackgroundImage = createMultiValueParser<Image, BackgroundImageIR>({
  propertyName: "background-image",

  preParse: (value: string): ParseResult<BackgroundImageIR> | null => {
    if (value.trim().toLowerCase() === "none") {
      return parseOk({ kind: "keyword", value: "none" });
    }
    return null;
  },

  itemParser(valueNode: csstree.Value): ParseResult<Image> {
    return Parsers.Image.parse(valueNode);
  },

  aggregator(layers: Image[]): BackgroundImageIR {
    return { kind: "list", values: layers };
  },
});


=== File: packages/b_declarations/src/properties/background-image/types.ts ===
// b_path:: packages/b_declarations/src/properties/background-image/types.ts
import { imageSchema, cssValueSchema } from "@b/types";
import { z } from "zod";
import * as Keywords from "@b/keywords";

/**
 * Concrete background-image values per CSS spec.
 * Image type now includes "none" at the concrete layer.
 */
const backgroundImageSchema = imageSchema;

/**
 * background-image value with universal CSS function support.
 */
const backgroundImageValueSchema = z.union([backgroundImageSchema, cssValueSchema]);

/**
 * The final IR for the entire `background-image` property.
 */
export const backgroundImageIR = z.discriminatedUnion("kind", [
  z.object({
    kind: z.literal("keyword"),
    value: z.union([Keywords.cssWide, Keywords.none]),
  }),
  z.object({
    kind: z.literal("list"),
    values: z.array(backgroundImageValueSchema).min(1),
  }),
]);

export type BackgroundImageIR = z.infer<typeof backgroundImageIR>;


=== File: packages/b_declarations/src/properties/background-origin/definition.ts ===
// b_path:: packages/b_declarations/src/properties/background-origin/definition.ts
import { defineProperty } from "../../core";
import { parseBackgroundOrigin } from "./parser";
import { generateBackgroundOrigin } from "./generator";
import type { BackgroundOriginIR } from "./types";
import { BACKGROUND_ORIGIN } from "@b/keywords";

/**
 * background-origin property definition.
 */
export const backgroundOrigin = defineProperty<BackgroundOriginIR>({
  name: "background-origin",
  syntax: "<box>#",
  allowedKeywords: BACKGROUND_ORIGIN,
  parser: parseBackgroundOrigin,
  multiValue: true,
  generator: generateBackgroundOrigin,
  inherited: false,
  initial: "padding-box",
});


=== File: packages/b_declarations/src/properties/background-origin/generator.ts ===
// b_path:: packages/b_declarations/src/properties/background-origin/generator.ts
import { generateOk, type GenerateResult } from "@b/types";
import * as Generators from "@b/generators";
import { generateValue } from "../../utils";
import type { BackgroundOriginIR } from "./types";

/**
 * Generate CSS for background-origin property.
 * Returns value-only (no property prefix).
 */
export function generateBackgroundOrigin(ir: BackgroundOriginIR): GenerateResult {
  if (ir.kind === "keyword") {
    return generateOk(ir.value);
  }

  const layerStrings: string[] = [];
  for (const layer of ir.values) {
    const result = generateValue(layer, Generators.Background.Origin.generate);
    if (!result.ok) return result;
    layerStrings.push(result.value);
  }

  return generateOk(layerStrings.join(", "));
}


=== File: packages/b_declarations/src/properties/background-origin/index.ts ===
// b_path:: packages/b_declarations/src/properties/background-origin/index.ts
export * from "./types";
export * from "./parser";
export * from "./generator";
export * from "./definition";


=== File: packages/b_declarations/src/properties/background-origin/parser.ts ===
// b_path:: packages/b_declarations/src/properties/background-origin/parser.ts
import type { ParseResult } from "@b/types";
import * as Parsers from "@b/parsers";
import { createMultiValueParser } from "../../utils";
import type { BackgroundOriginIR } from "./types";
import type * as csstree from "@eslint/css-tree";
import type * as Keywords from "@b/keywords";

export const parseBackgroundOrigin = createMultiValueParser<Keywords.BackgroundOrigin, BackgroundOriginIR>({
  propertyName: "background-origin",

  itemParser(valueNode: csstree.Value): ParseResult<Keywords.BackgroundOrigin> {
    return Parsers.Background.Origin.parse(valueNode);
  },

  aggregator(layers: Keywords.BackgroundOrigin[]): BackgroundOriginIR {
    return { kind: "list", values: layers };
  },
});


=== File: packages/b_declarations/src/properties/background-origin/types.ts ===
// b_path:: packages/b_declarations/src/properties/background-origin/types.ts

import { z } from "zod";
import * as Keywords from "@b/keywords";
import { cssValueSchema } from "@b/types";

/**
 * Concrete background-origin values per CSS spec.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/background-origin
 */
const backgroundOriginSchema = Keywords.backgroundOrigin;

/**
 * background-origin value with universal CSS function support.
 * Can be a concrete keyword OR a CssValue (var(), calc(), etc.)
 */
const backgroundOriginValueSchema = z.union([backgroundOriginSchema, cssValueSchema]);

/**
 * The final IR schema for the entire `background-origin` property.
 * This is the top-level property type.
 */
export const backgroundOriginIR = z.discriminatedUnion("kind", [
  // OPTION A: The entire property is a CSS-wide keyword.
  z.object({
    kind: z.literal("keyword"),
    value: Keywords.cssWide,
  }),

  // OPTION B: The entire property is a list of <background-origin> values.
  z.object({
    kind: z.literal("list"),
    values: z.array(backgroundOriginValueSchema).min(1),
  }),
]);

export type BackgroundOriginIR = z.infer<typeof backgroundOriginIR>;


=== File: packages/b_declarations/src/properties/background-position/definition.ts ===
// b_path:: packages/b_declarations/src/properties/background-position/definition.ts

import { defineProperty } from "../../core";
import { parseBackgroundPosition } from "./parser";
import { generateBackgroundPosition } from "./generator";
import type { BackgroundPositionIR } from "./types";

export const backgroundPosition = defineProperty<BackgroundPositionIR>({
  name: "background-position",
  syntax: "<bg-position>#",
  parser: parseBackgroundPosition,
  multiValue: true,
  generator: generateBackgroundPosition,
  inherited: false,
  initial: "0% 0%",
});


=== File: packages/b_declarations/src/properties/background-position/generator.ts ===
// b_path:: packages/b_declarations/src/properties/background-position/generator.ts

import { generateOk, type GenerateResult } from "@b/types";
import * as Generators from "@b/generators";
import { generateValue } from "../../utils";
import type { BackgroundPositionIR } from "./types";

export function generateBackgroundPosition(ir: BackgroundPositionIR): GenerateResult {
  if (ir.kind === "keyword") {
    return generateOk(ir.value);
  }

  const layerStrings: string[] = [];
  for (const value of ir.values) {
    const result = generateValue(value, Generators.Position.generate);
    if (!result.ok) return result;
    layerStrings.push(result.value);
  }

  return generateOk(layerStrings.join(", "));
}


=== File: packages/b_declarations/src/properties/background-position/index.ts ===
// b_path:: packages/b_declarations/src/properties/background-position/index.ts

export * from "./types";
export * from "./parser";
export * from "./generator";
export * from "./definition";


=== File: packages/b_declarations/src/properties/background-position/parser.ts ===
// b_path:: packages/b_declarations/src/properties/background-position/parser.ts

import type { ParseResult, Position2D } from "@b/types";
import * as Parsers from "@b/parsers";
import { createMultiValueParser } from "../../utils";
import type { BackgroundPositionIR } from "./types";
import type * as csstree from "@eslint/css-tree";

export const parseBackgroundPosition = createMultiValueParser<Position2D, BackgroundPositionIR>({
  propertyName: "background-position",

  itemParser(valueNode: csstree.Value): ParseResult<Position2D> {
    const nodes = Array.from(valueNode.children);
    const result = Parsers.Position.parsePosition2D(nodes, 0);
    if (result.ok) {
      return {
        ok: true,
        property: "background-position",
        value: result.value.position,
        issues: result.issues,
      };
    }
    return result as ParseResult<Position2D>;
  },

  aggregator(values: Position2D[]): BackgroundPositionIR {
    return { kind: "list", values };
  },
});


=== File: packages/b_declarations/src/properties/background-position/types.ts ===
// b_path:: packages/b_declarations/src/properties/background-position/types.ts

import { z } from "zod";
import { position2DSchema, cssValueSchema } from "@b/types";
import * as Keywords from "@b/keywords";

/**
 * background-position value with universal CSS function support.
 */
const backgroundPositionValueSchema = z.union([position2DSchema, cssValueSchema]);

/**
 * The final IR for the entire `background-position` property.
 */
export const backgroundPositionIRSchema = z.discriminatedUnion("kind", [
  z.object({
    kind: z.literal("keyword"),
    value: Keywords.cssWide,
  }),
  z.object({
    kind: z.literal("list"),
    values: z.array(backgroundPositionValueSchema).min(1),
  }),
]);

export type BackgroundPositionIR = z.infer<typeof backgroundPositionIRSchema>;


=== File: packages/b_declarations/src/properties/background-repeat/definition.ts ===
// b_path:: packages/b_declarations/src/properties/background-repeat/definition.ts
import { defineProperty } from "../../core";
import { parseBackgroundRepeat } from "./parser";
import { generateBackgroundRepeat } from "./generator";
import type { BackgroundRepeatIR } from "./types";

/**
 * background-repeat property definition.
 */
export const backgroundRepeat = defineProperty<BackgroundRepeatIR>({
  name: "background-repeat",
  syntax: "<repeat-style>#",
  parser: parseBackgroundRepeat,
  multiValue: true,
  generator: generateBackgroundRepeat,
  inherited: false,
  initial: "repeat",
});


=== File: packages/b_declarations/src/properties/background-repeat/generator.ts ===
// b_path:: packages/b_declarations/src/properties/background-repeat/generator.ts
import { generateOk, type GenerateResult } from "@b/types";
import * as Generators from "@b/generators";
import { generateValue } from "../../utils";
import type { BackgroundRepeatIR } from "./types";

/**
 * Generate CSS for background-repeat property.
 * Returns value-only (no property prefix).
 */
export function generateBackgroundRepeat(ir: BackgroundRepeatIR): GenerateResult {
  if (ir.kind === "keyword") {
    return generateOk(ir.value);
  }

  const layerStrings: string[] = [];
  for (const layer of ir.values) {
    const result = generateValue(layer, Generators.Background.Repeat.generate);
    if (!result.ok) return result;
    layerStrings.push(result.value);
  }

  return generateOk(layerStrings.join(", "));
}


=== File: packages/b_declarations/src/properties/background-repeat/index.ts ===
// b_path:: packages/b_declarations/src/properties/background-repeat/index.ts
export * from "./types";
export * from "./parser";
export * from "./generator";
export * from "./definition";


=== File: packages/b_declarations/src/properties/background-repeat/parser.ts ===
// b_path:: packages/b_declarations/src/properties/background-repeat/parser.ts
import type { ParseResult, RepeatStyle, CssValue } from "@b/types";
import * as Parsers from "@b/parsers";
import { createMultiValueParser } from "../../utils";
import type { BackgroundRepeatIR, RepeatStyleValue } from "./types";
import type * as csstree from "@eslint/css-tree";

export const parseBackgroundRepeat = createMultiValueParser<RepeatStyleValue, BackgroundRepeatIR>({
  propertyName: "background-repeat",

  itemParser(valueNode: csstree.Value): ParseResult<RepeatStyle | CssValue> {
    return Parsers.Background.Repeat.parse(valueNode);
  },

  aggregator(layers: RepeatStyleValue[]): BackgroundRepeatIR {
    return { kind: "list", values: layers };
  },
});


=== File: packages/b_declarations/src/properties/background-repeat/types.ts ===
// b_path:: packages/b_declarations/src/properties/background-repeat/types.ts

import { z } from "zod";
import { repeatStyleSchema, cssValueSchema } from "@b/types";
import * as Keywords from "@b/keywords";

/**
 * Concrete background-repeat values per CSS spec.
 */
const backgroundRepeatSchema = repeatStyleSchema;

/**
 * background-repeat value with universal CSS function support.
 * Can be a concrete repeat-style OR a CssValue (var(), calc(), etc.)
 */
const backgroundRepeatValueSchema = z.union([backgroundRepeatSchema, cssValueSchema]);

export type RepeatStyleValue = z.infer<typeof backgroundRepeatValueSchema>;

/**
 * The final IR schema for the entire `background-repeat` property.
 */
export const backgroundRepeatIRSchema = z.discriminatedUnion("kind", [
  // OPTION A: The entire property is a CSS-wide keyword.
  z.object({
    kind: z.literal("keyword"),
    value: Keywords.cssWide,
  }),

  // OPTION B: The entire property is a list of <repeat-style> values.
  z.object({
    kind: z.literal("list"),
    values: z.array(backgroundRepeatValueSchema).min(1),
  }),
]);

/**
 * Authoritative type for the `background-repeat` property's IR,
 * inferred directly from the schema.
 */
export type BackgroundRepeatIR = z.infer<typeof backgroundRepeatIRSchema>;


=== File: packages/b_declarations/src/properties/background-size/definition.ts ===
// b_path:: packages/b_declarations/src/properties/background-size/definition.ts
// packages/b_declarations/src/properties/background-size/definition.ts

import { defineProperty } from "../../core";
import { parseBackgroundSize } from "./parser";
import { generateBackgroundSize } from "./generator";
import type { BackgroundSizeIR } from "./types";

export const backgroundSize = defineProperty<BackgroundSizeIR>({
  name: "background-size",
  syntax: "<bg-size>#",
  parser: parseBackgroundSize,
  generator: generateBackgroundSize,
  multiValue: true,
  inherited: false,
  initial: "auto",
});


=== File: packages/b_declarations/src/properties/background-size/generator.ts ===
// b_path:: packages/b_declarations/src/properties/background-size/generator.ts

import { generateOk, type GenerateResult } from "@b/types";
import * as Generators from "@b/generators";
import { generateValue } from "../../utils";
import type { BackgroundSizeIR } from "./types";

/**
 * Generate CSS for background-size property.
 * Returns value-only (no property prefix).
 */
export function generateBackgroundSize(ir: BackgroundSizeIR): GenerateResult {
  if (ir.kind === "keyword") {
    return generateOk(ir.value);
  }

  const valueStrings: string[] = [];

  for (let i = 0; i < ir.values.length; i++) {
    const result = generateValue(ir.values[i], Generators.Background.Size.generate);
    if (!result.ok) return result;
    valueStrings.push(result.value);
  }

  return generateOk(valueStrings.join(", "));
}


=== File: packages/b_declarations/src/properties/background-size/index.ts ===
// b_path:: packages/b_declarations/src/properties/background-size/index.ts

export * from "./types";
export * from "./parser";
export * from "./generator";
export * from "./definition";


=== File: packages/b_declarations/src/properties/background-size/parser.ts ===
// b_path:: packages/b_declarations/src/properties/background-size/parser.ts

import type { ParseResult, BgSize } from "@b/types";
import * as Parsers from "@b/parsers";
import { createMultiValueParser } from "../../utils";
import type * as csstree from "@eslint/css-tree";
import type { BackgroundSizeIR } from "./types";

export const parseBackgroundSize = createMultiValueParser<BgSize, BackgroundSizeIR>({
  propertyName: "background-size",

  itemParser(valueNode: csstree.Value): ParseResult<BgSize> {
    return Parsers.Background.Size.parse(valueNode);
  },

  aggregator(values: BgSize[]): BackgroundSizeIR {
    return { kind: "list", values };
  },
});


=== File: packages/b_declarations/src/properties/background-size/types.ts ===
// b_path:: packages/b_declarations/src/properties/background-size/types.ts
import { z } from "zod";
import { bgSizeSchema, cssValueSchema } from "@b/types";
import * as Keywords from "@b/keywords";

/**
 * Concrete background-size values per CSS spec.
 */
const backgroundSizeSchema = bgSizeSchema;

/**
 * background-size value with universal CSS function support.
 * Can be a concrete bg-size (cover, contain, explicit dimensions)
 * OR a CssValue (var(), calc(), etc.)
 */
const backgroundSizeValueSchema = z.union([backgroundSizeSchema, cssValueSchema]);

/**
 * The final IR for the entire `background-size` property.
 */
export const backgroundSizeIR = z.discriminatedUnion("kind", [
  z.object({
    kind: z.literal("keyword"),
    value: Keywords.cssWide,
  }),
  z.object({
    kind: z.literal("list"),
    values: z.array(backgroundSizeValueSchema).min(1),
  }),
]);

export type BackgroundSizeIR = z.infer<typeof backgroundSizeIR>;


=== File: packages/b_declarations/src/properties/custom-property/definition.ts ===
// b_path:: packages/b_declarations/src/properties/custom-property/definition.ts
import { defineProperty } from "../../core";
import { generateCustomProperty } from "./generator";
import { parseCustomProperty } from "./parser";
import type { CustomPropertyIR } from "./types";

/**
 * Custom property definition (--*)
 * Note: This is a template - actual properties are dynamic
 * Special case in parser: receives raw string (not AST) to preserve exact formatting
 */
export const customProperty = defineProperty<CustomPropertyIR>({
  name: "--*",
  syntax: "<declaration-value>",
  parser: parseCustomProperty,
  multiValue: false,
  rawValue: true,
  generator: generateCustomProperty,
  inherited: true,
  initial: "",
});


=== File: packages/b_declarations/src/properties/custom-property/generator.ts ===
// b_path:: packages/b_declarations/src/properties/custom-property/generator.ts
import type { GenerateResult } from "@b/types";
import { generateOk } from "@b/types";
import type { CustomPropertyIR } from "./types";

/**
 * Generate CSS from custom property IR
 */
export function generateCustomProperty(ir: CustomPropertyIR): GenerateResult {
  return generateOk(ir.value);
}


=== File: packages/b_declarations/src/properties/custom-property/index.ts ===
// b_path:: packages/b_declarations/src/properties/custom-property/index.ts
export * from "./types";
export * from "./parser";
export * from "./generator";
export * from "./definition";


=== File: packages/b_declarations/src/properties/custom-property/parser.ts ===
// b_path:: packages/b_declarations/src/properties/custom-property/parser.ts
import type { ParseResult } from "@b/types";
import { createError, parseErr, parseOk } from "@b/types";
import type { CustomPropertyIR } from "./types";

/**
 * Parse custom property value
 * Stores raw string per CSS spec (no interpretation)
 * Receives raw string to preserve exact whitespace/formatting
 * @see https://www.w3.org/TR/css-variables-1/#defining-variables
 */
export function parseCustomProperty(value: string): ParseResult<CustomPropertyIR> {
  const trimmed = value.trim();
  if (trimmed === "") {
    return parseErr("custom-property", createError("missing-value", "Custom property value cannot be empty"));
  }

  return parseOk({ kind: "raw", value: trimmed });
}


=== File: packages/b_declarations/src/properties/custom-property/types.ts ===
// b_path:: packages/b_declarations/src/properties/custom-property/types.ts

/**
 * Custom property IR (--*)
 * Stores value as an unparsed string per CSS spec.
 * We use a "raw" kind to distinguish it from standard keywords or values.
 * @see https://www.w3.org/TR/css-variables-1/#defining-variables
 */
export type CustomPropertyIR = { kind: "raw"; value: string };


=== File: packages/b_declarations/src/properties/definitions.ts ===
// b_path:: packages/b_declarations/src/properties/definitions.ts

/**
 * Central registry of all property definitions.
 *
 * ⚠️ THIS FILE IS AUTO-GENERATED. DO NOT EDIT MANUALLY.
 *
 * Run: pnpm generate:definitions
 *
 * This is the single source of truth for:
 * - Property names → IR type mapping (derives PropertyIRMap)
 * - Property metadata (multiValue, rawValue flags)
 * - Type-level contract enforcement
 *
 * Architecture:
 * - Each property folder exports its definition (e.g., backgroundAttachment)
 * - This file aggregates them into PROPERTY_DEFINITIONS
 * - PropertyIRMap is derived from this via type inference
 * - Type-level contracts check actual definitions, not generic types
 *
 * When adding a new property:
 * 1. Create property folder with definition.ts that exports a definition
 * 2. Run: pnpm generate:definitions
 * 3. PropertyIRMap auto-updates via type inference
 * 4. Type-level contracts validate multiValue → list IR
 */

import { customProperty } from "./custom-property/definition";
import { backgroundAttachment } from "./background-attachment/definition";
import { backgroundBlendMode } from "./background-blend-mode/definition";
import { backgroundClip } from "./background-clip/definition";
import { backgroundColor } from "./background-color/definition";
import { backgroundImage } from "./background-image/definition";
import { backgroundOrigin } from "./background-origin/definition";
import { backgroundPosition } from "./background-position/definition";
import { backgroundRepeat } from "./background-repeat/definition";
import { backgroundSize } from "./background-size/definition";
import { mixBlendMode } from "./mix-blend-mode/definition";

/**
 * Central definitions object.
 *
 * Keys are CSS property names (e.g., "background-color").
 * Values are PropertyDefinition instances.
 *
 * This object is the source of truth for:
 * - Runtime property lookup
 * - Type-level IR extraction
 * - Contract validation
 */
export const PROPERTY_DEFINITIONS = {
  "--*": customProperty,
  "background-attachment": backgroundAttachment,
  "background-blend-mode": backgroundBlendMode,
  "background-clip": backgroundClip,
  "background-color": backgroundColor,
  "background-image": backgroundImage,
  "background-origin": backgroundOrigin,
  "background-position": backgroundPosition,
  "background-repeat": backgroundRepeat,
  "background-size": backgroundSize,
  "mix-blend-mode": mixBlendMode,
} as const;

/**
 * Type alias for the definitions object.
 * Used for type-level operations.
 */
export type PropertyDefinitions = typeof PROPERTY_DEFINITIONS;


=== File: packages/b_declarations/src/properties/index.ts ===
// b_path:: packages/b_declarations/src/properties/index.ts

// Central definitions export (single source of truth)
export * from "./definitions";

// Import before other properties that might depend on it
export * from "./custom-property";

export * from "./background-attachment";
export * from "./background-blend-mode";
export * from "./background-clip";
export * from "./background-color";
export * from "./background-image";
export * from "./background-origin";
export * from "./background-position";
export * from "./background-repeat";
export * from "./background-size";
export * from "./mix-blend-mode";

// Mark registry as initialized after all properties are loaded
// This is a side-effect import that happens when this module is imported
import { propertyRegistry } from "../core/registry";
propertyRegistry.markInitialized();


=== File: packages/b_declarations/src/properties/mix-blend-mode/definition.ts ===
// b_path:: packages/b_declarations/src/properties/mix-blend-mode/definition.ts

import { defineProperty } from "../../core";
import { parseMixBlendMode } from "./parser";
import { generateMixBlendMode } from "./generator";
import type { MixBlendModeIR } from "./types";

export const mixBlendMode = defineProperty<MixBlendModeIR>({
  name: "mix-blend-mode",
  syntax: "<blend-mode>",
  parser: parseMixBlendMode,
  multiValue: false,
  generator: generateMixBlendMode,
  inherited: false,
  initial: "normal",
});


=== File: packages/b_declarations/src/properties/mix-blend-mode/generator.ts ===
// b_path:: packages/b_declarations/src/properties/mix-blend-mode/generator.ts

import { generateOk, type GenerateResult } from "@b/types";
import * as Generators from "@b/generators";
import { generateValue } from "../../utils";
import type { MixBlendModeIR } from "./types";

export function generateMixBlendMode(ir: MixBlendModeIR): GenerateResult {
  if (ir.kind === "keyword") {
    return generateOk(ir.value);
  }

  return generateValue(ir.value, Generators.BlendMode.generate);
}


=== File: packages/b_declarations/src/properties/mix-blend-mode/index.ts ===
// b_path:: packages/b_declarations/src/properties/mix-blend-mode/index.ts

export * from "./types";
export * from "./parser";
export * from "./generator";
export * from "./definition";


=== File: packages/b_declarations/src/properties/mix-blend-mode/parser.ts ===
// b_path:: packages/b_declarations/src/properties/mix-blend-mode/parser.ts

import type { ParseResult } from "@b/types";
import * as Parsers from "@b/parsers";
import type * as csstree from "@eslint/css-tree";
import type { MixBlendModeIR } from "./types";

export function parseMixBlendMode(ast: csstree.Value): ParseResult<MixBlendModeIR> {
  const firstNode = ast.children.first;

  if (!firstNode) {
    return {
      ok: false,
      property: "mix-blend-mode",
      value: undefined,
      issues: [
        {
          code: "missing-value",
          severity: "error",
          message: "Empty value for mix-blend-mode",
        },
      ],
    };
  }

  const result = Parsers.BlendMode.parse(ast);

  if (result.ok) {
    return {
      ok: true,
      property: "mix-blend-mode",
      value: { kind: "value", value: result.value },
      issues: result.issues,
    };
  }

  return result as ParseResult<MixBlendModeIR>;
}


=== File: packages/b_declarations/src/properties/mix-blend-mode/types.ts ===
// b_path:: packages/b_declarations/src/properties/mix-blend-mode/types.ts

import { z } from "zod";
import * as Keywords from "@b/keywords";
import { cssValueSchema } from "@b/types";

/**
 * mix-blend-mode value with universal CSS function support.
 */
const mixBlendModeValueSchema = z.union([Keywords.blendMode, cssValueSchema]);

export type MixBlendModeValue = z.infer<typeof mixBlendModeValueSchema>;

/**
 * The final IR for the entire `mix-blend-mode` property.
 */
export const mixBlendModeIRSchema = z.discriminatedUnion("kind", [
  z.object({
    kind: z.literal("keyword"),
    value: Keywords.cssWide,
  }),
  z.object({
    kind: z.literal("value"),
    value: mixBlendModeValueSchema,
  }),
]);

export type MixBlendModeIR = z.infer<typeof mixBlendModeIRSchema>;


=== File: packages/b_declarations/src/test/property-contract.ts ===
// b_path:: packages/b_declarations/src/test/property-contract.ts

import { describe, it, expect } from "vitest";
import { parseDeclaration } from "../parser";
import { generateDeclaration } from "../generator";
import type { ParseResult, GenerateResult } from "@b/types";

/**
 * Normalize CSS string for comparison (whitespace, etc.)
 */
function norm(css: string): string {
  return css.trim().replace(/\s+/g, " ");
}

/**
 * Test case for parsing a declaration.
 */
export interface ParseCase<TIR = unknown> {
  /** Full CSS declaration: "property: value" */
  css: string;
  /** Expected parse outcome */
  expectOk: boolean;
  /** Optional: partial IR shape to validate against */
  irContains?: Partial<TIR>;
}

/**
 * Test case for generating a declaration.
 */
export interface GenerateCase<TIR = unknown> {
  /** Property name */
  property: string;
  /** IR to generate from */
  ir: TIR;
  /** Expected generate outcome */
  expectOk: boolean;
  /** Optional: expected CSS output (full "prop: value" or just value) */
  expectValue?: string;
}

/**
 * Test case for roundtrip (parse → generate).
 */
export interface RoundtripCase {
  /** Input CSS declaration: "property: value" */
  css: string;
  /** Optional: normalized expected output (defaults to input) */
  expectCss?: string;
}

/**
 * Options for running standardized property tests.
 */
export interface RunPropertyTestsOptions<TIR> {
  /** CSS property name */
  property: string;
  /** Optional: Zod schema or validator for IR */
  schema?: { parse: (input: unknown) => TIR };
  /** Parse test cases */
  parse?: ParseCase<TIR>[];
  /** Generate test cases */
  generate?: GenerateCase<TIR>[];
  /** Roundtrip test cases */
  roundtrip?: RoundtripCase[];
}

/**
 * Standardized contract tests for a CSS property.
 *
 * Enforces consistent behavior across:
 * - parseDeclaration
 * - generateDeclaration
 * - roundtrip consistency
 * - optional IR schema validation
 *
 * @example
 * ```typescript
 * runPropertyTests<BackgroundSizeIR>({
 *   property: "background-size",
 *   schema: backgroundSizeIRSchema,
 *   parse: [
 *     { css: "background-size: auto", expectOk: true, irContains: { kind: "list" } },
 *     { css: "background-size: invalid", expectOk: false },
 *   ],
 *   roundtrip: [
 *     { css: "background-size: cover" },
 *     { css: "background-size: 100px 200px" },
 *   ],
 * });
 * ```
 */
export function runPropertyTests<TIR>(opts: RunPropertyTestsOptions<TIR>): void {
  const { property } = opts;

  if (opts.parse?.length) {
    describe(`${property} :: parseDeclaration`, () => {
      for (const c of opts.parse!) {
        it(c.css, () => {
          const res = parseDeclaration(c.css) as ParseResult<{ property: string; ir: TIR }>;

          if (c.expectOk) {
            expect(res.ok).toBe(true);
            if (!res.ok) return;

            // Verify property name is correct
            expect(res.value.property).toBe(property);

            // Optional: validate IR against schema (throws if invalid)
            if (opts.schema) {
              opts.schema.parse(res.value.ir);
            }

            // Optional: verify IR contains expected shape
            if (c.irContains) {
              expect(res.value.ir).toMatchObject(c.irContains);
            }
          } else {
            expect(res.ok).toBe(false);
          }
        });
      }
    });
  }

  if (opts.generate?.length) {
    describe(`${property} :: generateDeclaration`, () => {
      for (const c of opts.generate!) {
        const label = JSON.stringify(c.ir).substring(0, 60);
        it(label, () => {
          const res = generateDeclaration({
            property: c.property as never,
            ir: c.ir as never,
          }) as GenerateResult;

          if (c.expectOk) {
            expect(res.ok).toBe(true);
            if (!res.ok) return;

            if (c.expectValue) {
              expect(norm(res.value)).toBe(norm(c.expectValue));
            }
          } else {
            expect(res.ok).toBe(false);
          }
        });
      }
    });
  }

  if (opts.roundtrip?.length) {
    describe(`${property} :: roundtrip`, () => {
      for (const c of opts.roundtrip!) {
        it(c.css, () => {
          // Parse
          const parsed = parseDeclaration(c.css) as ParseResult<{ property: string; ir: TIR }>;
          expect(parsed.ok).toBe(true);
          if (!parsed.ok) return;
          expect(parsed.value.property).toBe(property);

          // Generate
          const gen = generateDeclaration({
            property: property as never,
            ir: parsed.value.ir as never,
          }) as GenerateResult;

          expect(gen.ok).toBe(true);
          if (!gen.ok) return;

          // Compare
          const expected = c.expectCss ?? c.css;
          expect(norm(gen.value)).toBe(norm(expected));
        });
      }
    });
  }
}


=== File: packages/b_declarations/src/types.derived.ts ===
// b_path:: packages/b_declarations/src/types.derived.ts

/**
 * Type derivations from PROPERTY_DEFINITIONS.
 *
 * This file derives PropertyIRMap from the actual definitions,
 * replacing the old codegen approach with type-level extraction.
 *
 * Benefits:
 * - Single source of truth (definitions.ts)
 * - No manual sync between types.map.ts and registry
 * - Type-level contracts check REAL definitions
 */

import type { PropertyDefinitions } from "./properties/definitions";
import type { PropertyDefinition } from "./types";

/**
 * Extract IR type from a PropertyDefinition.
 *
 * @example
 * ```typescript
 * type BgColorDef = PropertyDefinitions["background-color"];
 * type BgColorIR = ExtractIR<BgColorDef>;
 * // → BackgroundColorIR
 * ```
 */
export type ExtractIR<T> = T extends PropertyDefinition<infer IR> ? IR : never;

/**
 * Map of CSS property names to their IR types.
 *
 * This replaces the old auto-generated types.map.ts.
 * Derived directly from PROPERTY_DEFINITIONS via type inference.
 *
 * @example
 * ```typescript
 * type BgColorIR = PropertyIRMap["background-color"];
 * // → BackgroundColorIR (inferred from definition)
 * ```
 */
export type PropertyIRMap = {
  [K in keyof PropertyDefinitions]: ExtractIR<PropertyDefinitions[K]>;
};

/**
 * Union type of all registered property names.
 */
export type RegisteredProperty = keyof PropertyIRMap;


=== File: packages/b_declarations/src/types.ts ===
// b_path:: packages/b_declarations/src/types.ts

// This module defines the core types for the @b/declarations package.
//
// - PropertyIRMap is now derived from PROPERTY_DEFINITIONS (see types.derived.ts)
// - RegisteredProperty is the union of all known property names
// - PropertyDefinition describes how each property integrates into the registry
// - Parser / generator function signatures used by property implementations

import type { ParseResult, GenerateResult } from "@b/types";
import type { PropertyIRMap } from "./types.derived";

export type { PropertyIRMap, RegisteredProperty } from "./types.derived";

/**
 * Basic CSS declaration input structure.
 * Example: { property: "background-image", value: "linear-gradient(...)", important: true }
 */
export interface CSSDeclaration {
  property: string;
  value: string;
  important?: boolean;
}

/**
 * Result of parsing a CSS declaration into its IR representation.
 *
 * Note:
 * - `ir` is the property-specific intermediate representation.
 * - `important` is preserved when originating from declarations that include it.
 */
export interface DeclarationResult<T = unknown> {
  property: string;
  ir: T;
  important?: boolean;
}

/**
 * Property generator function type.
 *
 * Given property-specific IR, returns a GenerateResult for the CSS value
 * (NOT including the "property:" prefix).
 */
export type PropertyGenerator<T = unknown> = (ir: T) => GenerateResult;

/**
 * Parser for single-value properties.
 * Receives a css-tree Value AST node.
 * Examples: color, opacity, width.
 */
export type SingleValueParser<T> = (node: import("@eslint/css-tree").Value) => ParseResult<T>;

/**
 * Parser for multi-value (comma-separated) properties.
 * Receives the raw value string.
 * Examples: background-image, font-family.
 */
export type MultiValueParser<T> = (value: string) => ParseResult<T>;

/**
 * Parser for "raw" value properties.
 * Receives the raw value string without AST parsing.
 * Examples: custom properties, or intentionally opaque properties.
 */
export type RawValueParser<T> = (value: string) => ParseResult<T>;

/**
 * Property definition fragments for different parsing modes.
 */

type SingleValueDefinition<T> = {
  multiValue?: false;
  rawValue?: false;
  parser: SingleValueParser<T>;
};

type MultiValueDefinition<T> = {
  multiValue: true;
  rawValue?: false;
  parser: MultiValueParser<T>;
};

type RawValueDefinition<T> = {
  multiValue?: false;
  rawValue: true;
  parser: RawValueParser<T>;
};

/**
 * Property definition for the registry.
 *
 * Each CSS property registers:
 * - its canonical name (CSS syntax),
 * - syntax string (for docs),
 * - parser configuration (single, multi, or raw),
 * - optional generator for IR → CSS,
 * - inheritance and initial/computed values,
 * - optional validation constraints.
 */
export type PropertyDefinition<T = unknown> = {
  /** CSS property name, e.g. "background-image" or "--*" */
  name: string;
  /** CSS syntax string (for documentation, non-normative) */
  syntax: string;
  /** Whether the property is inherited by default */
  inherited: boolean;
  /** Initial value per spec */
  initial: string;
  /** Optional computed value description */
  computed?: string;
  /** Optional IR → CSS value generator for this property */
  generator?: PropertyGenerator<T>;
  /**
   * Optional validation: allowed keyword values for this property.
   * When provided, the core parser will pre-validate keywords before
   * delegating to the property parser, enabling early error detection.
   *
   * @example
   * allowedKeywords: ['scroll', 'fixed', 'local']
   */
  allowedKeywords?: readonly string[];
} & (SingleValueDefinition<T> | MultiValueDefinition<T> | RawValueDefinition<T>);

// ============================================================================
// CONTRACT ENFORCEMENT (Type-Level)
// ============================================================================

/**
 * Type-level check: multiValue properties must have list-like IR.
 *
 * This enforces the architectural invariant that properties using
 * createMultiValueParser (multiValue: true) must have IR with kind: "list".
 *
 * NOW ENFORCED: Checks actual PropertyDefinitions, not generic types.
 *
 * If this type check fails, it means a property is registered as multiValue
 * but its IR in PropertyIRMap doesn't have a list variant.
 */

import type { PropertyDefinitions } from "./properties/definitions";

// Extract names of all multiValue properties from ACTUAL definitions
type MultiValuePropertyNames = {
  [K in keyof PropertyDefinitions]: PropertyDefinitions[K]["multiValue"] extends true ? K : never;
}[keyof PropertyDefinitions];

// For each multiValue property, verify IR has kind: "list"
type MultiValueIRsHaveListVariant = {
  [K in MultiValuePropertyNames]: PropertyIRMap[K] extends { kind: "list" } ? true : never;
}[MultiValuePropertyNames];

// Compile-time assertion: all multiValue IRs must have list variant
// If any property violates this, TypeScript will error here showing the property name
// @ts-expect-error - Type-level contract check, intentionally unused
type _AssertMultiValueContract = MultiValueIRsHaveListVariant extends true ? true : never;


=== File: packages/b_declarations/src/utils/create-multi-value-parser.ts ===
// b_path:: packages/b_declarations/src/utils/create-multi-value-parser.ts
/**
 * Factory for creating resilient multi-value (comma-separated) property parsers.
 *
 * This solves the "incomplete consumption" bug where css-tree stops parsing early
 * but doesn't error, causing silent failures when commas are missing between values.
 *
 * Key features:
 * - Splits by top-level commas
 * - Parses each chunk individually (resilience)
 * - Validates complete consumption (detects missing commas)
 * - Aggregates results and issues
 *
 * @module
 */

import * as csstree from "@eslint/css-tree";
import { createError, parseErr, type ParseResult, type Issue } from "@b/types";
import { Utils } from "@b/parsers";
import { splitByComma } from "./split";
import { isUniversalFunction } from "./type-guards";

/**
 * Configuration for the multi-value parser factory.
 * @template TItem The IR type of a single item in the list (e.g., ImageLayer).
 * @template TFinal The final IR type for the whole property (e.g., BackgroundImageIR).
 */
export interface MultiValueParserConfig<TItem, TFinal> {
  /**
   * Optional: Property name for better error messages.
   * If not provided, defaults to "multi-value".
   *
   * @example "background-image", "background-size"
   */
  propertyName?: string;

  /**
   * A parser for a single item in the list. It receives a validated AST for one chunk.
   */
  itemParser: (node: csstree.Value) => ParseResult<TItem>;

  /**
   * A function that aggregates an array of successfully parsed items into the final IR structure.
   * e.g., (layers) => ({ kind: 'layers', layers })
   */
  aggregator: (items: TItem[]) => TFinal;

  /**
   * Optional: A function to handle property-specific keywords (like 'none') before list splitting.
   *
   * NOTE: CSS-wide keywords (inherit, initial, unset, revert, revert-layer) are handled
   * by the top-level parseDeclaration orchestrator. Do NOT check for them here.
   *
   * If it returns a result, the list parsing is skipped.
   */
  preParse?: (value: string) => ParseResult<TFinal> | null;
}

/**
 * Factory function to create a resilient, multi-value (comma-separated) property parser.
 *
 * This handles the generic boilerplate for:
 * 1. Handling top-level keywords.
 * 2. Splitting the value string by top-level commas.
 * 3. Parsing each chunk into an AST individually.
 * 4. Checking for incomplete consumption (trailing content bugs).
 * 5. Aggregating successful results and all issues.
 *
 * @param config The property-specific parsing and aggregation logic.
 * @returns A complete multi-value parser function.
 *
 * @example
 * ```typescript
 * export const parseBackgroundImage = createMultiValueParser({
 *   preParse: (value) => {
 *     if (value === "none") return parseOk({ kind: "keyword", value: "none" });
 *     return null;
 *   },
 *   itemParser: (ast) => parseImageLayer(ast),
 *   aggregator: (layers) => ({ kind: "list", layers }),
 * });
 * ```
 */
export function createMultiValueParser<TItem, TFinal>(
  config: MultiValueParserConfig<TItem, TFinal>,
): (value: string) => ParseResult<TFinal> {
  // Extract property name for error messages (default to "multi-value" for backward compatibility)
  const propertyName = config.propertyName || "multi-value";

  // This is the returned parser that conforms to the MultiValueParser signature.
  return (value: string): ParseResult<TFinal> => {
    const trimmedValue = value.trim();

    // 1. Handle top-level keywords (optional)
    if (config.preParse) {
      const preParseResult = config.preParse(trimmedValue);
      if (preParseResult !== null) {
        return preParseResult;
      }
    }

    // 2. Split by top-level commas
    const itemStrings = splitByComma(trimmedValue);
    const itemResults: ParseResult<TItem>[] = [];

    // 3. Parse each chunk individually
    for (const itemStr of itemStrings) {
      const trimmedItemStr = itemStr.trim();
      if (!trimmedItemStr) continue;

      let itemAst: csstree.Value;
      try {
        itemAst = csstree.parse(trimmedItemStr, { context: "value", positions: true }) as csstree.Value;

        // ✨ REFINED CRITICAL FIX: Check the container node's location ✨
        // If the parsed AST's end offset doesn't match the string's length,
        // it means css-tree stopped parsing early and there's trailing content.
        // This correctly handles both:
        // - Space-separated values within a layer (e.g., "repeat space") ✅
        // - Missing commas between layers (e.g., "url(...) url(...)") ✅
        if (itemAst.loc && itemAst.loc.end.offset < trimmedItemStr.length) {
          const unparsed = trimmedItemStr.slice(itemAst.loc.end.offset).trim();
          const previewLength = Math.min(unparsed.length, 50);
          const preview = unparsed.slice(0, previewLength) + (unparsed.length > previewLength ? "..." : "");
          const issue = createError(
            "invalid-syntax",
            `Unexpected content after a valid value, likely a missing comma. Unparsed: "${preview}"`,
          );
          itemResults.push(parseErr(propertyName, issue));
          continue;
        }
      } catch (e) {
        const errorMessage = e instanceof Error ? e.message : String(e);

        // Detect common mistakes and provide helpful messages
        let improvedMessage = `Invalid syntax in list item: ${errorMessage}`;

        if (trimmedItemStr.includes("!important")) {
          improvedMessage = `Found '!important' in value. Use parseDeclaration() for declarations with !important, not property parsers directly.`;
        } else if (/\s+!/.test(trimmedItemStr)) {
          improvedMessage = `Invalid syntax: '!' character found. Did you mean to use parseDeclaration() with !important?`;
        } else if (errorMessage.toLowerCase().includes("unexpected")) {
          improvedMessage = `Invalid syntax in list item: ${errorMessage}. Check for typos, missing quotes, or invalid tokens.`;
        }

        const issue = createError("invalid-syntax", improvedMessage);
        itemResults.push(parseErr(propertyName, issue));
        continue;
      }

      // 5. Check for universal CSS functions first (var, calc, min, max, clamp, etc.)
      // These are handled at the declaration layer, not by property-specific parsers.
      // This follows the same pattern as CSS-wide keywords (Session 057).
      const firstNode = itemAst.children.first;
      if (firstNode && isUniversalFunction(firstNode)) {
        const universalResult = Utils.parseNodeToCssValue(firstNode);
        if (universalResult.ok) {
          // Cast is safe: TItem can be CssValue (union type in property schemas)
          itemResults.push(universalResult as ParseResult<TItem>);
          continue;
        }
        // Fall through if universal parsing failed - let property parser handle the error
      }

      // 6. Delegate to the property-specific item parser with the validated AST chunk.
      itemResults.push(config.itemParser(itemAst));
    }

    // 7. Aggregate all successful items and all issues.
    const validItems: TItem[] = [];
    const allIssues: Issue[] = [];

    for (const result of itemResults) {
      allIssues.push(...result.issues);
      if (result.value) {
        validItems.push(result.value);
      }
    }

    // If there were no valid items, it's a total failure.
    if (validItems.length === 0) {
      return {
        ok: false,
        property: propertyName,
        value: undefined,
        issues: allIssues.length > 0 ? allIssues : [createError("invalid-value", "No valid list items found")],
      };
    }

    // Otherwise, we have a partial or full success.
    const finalIR = config.aggregator(validItems);

    // Determine ok status based on whether there were any errors.
    const hasErrors = allIssues.some((issue) => issue.severity === "error");

    if (hasErrors) {
      return {
        ok: false,
        property: propertyName,
        value: finalIR,
        issues: allIssues,
      };
    }

    return {
      ok: true,
      property: propertyName,
      value: finalIR,
      issues: allIssues,
    };
  };
}


=== File: packages/b_declarations/src/utils/generate-value.ts ===
// b_path:: packages/b_declarations/src/utils/generate-value.ts

import { generateOk, type CssValue, type GenerateResult } from "@b/types";
import { cssValueToCss } from "@b/utils";
import { isCssValue } from "./type-guards";

/**
 * Generate CSS from a value that may be concrete or a CssValue.
 *
 * This wrapper bridges the declaration layer (which accepts T | CssValue)
 * and the concrete generator layer (which expects only T).
 *
 * Architecture:
 * - Declaration schemas validate: T | CssValue
 * - Concrete generators expect: T
 * - This function: checks and delegates appropriately
 *
 * @param value - Either a concrete value (T) or a CssValue (var, calc, etc.)
 * @param concreteGenerator - Generator function that handles concrete values
 * @returns GenerateResult with CSS string
 *
 * @example
 * ```typescript
 * // Before:
 * const result = Generators.Background.generateSize(ir.values[i]);
 * // ❌ Type error: ir.values[i] is BgSize | CssValue
 *
 * // After:
 * const result = generateValue(ir.values[i], Generators.Background.generateSize);
 * // ✅ Type-safe: wrapper handles both cases
 * ```
 */
export function generateValue<T>(
  value: T | CssValue | string,
  concreteGenerator: (value: T) => GenerateResult,
): GenerateResult {
  // Handle CssValue (var, calc, etc.)
  if (isCssValue(value)) {
    return generateOk(cssValueToCss(value));
  }

  // Handle string literals (e.g., "border-box", "padding-box")
  if (typeof value === "string") {
    return generateOk(value);
  }

  // Handle concrete IR types
  return concreteGenerator(value as T);
}


=== File: packages/b_declarations/src/utils/index.ts ===
// b_path:: packages/b_declarations/src/utils/index.ts
export * from "./keywords";
export * from "./split";
export * from "./create-multi-value-parser";
export * from "./generate-value";
export * from "./type-guards";


=== File: packages/b_declarations/src/utils/keywords.ts ===
// b_path:: packages/b_declarations/src/utils/keywords.ts
import { createError, parseErr, parseOk, type ParseResult } from "@b/types";

/**
 * CSS-wide keywords that apply to all properties.
 * https://www.w3.org/TR/css-values-4/#common-keywords
 */
export const CSS_WIDE_KEYWORDS = ["inherit", "initial", "unset", "revert", "revert-layer"] as const;

export type CSSWideKeyword = (typeof CSS_WIDE_KEYWORDS)[number];

/**
 * Check if a value is a CSS-wide keyword.
 */
export function isCSSWideKeyword(value: string): value is CSSWideKeyword {
  return CSS_WIDE_KEYWORDS.includes(value as CSSWideKeyword);
}

/**
 * Parse a CSS-wide keyword.
 */
export function parseCSSWideKeyword(value: string): ParseResult<CSSWideKeyword> {
  const normalized = value.trim().toLowerCase();

  if (isCSSWideKeyword(normalized)) {
    return parseOk(normalized);
  }

  return parseErr("keyword", createError("invalid-value", `Not a CSS-wide keyword: ${value}`));
}


=== File: packages/b_declarations/src/utils/split.ts ===
// b_path:: packages/b_declarations/src/utils/split.ts
/**
 * Split a CSS value by comma, respecting nested functions.
 *
 * @example
 * splitByComma("url(a.png), linear-gradient(red, blue)")
 * // ["url(a.png)", "linear-gradient(red, blue)"]
 */
export function splitByComma(value: string): string[] {
  const result: string[] = [];
  let current = "";
  let depth = 0;

  for (let i = 0; i < value.length; i++) {
    const char = value[i];

    if (char === "(") {
      depth++;
      current += char;
    } else if (char === ")") {
      depth--;
      current += char;
    } else if (char === "," && depth === 0) {
      result.push(current.trim());
      current = "";
    } else {
      current += char;
    }
  }

  if (current.trim()) {
    result.push(current.trim());
  }

  return result;
}


=== File: packages/b_declarations/src/utils/type-guards.ts ===
// b_path:: packages/b_declarations/src/utils/type-guards.ts

import type { CssValue } from "@b/types";
import type * as csstree from "@eslint/css-tree";

/**
 * Exhaustive list of CssValue kinds.
 * Used to distinguish CssValue from property-specific IR structures.
 *
 * CRITICAL: Both CssValue and property IR may have a "kind" field.
 * This whitelist prevents false positives when checking generators.
 */
const CSS_VALUE_KINDS: ReadonlyArray<CssValue["kind"]> = [
  "literal",
  "keyword",
  "variable",
  "list",
  "calc",
  "calc-operation",
  "min",
  "max",
  "clamp",
  "url",
  "attr",
  "function",
  "string",
  "hex-color",
] as const;

/**
 * Type guard to check if a value is a CssValue (not a property-specific IR).
 *
 * This is critical for generators to distinguish between:
 * - CssValue: { kind: "calc", value: ... }
 * - Property IR: { kind: "explicit", horizontal: ..., vertical: ... }
 *
 * Both may have a "kind" field, so we use a whitelist of CssValue kinds.
 *
 * @param value - Value to check
 * @returns true if value is a CssValue
 *
 * @example
 * ```typescript
 * if (isCssValue(value)) {
 *   // It's var(), calc(), etc.
 *   return cssValueToCss(value);
 * } else {
 *   // It's property-specific IR
 *   return generateConcrete(value);
 * }
 * ```
 */
export function isCssValue(value: unknown): value is CssValue {
  if (typeof value !== "object" || value === null) return false;
  if (!("kind" in value)) return false;

  const kind = (value as { kind: string }).kind;
  return CSS_VALUE_KINDS.includes(kind as CssValue["kind"]);
}

/**
 * Universal CSS functions that apply to all properties.
 * These are handled by the declaration layer, not property parsers.
 */
const UNIVERSAL_FUNCTIONS = [
  "var", // CSS Variables
  "calc", // Math
  "min", // Math
  "max", // Math
  "clamp", // Math
  "attr", // Attribute references
  "env", // Environment variables
] as const;

/**
 * Check if a CSS AST node is a universal function.
 *
 * Universal functions (var, calc, etc.) apply to ALL properties and
 * should be handled by wrappers, not individual property parsers.
 *
 * @param node - CSS AST node
 * @returns true if the node is a universal function (var, calc, etc.)
 *
 * @example
 * ```typescript
 * if (isUniversalFunction(node)) {
 *   return parseNodeToCssValue(node);
 * }
 * // Not universal - delegate to property parser
 * ```
 */
export function isUniversalFunction(node: csstree.CssNode): boolean {
  if (node.type !== "Function") return false;
  const funcName = (node as csstree.FunctionNode).name.toLowerCase();
  return (UNIVERSAL_FUNCTIONS as ReadonlyArray<string>).includes(funcName);
}

/**
 * Check if a value is a concrete property value (not a CssValue).
 * Useful for downstream consumers who need to narrow types.
 *
 * @param value - Value to check
 * @returns true if value is concrete (not CssValue)
 *
 * @example
 * ```typescript
 * if (isConcreteValue(value)) {
 *   // TypeScript knows value is T, not CssValue
 *   console.log(value.specificField);
 * }
 * ```
 */
export function isConcreteValue<T>(value: T | CssValue): value is T {
  return !isCssValue(value);
}


=== File: packages/b_declarations/tsup.config.ts ===
// b_path:: packages/b_declarations/tsup.config.ts
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/index.ts"],
  format: ["cjs", "esm"],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
  treeshake: true,
});


=== File: packages/b_declarations/vite.config.ts ===
// b_path:: packages/b_declarations/vite.config.ts
import { defineConfig } from "vite";

import tsconfigPaths from "vite-tsconfig-paths";

// https://vite.dev/config/
export default defineConfig({
  plugins: [tsconfigPaths()],
});


=== File: packages/b_generators/src/angle.ts ===
// b_path:: packages/b_generators/src/angle.ts
import { generateOk, type GenerateResult } from "@b/types";
import type * as Type from "@b/types";

/**
 * Generate CSS angle string from Angle IR
 * @see https://drafts.csswg.org/css-values-4/#angles
 */
export function generate(angle: Type.Angle): GenerateResult {
  return generateOk(`${angle.value}${angle.unit}`);
}


=== File: packages/b_generators/src/background/attachment.ts ===
// b_path:: packages/b_generators/src/background/attachment.ts

import { generateOk, type GenerateResult } from "@b/types";
import type { BackgroundAttachment } from "@b/keywords";

/**
 * Generate CSS string for a single background-attachment value.
 *
 * Syntax: scroll | fixed | local
 *
 * @param value - The attachment value
 * @returns GenerateResult with CSS string
 */
export function generate(value: BackgroundAttachment): GenerateResult {
  return generateOk(value);
}


=== File: packages/b_generators/src/background/clip.ts ===
// b_path:: packages/b_generators/src/background/clip.ts

import { generateOk, type GenerateResult, type CssValue } from "@b/types";
import { cssValueToCss } from "@b/utils";

/**
 * Generate CSS string for a single background-clip value.
 *
 * Syntax: border-box | padding-box | content-box | text | var() | calc()
 *
 * @param value - The CssValue (keyword, var(), calc(), etc.)
 * @returns GenerateResult with CSS string
 */
export function generate(value: CssValue): GenerateResult {
  return generateOk(cssValueToCss(value));
}


=== File: packages/b_generators/src/background/index.ts ===
// b_path:: packages/b_generators/src/background/index.ts

export * as Attachment from "./attachment";
export * as Clip from "./clip";
export * as Origin from "./origin";
export * as Repeat from "./repeat";
export * as Size from "./size";


=== File: packages/b_generators/src/background/origin.ts ===
// b_path:: packages/b_generators/src/background/origin.ts

import { generateOk, type GenerateResult } from "@b/types";
import type { BackgroundOrigin } from "@b/keywords";

/**
 * Generate CSS string for a single background-origin value.
 *
 * Syntax: border-box | padding-box | content-box
 *
 * @param value - The box value
 * @returns GenerateResult with CSS string
 */
export function generate(value: BackgroundOrigin): GenerateResult {
  return generateOk(value);
}


=== File: packages/b_generators/src/background/repeat.ts ===
// b_path:: packages/b_generators/src/background/repeat.ts

import { generateOk, type GenerateResult, type CssValue } from "@b/types";
import { cssValueToCss } from "@b/utils";

type RepetitionValue = "repeat" | "space" | "round" | "no-repeat";

type RepeatStyle =
  | { kind: "shorthand"; value: "repeat-x" | "repeat-y" }
  | { kind: "explicit"; horizontal: RepetitionValue; vertical: RepetitionValue };

/**
 * Generate CSS string for a single background-repeat value.
 *
 * Syntax: repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2} | var() | calc()
 *
 * @param style - The repeat style or CssValue
 * @returns GenerateResult with CSS string
 */
export function generate(style: RepeatStyle | CssValue): GenerateResult {
  // Handle CssValue types (var(), calc(), etc.)
  if ("kind" in style) {
    if (style.kind === "shorthand") {
      return generateOk(style.value);
    }
    if (style.kind === "explicit") {
      if (style.horizontal === style.vertical) {
        return generateOk(style.horizontal);
      }
      return generateOk(`${style.horizontal} ${style.vertical}`);
    }
    // Any other kind is a CssValue
    return generateOk(cssValueToCss(style));
  }

  // Fallback (shouldn't reach here with proper types)
  return generateOk(cssValueToCss(style as CssValue));
}


=== File: packages/b_generators/src/background/size.ts ===
// b_path:: packages/b_generators/src/background/size.ts

import { generateOk, type GenerateResult, type BgSize } from "@b/types";
import { cssValueToCss } from "@b/utils";

/**
 * Generate CSS string for a single <bg-size> value.
 *
 * Syntax: [ <length-percentage [0,∞]> | auto ]{1,2} | cover | contain
 *
 * @param size - The BgSize IR
 * @returns GenerateResult with CSS string
 */
export function generate(size: BgSize): GenerateResult {
  if (size.kind === "keyword") {
    return generateOk(size.value);
  }

  // Explicit size
  const widthCss = cssValueToCss(size.width);
  const heightCss = cssValueToCss(size.height);

  // If height is 'auto' and width is not, we can use the one-value syntax.
  if (heightCss === "auto" && widthCss !== "auto") {
    return generateOk(widthCss);
  }

  // If both values happen to be the same (e.g. 'auto auto' or 'cover cover')
  if (widthCss === heightCss) {
    return generateOk(widthCss);
  }

  // Different values - output both
  return generateOk(`${widthCss} ${heightCss}`);
}


=== File: packages/b_generators/src/blend-mode.ts ===
// b_path:: packages/b_generators/src/blend-mode.ts

import { generateOk, type GenerateResult } from "@b/types";
import type { BlendMode } from "@b/keywords";

/**
 * Generate CSS <blend-mode> value
 */
export function generate(value: BlendMode): GenerateResult {
  return generateOk(value);
}


=== File: packages/b_generators/src/color/color-function.ts ===
// b_path:: packages/b_generators/src/color/color-function.ts
import { type GenerateResult, generateErr, generateOk, createError } from "@b/types";
import type { ColorFunction } from "@b/types";
import { cssValueToCss } from "@b/utils";

/**
 * @see https://drafts.csswg.org/css-color/#color-function
 */
export function generate(value: ColorFunction): GenerateResult {
  if (value === undefined || value === null) {
    return generateErr(createError("invalid-ir", "ColorFunction must not be null or undefined"));
  }
  if (typeof value !== "object") {
    return generateErr(createError("invalid-ir", `Expected ColorFunction object, got ${typeof value}`));
  }
  if (!("colorSpace" in value) || !("channels" in value)) {
    return generateErr(
      createError("missing-required-field", "ColorFunction must have 'colorSpace' and 'channels' fields"),
    );
  }

  const parts: string[] = ["color(", value.colorSpace];

  for (const channel of value.channels) {
    parts.push(" ");
    parts.push(cssValueToCss(channel));
  }

  if (value.alpha !== undefined) {
    parts.push(" / ");
    parts.push(cssValueToCss(value.alpha));
  }

  parts.push(")");
  return generateOk(parts.join(""));
}


=== File: packages/b_generators/src/color/color.ts ===
// b_path:: packages/b_generators/src/color/color.ts
import { type GenerateResult, type GenerateContext, generateErr, generateOk, createError } from "@b/types";
import type * as Type from "@b/types";
import { cssValueToCss } from "@b/utils";
import * as ColorFunction from "./color-function";
import * as Hex from "./hex";
import * as Hsl from "./hsl";
import * as Hwb from "./hwb";
import * as Lab from "./lab";
import * as Lch from "./lch";
import * as Named from "./named";
import * as Oklab from "./oklab";
import * as Oklch from "./oklch";
import * as Rgb from "./rgb";
import * as Special from "./special";

/**
 * @see https://drafts.csswg.org/css-color/#typedef-color
 */
export function generate(color: Type.Color, context?: GenerateContext): GenerateResult {
  // Minimal runtime check for null/undefined to prevent crashes
  // TypeScript ensures correct types, but runtime errors need handling
  if (!color) {
    return generateErr(createError("unsupported-kind", "Invalid color IR: null or undefined"));
  }

  switch (color.kind) {
    case "hex":
      return Hex.generate(color);

    case "named":
      return Named.generate(color, context);

    case "rgb":
      return Rgb.generate(color, context);

    case "hsl":
      return Hsl.generate(color);

    case "hwb":
      return Hwb.generate(color);

    case "lab":
      return Lab.generate(color);

    case "lch":
      return Lch.generate(color);

    case "oklab":
      return Oklab.generate(color);

    case "oklch":
      return Oklch.generate(color);

    case "special":
      return Special.generate(color);

    case "color":
      return ColorFunction.generate(color);

    case "variable":
      return generateOk(cssValueToCss(color));

    default: {
      // Exhaustiveness check - TypeScript ensures all cases are handled
      const _exhaustive: never = color;
      return generateErr(
        createError("unsupported-kind", `Unknown color kind: ${(_exhaustive as { kind?: string }).kind}`),
      );
    }
  }
}


=== File: packages/b_generators/src/color/hex.ts ===
// b_path:: packages/b_generators/src/color/hex.ts
import { type GenerateResult, generateErr, generateOk, hexColorSchema } from "@b/types";
import { zodErrorToIssues } from "@b/utils";

/**
 * @see https://drafts.csswg.org/css-color/#hex-notation
 */
export function generate(color: unknown): GenerateResult {
  // Schema validation
  const validation = hexColorSchema.safeParse(color);
  if (!validation.success) {
    return generateErr(zodErrorToIssues(validation.error, { typeName: "HexColor" }));
  }
  return generateOk(validation.data.value);
}


=== File: packages/b_generators/src/color/hsl.ts ===
// b_path:: packages/b_generators/src/color/hsl.ts
import { type GenerateResult, addGenerateIssue, generateErr, generateOk, hslColorSchema } from "@b/types";
import { checkAlpha, checkHue, checkPercentage, collectWarnings, cssValueToCss, zodErrorToIssues } from "@b/utils";

/**
 * @see https://drafts.csswg.org/css-color/#the-hsl-notation
 */
export function generate(color: unknown): GenerateResult {
  // 1. Schema validation (structure errors)
  const validation = hslColorSchema.safeParse(color);
  if (!validation.success) {
    return generateErr(
      zodErrorToIssues(validation.error, {
        typeName: "HSLColor",
        property: "color",
      }),
      "hsl-color",
    );
  }

  const { h, s, l, alpha } = validation.data;

  // 2. Semantic validation (range warnings)
  const warnings = collectWarnings(
    checkHue(h, "h", "HSLColor"),
    checkPercentage(s, "s", "HSLColor"),
    checkPercentage(l, "l", "HSLColor"),
    alpha ? checkAlpha(alpha, "alpha", "HSLColor") : undefined,
  );

  // 3. Generate CSS
  const hslPart = `${cssValueToCss(h)} ${cssValueToCss(s)} ${cssValueToCss(l)}`;

  let result: GenerateResult;
  if (alpha !== undefined) {
    result = generateOk(`hsl(${hslPart} / ${cssValueToCss(alpha)})`);
  } else {
    result = generateOk(`hsl(${hslPart})`);
  }

  // 4. Attach warnings
  for (const warning of warnings) {
    result = addGenerateIssue(result, warning);
  }

  return result;
}


=== File: packages/b_generators/src/color/hwb.ts ===
// b_path:: packages/b_generators/src/color/hwb.ts
import { type GenerateResult, addGenerateIssue, generateErr, generateOk, hwbColorSchema } from "@b/types";
import { checkAlpha, checkHue, checkPercentage, collectWarnings, cssValueToCss, zodErrorToIssues } from "@b/utils";

/**
 * @see https://drafts.csswg.org/css-color/#the-hwb-notation
 */
export function generate(color: unknown): GenerateResult {
  // 1. Schema validation (structure errors)
  const validation = hwbColorSchema.safeParse(color);
  if (!validation.success) {
    return generateErr(
      zodErrorToIssues(validation.error, {
        typeName: "HWBColor",
        property: "color",
      }),
      "hwb-color",
    );
  }

  const { h, w, b, alpha } = validation.data;

  // 2. Semantic validation (range warnings)
  const warnings = collectWarnings(
    checkHue(h, "h", "HWBColor"),
    checkPercentage(w, "w", "HWBColor"),
    checkPercentage(b, "b", "HWBColor"),
    alpha ? checkAlpha(alpha, "alpha", "HWBColor") : undefined,
  );

  // 3. Generate CSS
  let css = `hwb(${cssValueToCss(h)} ${cssValueToCss(w)} ${cssValueToCss(b)}`;

  if (alpha !== undefined) {
    css += ` / ${cssValueToCss(alpha)}`;
  }

  css += ")";
  let result = generateOk(css);

  // 4. Attach warnings
  for (const warning of warnings) {
    result = addGenerateIssue(result, warning);
  }

  return result;
}


=== File: packages/b_generators/src/color/index.ts ===
// b_path:: packages/b_generators/src/color/index.ts
export * as ColorFunction from "./color-function";
export * as Hex from "./hex";
export * as Hsl from "./hsl";
export * as Hwb from "./hwb";
export * as Lab from "./lab";
export * as Lch from "./lch";
export * as Named from "./named";
export * as Oklab from "./oklab";
export * as Oklch from "./oklch";
export * as Rgb from "./rgb";
export * as Special from "./special";
export * from "./color";


=== File: packages/b_generators/src/color/lab.ts ===
// b_path:: packages/b_generators/src/color/lab.ts
import { type GenerateResult, addGenerateIssue, generateErr, generateOk, labColorSchema } from "@b/types";
import { checkAlpha, checkLiteralRange, collectWarnings, cssValueToCss, zodErrorToIssues } from "@b/utils";

/**
 * @see https://drafts.csswg.org/css-color/#lab-colors
 */
export function generate(color: unknown): GenerateResult {
  // 1. Schema validation (structure errors)
  const validation = labColorSchema.safeParse(color);
  if (!validation.success) {
    return generateErr(
      zodErrorToIssues(validation.error, {
        typeName: "LABColor",
        property: "color",
      }),
      "lab-color",
    );
  }

  const { l, a, b, alpha } = validation.data;

  // 2. Semantic validation (range warnings)
  const warnings = collectWarnings(
    checkLiteralRange(l, 0, 100, { field: "l", typeName: "LABColor" }),
    checkLiteralRange(a, -125, 125, { field: "a", typeName: "LABColor" }),
    checkLiteralRange(b, -125, 125, { field: "b", typeName: "LABColor" }),
    alpha ? checkAlpha(alpha, "alpha", "LABColor") : undefined,
  );

  // 3. Generate CSS
  const labPart = `${cssValueToCss(l)} ${cssValueToCss(a)} ${cssValueToCss(b)}`;

  let result: GenerateResult;
  if (alpha !== undefined) {
    result = generateOk(`lab(${labPart} / ${cssValueToCss(alpha)})`);
  } else {
    result = generateOk(`lab(${labPart})`);
  }

  // 4. Attach warnings
  for (const warning of warnings) {
    result = addGenerateIssue(result, warning);
  }

  return result;
}


=== File: packages/b_generators/src/color/lch.ts ===
// b_path:: packages/b_generators/src/color/lch.ts
import { type GenerateResult, addGenerateIssue, generateErr, generateOk, lchColorSchema } from "@b/types";
import { checkAlpha, checkHue, checkLiteralRange, collectWarnings, cssValueToCss, zodErrorToIssues } from "@b/utils";

/**
 * Generates LCH color CSS from IR
 * Supports literals, variables (var()), and keywords (none)
 * @see https://drafts.csswg.org/css-color/#lch-colors
 */
export function generate(color: unknown): GenerateResult {
  // 1. Schema validation (structure errors)
  const validation = lchColorSchema.safeParse(color);
  if (!validation.success) {
    return generateErr(
      zodErrorToIssues(validation.error, {
        typeName: "LCHColor",
        property: "color",
      }),
      "lch-color",
    );
  }

  const { l, c, h, alpha } = validation.data;

  // 2. Semantic validation (range warnings)
  const warnings = collectWarnings(
    checkLiteralRange(l, 0, 100, { field: "l", typeName: "LCHColor" }),
    checkLiteralRange(c, 0, 150, { field: "c", typeName: "LCHColor" }),
    checkHue(h, "h", "LCHColor"),
    alpha ? checkAlpha(alpha, "alpha", "LCHColor") : undefined,
  );

  // 3. Generate CSS
  const lchPart = `${cssValueToCss(l)} ${cssValueToCss(c)} ${cssValueToCss(h)}`;

  let result: GenerateResult;
  if (alpha !== undefined) {
    result = generateOk(`lch(${lchPart} / ${cssValueToCss(alpha)})`);
  } else {
    result = generateOk(`lch(${lchPart})`);
  }

  // 4. Attach warnings
  for (const warning of warnings) {
    result = addGenerateIssue(result, warning);
  }

  return result;
}


=== File: packages/b_generators/src/color/named.ts ===
// b_path:: packages/b_generators/src/color/named.ts
import { namedColorsValues } from "@b/keywords";
import { type GenerateResult, type GenerateContext, generateOk, generateErr, addGenerateIssue } from "@b/types";
import { findClosestMatch, zodErrorToIssues } from "@b/utils";
import { z } from "zod";

// Relaxed schema for generation - accepts any string for name
const namedColorGeneratorSchema = z
  .object({
    kind: z.literal("named"),
    name: z.string(), // Accept any string, we'll validate semantically
  })
  .strict();

/**
 * Generate CSS named color string from NamedColor IR.
 *
 * Follows the 4-step generator pattern:
 * 1. Structural validation (Zod schema)
 * 2. Generate CSS string (always succeeds for valid structure)
 * 3. Semantic validation (check if color name is recognized)
 * 4. Attach warnings if needed
 *
 * @see https://drafts.csswg.org/css-color/#named-colors
 */
export function generate(color: unknown, context?: GenerateContext): GenerateResult {
  // Step 1: Structural Validation
  // Validate that the input has the correct shape (object with kind and name)
  const validation = namedColorGeneratorSchema.safeParse(color);

  if (!validation.success) {
    return generateErr(
      zodErrorToIssues(validation.error, {
        typeName: "NamedColor",
        property: context?.property ?? "color",
        parentPath: context?.parentPath,
      }),
      "named-color",
    );
  }

  const { name: colorName } = validation.data;

  // Step 2: Generate CSS
  // We can always represent a named color as CSS, even if unrecognized
  // Philosophy: ok = canRepresent(input), not isValidCSS(input)
  let result = generateOk(colorName);

  // Step 3: Semantic Validation
  // Check if it's a recognized CSS named color
  const isKnownColor = namedColorsValues.includes(colorName);

  // Step 4: Attach Warnings
  if (!isKnownColor) {
    const closestMatch = findClosestMatch(colorName, namedColorsValues);

    result = addGenerateIssue(result, {
      code: "invalid-value",
      severity: "warning",
      message: `Unknown named color '${colorName}'`,
      property: context?.property ?? "color",
      suggestion: closestMatch ? `Did you mean '${closestMatch}'?` : "Use a valid CSS named color",
      expected: "Valid named color (e.g., red, blue, green, etc.)",
      received: colorName,
      path: [...(context?.parentPath ?? []), "name"],
    });
  }

  return result;
}


=== File: packages/b_generators/src/color/oklab.ts ===
// b_path:: packages/b_generators/src/color/oklab.ts
import { type GenerateResult, addGenerateIssue, generateErr, generateOk, oklabColorSchema } from "@b/types";
import { checkAlpha, checkLiteralRange, collectWarnings, cssValueToCss, zodErrorToIssues } from "@b/utils";

/**
 * @see https://drafts.csswg.org/css-color/#ok-lab
 */
export function generate(color: unknown): GenerateResult {
  // 1. Schema validation (structure errors)
  const validation = oklabColorSchema.safeParse(color);
  if (!validation.success) {
    return generateErr(
      zodErrorToIssues(validation.error, {
        typeName: "OKLABColor",
        property: "color",
      }),
      "oklab-color",
    );
  }

  const { l, a, b, alpha } = validation.data;

  // 2. Semantic validation (range warnings)
  const warnings = collectWarnings(
    checkLiteralRange(l, 0, 1, { field: "l", typeName: "OKLABColor" }),
    checkLiteralRange(a, -0.4, 0.4, { field: "a", typeName: "OKLABColor" }),
    checkLiteralRange(b, -0.4, 0.4, { field: "b", typeName: "OKLABColor" }),
    alpha ? checkAlpha(alpha, "alpha", "OKLABColor") : undefined,
  );

  // 3. Generate CSS
  const oklabPart = `${cssValueToCss(l)} ${cssValueToCss(a)} ${cssValueToCss(b)}`;

  let result: GenerateResult;
  if (alpha !== undefined) {
    result = generateOk(`oklab(${oklabPart} / ${cssValueToCss(alpha)})`);
  } else {
    result = generateOk(`oklab(${oklabPart})`);
  }

  // 4. Attach warnings
  for (const warning of warnings) {
    result = addGenerateIssue(result, warning);
  }

  return result;
}


=== File: packages/b_generators/src/color/oklch.ts ===
// b_path:: packages/b_generators/src/color/oklch.ts

import { type GenerateResult, addGenerateIssue, generateErr, generateOk, oklchColorSchema } from "@b/types";
import { checkAlpha, checkHue, checkLiteralRange, collectWarnings, cssValueToCss, zodErrorToIssues } from "@b/utils";

/**
 * Semantic check for OKLCH lightness.
 *
 * Rules:
 * - If percentage: soft-bound to 0-100%.
 * - If number: soft-bound to 0-1.
 * - Otherwise (var/calc/etc): no warning.
 */
function checkOKLCHLightness(l: import("@b/types").CssValue): import("@b/types").Issue | undefined {
  if (l.kind !== "literal") return undefined;

  if (l.unit === "%") {
    // 0% – 100%
    return checkLiteralRange(l, 0, 100, { field: "l", unit: "%", typeName: "OKLCHColor" });
  }

  // Unitless or other units: treat as 0–1 soft range
  return checkLiteralRange(l, 0, 1, { field: "l", typeName: "OKLCHColor" });
}

/**
 * @see https://drafts.csswg.org/css-color/#ok-lch
 */
export function generate(color: unknown): GenerateResult {
  // 1. Schema validation (structure errors)
  const validation = oklchColorSchema.safeParse(color);
  if (!validation.success) {
    return generateErr(
      zodErrorToIssues(validation.error, {
        typeName: "OKLCHColor",
        property: "color",
      }),
      "oklch-color",
    );
  }

  const { l, c, h, alpha } = validation.data;

  // 2. Semantic validation (range warnings)
  const warnings = collectWarnings(
    // Lightness: 0-1 or 0-100% depending on unit.
    checkOKLCHLightness(l),
    // Chroma: soft-bounded guideline range (tunable).
    checkLiteralRange(c, 0, 0.4, { field: "c", typeName: "OKLCHColor" }),
    // Hue: unit and magnitude sanity.
    checkHue(h, "h", "OKLCHColor"),
    // Alpha: standard alpha semantics.
    alpha ? checkAlpha(alpha, "alpha", "OKLCHColor") : undefined,
  );

  // 3. Generate CSS
  const oklchPart = `${cssValueToCss(l)} ${cssValueToCss(c)} ${cssValueToCss(h)}`;

  let result: GenerateResult;
  if (alpha !== undefined) {
    result = generateOk(`oklch(${oklchPart} / ${cssValueToCss(alpha)})`);
  } else {
    result = generateOk(`oklch(${oklchPart})`);
  }

  // 4. Attach warnings
  for (const warning of warnings) {
    result = addGenerateIssue(result, warning);
  }

  return result;
}


=== File: packages/b_generators/src/color/rgb.ts ===
// b_path:: packages/b_generators/src/color/rgb.ts
import {
  type GenerateResult,
  type GenerateContext,
  addGenerateIssue,
  generateErr,
  generateOk,
  rgbColorSchema,
} from "@b/types";
import { checkAlpha, checkRGBComponent, collectWarnings, cssValueToCss, zodErrorToIssues } from "@b/utils";

/**
 * @see https://drafts.csswg.org/css-color/#rgb-functions
 */
export function generate(color: unknown, context?: GenerateContext): GenerateResult {
  // 1. Schema validation (structure errors)
  const validation = rgbColorSchema.safeParse(color);
  if (!validation.success) {
    return generateErr(
      zodErrorToIssues(validation.error, {
        typeName: "RGBColor",
        property: context?.property ?? "color",
        parentPath: context?.parentPath,
      }),
      "rgb-color",
    );
  }

  const { r, g, b, alpha } = validation.data;

  // 2. Semantic validation (range warnings) with path context
  const warnings = collectWarnings(
    checkRGBComponent(r, "r", "RGBColor", context?.parentPath),
    checkRGBComponent(g, "g", "RGBColor", context?.parentPath),
    checkRGBComponent(b, "b", "RGBColor", context?.parentPath),
    alpha ? checkAlpha(alpha, "alpha", "RGBColor", context?.parentPath) : undefined,
  );

  // 3. Generate CSS
  const rgbPart = `${cssValueToCss(r)} ${cssValueToCss(g)} ${cssValueToCss(b)}`;

  let result: GenerateResult;
  if (alpha !== undefined) {
    result = generateOk(`rgb(${rgbPart} / ${cssValueToCss(alpha)})`);
  } else {
    result = generateOk(`rgb(${rgbPart})`);
  }

  // 4. Attach warnings
  for (const warning of warnings) {
    result = addGenerateIssue(result, warning);
  }

  return result;
}


=== File: packages/b_generators/src/color/special.ts ===
// b_path:: packages/b_generators/src/color/special.ts
import { type GenerateResult, generateErr, generateOk, specialColorSchema } from "@b/types";
import { zodErrorToIssues } from "@b/utils";

/**
 * @see https://drafts.csswg.org/css-color/#typedef-color
 */
export function generate(color: unknown): GenerateResult {
  // Schema validation
  const validation = specialColorSchema.safeParse(color);
  if (!validation.success) {
    return generateErr(zodErrorToIssues(validation.error, { typeName: "SpecialColor" }));
  }
  return generateOk(validation.data.keyword);
}


=== File: packages/b_generators/src/gradient/color-stop.ts ===
// b_path:: packages/b_generators/src/gradient/color-stop.ts
import { generateOk, type GenerateResult, type GenerateContext } from "@b/types";
import type * as Type from "@b/types";
import * as Color from "../color";
import { cssValueToCss } from "@b/utils";

/**
 * Generate CSS color stop or hint string from ColorStopOrHint IR.
 *
 * A color stop consists of a color and an optional position.
 * A color hint is just a position (transition midpoint).
 * Position can be a length, percentage, or angle (for conic gradients).
 *
 * @param stopOrHint - ColorStopOrHint IR object
 * @returns CSS color stop or hint string
 *
 * @example
 * Color stops:
 * ```typescript
 * generate({ color: { kind: "named", name: "red" } })
 * // => "red"
 *
 * generate({
 *   color: { kind: "named", name: "blue" },
 *   position: { kind: "literal", value: 50, unit: "%" }
 * })
 * // => "blue 50%"
 * ```
 *
 * @example
 * Color hint:
 * ```typescript
 * generate({
 *   kind: "hint",
 *   position: { kind: "literal", value: 30, unit: "%" }
 * })
 * // => "30%"
 * ```
 */
export function generate(stopOrHint: Type.ColorStopOrHint, context?: GenerateContext): GenerateResult {
  // Handle color hint
  if ("kind" in stopOrHint && stopOrHint.kind === "hint") {
    return generateOk(cssValueToCss(stopOrHint.position));
  }

  // Handle color stop
  const colorStop = stopOrHint as Type.ColorStop;
  const colorResult = Color.generate(colorStop.color, {
    parentPath: [...(context?.parentPath ?? []), "color"],
    property: context?.property,
  });
  if (!colorResult.ok) {
    return colorResult;
  }

  let css = colorResult.value;
  const issues = [...colorResult.issues];

  if (colorStop.position) {
    const pos = colorStop.position;

    if (Array.isArray(pos)) {
      const [pos1, pos2] = pos;
      css += ` ${cssValueToCss(pos1)} ${cssValueToCss(pos2)}`;
    } else {
      css += ` ${cssValueToCss(pos)}`;
    }
  }

  return {
    ok: true,
    value: css,
    issues,
  };
}


=== File: packages/b_generators/src/gradient/conic.ts ===
// b_path:: packages/b_generators/src/gradient/conic.ts
import { generateOk, type GenerateResult, type GenerateContext } from "@b/types";
import type * as Type from "@b/types";
import * as Position from "../position";
import * as ColorStop from "./color-stop";
import { cssValueToCss } from "@b/utils";

/**
 * Generate CSS color interpolation method string.
 */
function generateColorInterpolation(method: Type.ColorInterpolationMethod): GenerateResult {
  let css = `in ${method.colorSpace}`;

  if ("hueInterpolationMethod" in method && method.hueInterpolationMethod) {
    css += ` ${method.hueInterpolationMethod}`;
  }

  return generateOk(css);
}

/**
 * Generate a CSS conic gradient string from intermediate representation (IR).
 *
 * Converts a ConicGradient IR object into a valid CSS `conic-gradient()` or
 * `repeating-conic-gradient()` function string.
 *
 * @param ir - ConicGradient IR object to convert to CSS
 * @returns CSS conic gradient function string
 *
 * @example
 * Simple gradient:
 * ```typescript
 * generate({
 *   kind: "conic",
 *   colorStops: [
 *     { color: { kind: "named", value: "red" } },
 *     { color: { kind: "named", value: "blue" } }
 *   ],
 *   repeating: false
 * })
 * // => "conic-gradient(red, blue)"
 * ```
 *
 * @example
 * With from angle:
 * ```typescript
 * generate({
 *   kind: "conic",
 *   fromAngle: { kind: "literal", value: 45, unit: "deg" },
 *   colorStops: [
 *     { color: { kind: "named", value: "red" } },
 *     { color: { kind: "named", value: "blue" } }
 *   ],
 *   repeating: false
 * })
 * // => "conic-gradient(from 45deg, red, blue)"
 * ```
 *
 * @example
 * With position:
 * ```typescript
 * generate({
 *   kind: "conic",
 *   position: {
 *     horizontal: { kind: "keyword", value: "center" },
 *     vertical: { kind: "keyword", value: "center" }
 *   },
 *   colorStops: [
 *     { color: { kind: "named", value: "red" } },
 *     { color: { kind: "named", value: "blue" } }
 *   ],
 *   repeating: false
 * })
 * // => "conic-gradient(at center center, red, blue)"
 * ```
 */
export function generate(ir: Type.ConicGradient, context?: GenerateContext): GenerateResult {
  const functionName = ir.repeating ? "repeating-conic-gradient" : "conic-gradient";
  const parts: string[] = [];
  const firstPart: string[] = [];
  const allIssues: Type.Issue[] = [];

  if (ir.fromAngle) {
    firstPart.push(`from ${cssValueToCss(ir.fromAngle)}`);
  }

  if (ir.position) {
    const posResult = Position.generate(ir.position);
    if (!posResult.ok) return posResult;
    firstPart.push(`at ${posResult.value}`);
    allIssues.push(...posResult.issues);
  }

  if (firstPart.length > 0) {
    parts.push(firstPart.join(" "));
  }

  if (ir.colorInterpolationMethod) {
    const interpResult = generateColorInterpolation(ir.colorInterpolationMethod);
    if (!interpResult.ok) return interpResult;
    parts.push(interpResult.value);
    allIssues.push(...interpResult.issues);
  }

  for (let i = 0; i < ir.colorStops.length; i++) {
    const stop = ir.colorStops[i];
    const stopResult = ColorStop.generate(stop, {
      parentPath: [...(context?.parentPath ?? []), "colorStops", i],
      property: context?.property,
    });
    if (!stopResult.ok) return stopResult;
    parts.push(stopResult.value);
    allIssues.push(...stopResult.issues);
  }

  return {
    ok: true,
    value: `${functionName}(${parts.join(", ")})`,
    issues: allIssues,
  };
}


=== File: packages/b_generators/src/gradient/index.ts ===
// b_path:: packages/b_generators/src/gradient/index.ts
export * as ColorStop from "./color-stop";
export * as Linear from "./linear";
export * as Radial from "./radial";
export * as Conic from "./conic";

import { createError, generateErr, type GenerateResult, type GenerateContext, type Gradient } from "@b/types";
import * as Linear from "./linear";
import * as Radial from "./radial";
import * as Conic from "./conic";

/**
 * Generate CSS string for any gradient type.
 * Routes to the appropriate gradient generator based on kind.
 */
export function generate(gradient: Gradient, context?: GenerateContext): GenerateResult {
  switch (gradient.kind) {
    case "linear":
      return Linear.generate(gradient, context);
    case "radial":
      return Radial.generate(gradient, context);
    case "conic":
      return Conic.generate(gradient, context);
    default: {
      // Exhaustiveness check - TypeScript ensures all gradient types are handled
      const _exhaustive: never = gradient;
      return generateErr(
        createError("unsupported-kind", `Unsupported gradient kind: ${(_exhaustive as { kind: string }).kind}`),
      );
    }
  }
}


=== File: packages/b_generators/src/gradient/linear.ts ===
// b_path:: packages/b_generators/src/gradient/linear.ts
import { generateOk, type GenerateResult, type GenerateContext } from "@b/types";
import type * as Type from "@b/types";
import * as ColorStop from "./color-stop";
import { cssValueToCss } from "@b/utils";

/**
 * Generate CSS direction string from GradientDirection IR.
 *
 * @param direction - GradientDirection IR object
 * @returns CSS direction string (e.g., "45deg", "to right", "to top left")
 */
function generateDirection(direction: Type.GradientDirection): GenerateResult {
  if (direction.kind === "angle") {
    return generateOk(cssValueToCss(direction.value));
  }

  if (direction.kind === "to-side") {
    return generateOk(`to ${direction.value}`);
  }

  return generateOk(`to ${direction.value}`);
}

/**
 * Generate CSS color interpolation method string.
 *
 * @param method - ColorInterpolationMethod IR object
 * @returns CSS interpolation string (e.g., "in oklch", "in hsl shorter hue")
 */
function generateColorInterpolation(method: Type.ColorInterpolationMethod): GenerateResult {
  let css = `in ${method.colorSpace}`;

  if ("hueInterpolationMethod" in method && method.hueInterpolationMethod) {
    css += ` ${method.hueInterpolationMethod}`;
  }

  return generateOk(css);
}

/**
 * Generate a CSS linear gradient string from intermediate representation (IR).
 *
 * Converts a LinearGradient IR object into a valid CSS `linear-gradient()` or
 * `repeating-linear-gradient()` function string.
 *
 * @param ir - LinearGradient IR object to convert to CSS
 * @returns CSS linear gradient function string
 *
 * @example
 * Simple gradient:
 * ```typescript
 * generate({
 *   kind: "linear",
 *   colorStops: [
 *     { color: { kind: "named", value: "red" } },
 *     { color: { kind: "named", value: "blue" } }
 *   ],
 *   repeating: false
 * })
 * // => "linear-gradient(red, blue)"
 * ```
 *
 * @example
 * With angle direction:
 * ```typescript
 * generate({
 *   kind: "linear",
 *   direction: { kind: "angle", value: { value: 45, unit: "deg" } },
 *   colorStops: [
 *     { color: { kind: "named", value: "red" } },
 *     { color: { kind: "named", value: "blue" } }
 *   ],
 *   repeating: false
 * })
 * // => "linear-gradient(45deg, red, blue)"
 * ```
 *
 * @example
 * With side direction:
 * ```typescript
 * generate({
 *   kind: "linear",
 *   direction: { kind: "to-side", value: "right" },
 *   colorStops: [
 *     { color: { kind: "named", value: "red" } },
 *     { color: { kind: "named", value: "blue" } }
 *   ],
 *   repeating: false
 * })
 * // => "linear-gradient(to right, red, blue)"
 * ```
 *
 * @example
 * With color interpolation:
 * ```typescript
 * generate({
 *   kind: "linear",
 *   colorSpace: "oklch",
 *   colorStops: [
 *     { color: { kind: "named", value: "red" } },
 *     { color: { kind: "named", value: "blue" } }
 *   ],
 *   repeating: false
 * })
 * // => "linear-gradient(in oklch, red, blue)"
 * ```
 */
export function generate(ir: Type.LinearGradient, context?: GenerateContext): GenerateResult {
  const functionName = ir.repeating ? "repeating-linear-gradient" : "linear-gradient";
  const parts: string[] = [];
  const allIssues: Type.Issue[] = [];

  if (ir.direction) {
    const dirResult = generateDirection(ir.direction);

    if (!dirResult.ok) return dirResult;
    parts.push(dirResult.value);
    allIssues.push(...dirResult.issues);
  }

  if (ir.colorInterpolationMethod) {
    const interpResult = generateColorInterpolation(ir.colorInterpolationMethod);
    if (!interpResult.ok) return interpResult;
    parts.push(interpResult.value);
    allIssues.push(...interpResult.issues);
  }

  for (let i = 0; i < ir.colorStops.length; i++) {
    const stop = ir.colorStops[i];
    const stopResult = ColorStop.generate(stop, {
      parentPath: [...(context?.parentPath ?? []), "colorStops", i],
      property: context?.property,
    });
    if (!stopResult.ok) return stopResult;
    parts.push(stopResult.value);
    allIssues.push(...stopResult.issues);
  }

  return {
    ok: true,
    value: `${functionName}(${parts.join(", ")})`,
    issues: allIssues,
  };
}


=== File: packages/b_generators/src/gradient/radial.ts ===
// b_path:: packages/b_generators/src/gradient/radial.ts
import { generateOk, type GenerateResult, type GenerateContext } from "@b/types";
import type * as Type from "@b/types";
import * as Position from "../position";
import * as ColorStop from "./color-stop";
import { cssValueToCss } from "@b/utils";

/**
 * Generate CSS radial gradient size string from RadialGradientSize IR.
 *
 * @param size - RadialGradientSize IR object
 * @returns CSS size string
 */
function generateSize(size: Type.RadialGradientSize): GenerateResult {
  if (size.kind === "keyword") {
    return generateOk(size.value);
  }

  if (size.kind === "circle-explicit") {
    return generateOk(cssValueToCss(size.radius));
  }

  const radiusX = cssValueToCss(size.radiusX);
  const radiusY = cssValueToCss(size.radiusY);

  return generateOk(`${radiusX} ${radiusY}`);
}

/**
 * Generate CSS color interpolation method string.
 */
function generateColorInterpolation(method: Type.ColorInterpolationMethod): GenerateResult {
  let css = `in ${method.colorSpace}`;

  if ("hueInterpolationMethod" in method && method.hueInterpolationMethod) {
    css += ` ${method.hueInterpolationMethod}`;
  }

  return generateOk(css);
}

/**
 * Generate a CSS radial gradient string from intermediate representation (IR).
 *
 * Converts a RadialGradient IR object into a valid CSS `radial-gradient()` or
 * `repeating-radial-gradient()` function string.
 *
 * @param ir - RadialGradient IR object to convert to CSS
 * @returns CSS radial gradient function string
 *
 * @example
 * Simple gradient:
 * ```typescript
 * generate({
 *   kind: "radial",
 *   colorStops: [
 *     { color: { kind: "named", value: "red" } },
 *     { color: { kind: "named", value: "blue" } }
 *   ],
 *   repeating: false
 * })
 * // => "radial-gradient(red, blue)"
 * ```
 *
 * @example
 * With shape and size:
 * ```typescript
 * generate({
 *   kind: "radial",
 *   shape: "circle",
 *   size: { kind: "keyword", value: "closest-side" },
 *   colorStops: [
 *     { color: { kind: "named", value: "red" } },
 *     { color: { kind: "named", value: "blue" } }
 *   ],
 *   repeating: false
 * })
 * // => "radial-gradient(circle closest-side, red, blue)"
 * ```
 *
 * @example
 * With position:
 * ```typescript
 * generate({
 *   kind: "radial",
 *   position: { horizontal: "center", vertical: "top" },
 *   colorStops: [
 *     { color: { kind: "named", value: "red" } },
 *     { color: { kind: "named", value: "blue" } }
 *   ],
 *   repeating: false
 * })
 * // => "radial-gradient(at center top, red, blue)"
 * ```
 */
export function generate(ir: Type.RadialGradient, context?: GenerateContext): GenerateResult {
  const functionName = ir.repeating ? "repeating-radial-gradient" : "radial-gradient";
  const parts: string[] = [];
  const firstPart: string[] = [];
  const allIssues: Type.Issue[] = [];

  if (ir.shape) {
    firstPart.push(ir.shape);
  }

  if (ir.size) {
    const sizeResult = generateSize(ir.size);
    if (!sizeResult.ok) return sizeResult;
    firstPart.push(sizeResult.value);
    allIssues.push(...sizeResult.issues);
  }

  if (ir.position) {
    const posResult = Position.generate(ir.position);
    if (!posResult.ok) return posResult;
    firstPart.push(`at ${posResult.value}`);
    allIssues.push(...posResult.issues);
  }

  if (firstPart.length > 0) {
    parts.push(firstPart.join(" "));
  }

  if (ir.colorInterpolationMethod) {
    const interpResult = generateColorInterpolation(ir.colorInterpolationMethod);
    if (!interpResult.ok) return interpResult;
    parts.push(interpResult.value);
    allIssues.push(...interpResult.issues);
  }

  for (let i = 0; i < ir.colorStops.length; i++) {
    const stop = ir.colorStops[i];
    const stopResult = ColorStop.generate(stop, {
      parentPath: [...(context?.parentPath ?? []), "colorStops", i],
      property: context?.property,
    });
    if (!stopResult.ok) return stopResult;
    parts.push(stopResult.value);
    allIssues.push(...stopResult.issues);
  }

  return {
    ok: true,
    value: `${functionName}(${parts.join(", ")})`,
    issues: allIssues,
  };
}


=== File: packages/b_generators/src/image/image.ts ===
// b_path:: packages/b_generators/src/image/image.ts

import { generateOk, generateErr, createError, type GenerateResult, type Image } from "@b/types";
import * as Generators from "@b/generators";

/**
 * Generate a single image value.
 */
export function generate(layer: Image): GenerateResult {
  switch (layer.kind) {
    case "none":
      return generateOk("none");

    case "url":
      return generateOk(`url(${layer.url})`);

    case "gradient": {
      return Generators.Gradient.generate(layer.gradient, { parentPath: ["gradient"] });
    }

    default:
      return generateErr(createError("invalid-ir", "Unsupported image layer kind"));
  }
}


=== File: packages/b_generators/src/image/index.ts ===
// b_path:: packages/b_generators/src/image/index.ts
export * from "./image";


=== File: packages/b_generators/src/index.ts ===
// b_path:: packages/b_generators/src/index.ts
export * as Angle from "./angle";
export * as Background from "./background";
export * as BlendMode from "./blend-mode";
export * as Color from "./color";
export * as Gradient from "./gradient";
export * as Image from "./image";
export * as Length from "./length";
export * as Position from "./position";


=== File: packages/b_generators/src/length.ts ===
// b_path:: packages/b_generators/src/length.ts
import { generateOk, type GenerateResult } from "@b/types";
import type * as Type from "@b/types";

/**
 * Generate CSS length string from Length IR
 * @see https://drafts.csswg.org/css-values-4/#lengths
 */
export function generate(length: Type.Length): GenerateResult {
  return generateOk(`${length.value}${length.unit}`);
}

/**
 * Generate CSS length-percentage string from LengthPercentage IR
 * @see https://drafts.csswg.org/css-values-4/#percentage-value
 */
export function generateLengthPercentage(lengthPercentage: Type.LengthPercentage): GenerateResult {
  return generateOk(`${lengthPercentage.value}${lengthPercentage.unit}`);
}


=== File: packages/b_generators/src/position.ts ===
// b_path:: packages/b_generators/src/position.ts
import { generateOk, type GenerateResult } from "@b/types";
import type * as Type from "@b/types";
import { cssValueToCss } from "@b/utils";

/**
 * Generate CSS position string from Position2D IR
 * Supports both simple values and edge+offset syntax
 * @see https://drafts.csswg.org/css-backgrounds-3/#typedef-bg-position
 */
export function generate(position: Type.Position2D): GenerateResult {
  const horizontal = generatePositionComponent(position.horizontal);
  const vertical = generatePositionComponent(position.vertical);

  return generateOk(`${horizontal} ${vertical}`);
}

/**
 * Generate CSS for a single position component (horizontal or vertical)
 */
function generatePositionComponent(component: Type.CssValue | Type.PositionEdgeOffset): string {
  // Check if it's edge+offset structure
  if ("edge" in component) {
    const offset = cssValueToCss(component.offset);
    return `${component.edge} ${offset}`;
  }

  // Simple value
  return cssValueToCss(component);
}


=== File: packages/b_generators/tsup.config.ts ===
// b_path:: packages/b_generators/tsup.config.ts
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/index.ts"],
  format: ["cjs", "esm"],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
  treeshake: true,
});


=== File: packages/b_generators/vite.config.ts ===
// b_path:: packages/b_generators/vite.config.ts
import { defineConfig } from "vite";

import tsconfigPaths from "vite-tsconfig-paths";

// https://vite.dev/config/
export default defineConfig({
  plugins: [tsconfigPaths()],
});


=== File: packages/b_keywords/src/background-attachment.ts ===
// b_path:: packages/b_keywords/src/background-attachment.ts

import { getLiteralValues } from "./utils";
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/background-attachment
 */
export const backgroundAttachment = z.union([z.literal("scroll"), z.literal("fixed"), z.literal("local")]);

export const BACKGROUND_ATTACHMENT = getLiteralValues(backgroundAttachment);

export type BackgroundAttachment = z.infer<typeof backgroundAttachment>;


=== File: packages/b_keywords/src/background-clip.ts ===
// b_path:: packages/b_keywords/src/background-clip.ts

import { getLiteralValues } from "./utils";
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/background-clip
 */
export const backgroundClip = z.union([
  z.literal("border-box"),
  z.literal("padding-box"),
  z.literal("content-box"),
  z.literal("text"),
]);

export const BACKGROUND_CLIP = getLiteralValues(backgroundClip);

export type BackgroundClip = z.infer<typeof backgroundClip>;


=== File: packages/b_keywords/src/background-origin.ts ===
// b_path:: packages/b_keywords/src/background-origin.ts

import { getLiteralValues } from "./utils";
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/background-origin
 */
export const backgroundOrigin = z.union([z.literal("border-box"), z.literal("padding-box"), z.literal("content-box")]);

export const BACKGROUND_ORIGIN = getLiteralValues(backgroundOrigin);

export type BackgroundOrigin = z.infer<typeof backgroundOrigin>;


=== File: packages/b_keywords/src/bg-size.ts ===
// b_path:: packages/b_keywords/src/bg-size.ts

import { z } from "zod";
import { getLiteralValues } from "./utils";

/**
 * Defines keywords for background-size and mask-size properties.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/background-size#values
 */
export const bgSize = z.union([z.literal("auto"), z.literal("cover"), z.literal("contain")]);

// Extract the raw string values for convenience
export const BG_SIZE = getLiteralValues(bgSize);

export type BgSize = z.infer<typeof bgSize>;


=== File: packages/b_keywords/src/blend-mode.ts ===
// b_path:: packages/b_keywords/src/blend-mode.ts

import { getLiteralValues } from "./utils";
import { z } from "zod";

/**
 * Blend mode keywords for compositing operations
 * @see https://drafts.fxtf.org/compositing/#ltblendmodegt
 */
export const blendMode = z.union([
  z.literal("normal"),
  z.literal("multiply"),
  z.literal("screen"),
  z.literal("overlay"),
  z.literal("darken"),
  z.literal("lighten"),
  z.literal("color-dodge"),
  z.literal("color-burn"),
  z.literal("hard-light"),
  z.literal("soft-light"),
  z.literal("difference"),
  z.literal("exclusion"),
  z.literal("hue"),
  z.literal("saturation"),
  z.literal("color"),
  z.literal("luminosity"),
  z.literal("plus-lighter"), // mix-blend-mode only
]);

export const BLEND_MODE = getLiteralValues(blendMode);
export type BlendMode = z.infer<typeof blendMode>;


=== File: packages/b_keywords/src/color-interpolation.ts ===
// b_path:: packages/b_keywords/src/color-interpolation.ts
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-method
 */

export const rectangularColorSpace = z.union([
  z.literal("srgb"),
  z.literal("srgb-linear"),
  z.literal("display-p3"),
  z.literal("display-p3-linear"),
  z.literal("a98-rgb"),
  z.literal("prophoto-rgb"),
  z.literal("rec2020"),
  z.literal("lab"),
  z.literal("oklab"),
  z.literal("xyz"),
  z.literal("xyz-d50"),
  z.literal("xyz-d65"),
]);

export type RectangularColorSpace = z.infer<typeof rectangularColorSpace>;

export const polarColorSpace = z.union([z.literal("hsl"), z.literal("hwb"), z.literal("lch"), z.literal("oklch")]);

export type PolarColorSpace = z.infer<typeof polarColorSpace>;

export const hueInterpolationMethod = z.union([
  z.literal("shorter hue"),
  z.literal("longer hue"),
  z.literal("increasing hue"),
  z.literal("decreasing hue"),
]);

export type HueInterpolationMethod = z.infer<typeof hueInterpolationMethod>;

// For backward compatibility, keep the simple union
export const colorInterpolation = z.union([rectangularColorSpace, polarColorSpace]);

export type ColorInterpolation = z.infer<typeof colorInterpolation>;


=== File: packages/b_keywords/src/color-space.ts ===
// b_path:: packages/b_keywords/src/color-space.ts
import { z } from "zod";

/**
 * Color spaces supported by the color() function
 * @see https://www.w3.org/TR/css-color-4/#color-function
 */
export const colorFunctionSpace = z.union([
  z.literal("srgb"),
  z.literal("srgb-linear"),
  z.literal("display-p3"),
  z.literal("a98-rgb"),
  z.literal("prophoto-rgb"),
  z.literal("rec2020"),
  z.literal("xyz"),
  z.literal("xyz-d50"),
  z.literal("xyz-d65"),
]);

export type ColorFunctionSpace = z.infer<typeof colorFunctionSpace>;


=== File: packages/b_keywords/src/common.ts ===
// b_path:: packages/b_keywords/src/common.ts
import { z } from "zod";

/**
 * Defines CSS-wide keywords that apply to all properties.
 * @see https://www.w3.org/TR/css-values-4/#common-keywords
 */
export const cssWide = z.union([
  z.literal("inherit"),
  z.literal("initial"),
  z.literal("unset"),
  z.literal("revert"),
  z.literal("revert-layer"),
]);

export type CssWide = z.infer<typeof cssWide>;


=== File: packages/b_keywords/src/gradient-direction.ts ===
// b_path:: packages/b_keywords/src/gradient-direction.ts
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient
 */
export const gradientSide = z.union([z.literal("top"), z.literal("right"), z.literal("bottom"), z.literal("left")]);

export const gradientCorner = z.union([
  z.literal("top left"),
  z.literal("top right"),
  z.literal("bottom left"),
  z.literal("bottom right"),
]);

export type GradientSide = z.infer<typeof gradientSide>;
export type GradientCorner = z.infer<typeof gradientCorner>;


=== File: packages/b_keywords/src/index.ts ===
// b_path:: packages/b_keywords/src/index.ts
export * from "./background-attachment";
export * from "./background-clip";
export * from "./background-origin";
export * from "./bg-size";
export * from "./blend-mode";
export * from "./color-interpolation";
export * from "./color-space";
export * from "./common";
export * from "./gradient-direction";
export * from "./named-colors";
export * from "./none";
export * from "./position";
export * from "./radial-shape";
export * from "./radial-size";
export * from "./utils";


=== File: packages/b_keywords/src/named-colors.ts ===
// b_path:: packages/b_keywords/src/named-colors.ts
import { z } from "zod";
import { getLiteralValues } from "./utils";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/named-color
 */

export const namedColors = [
  z.literal("transparent"),
  z.literal("currentcolor"),
  z.literal("black"),
  z.literal("white"),
  z.literal("red"),
  z.literal("green"),
  z.literal("blue"),
  z.literal("yellow"),
  z.literal("orange"),
  z.literal("purple"),
  z.literal("pink"),
  z.literal("brown"),
  z.literal("gray"),
  z.literal("grey"),
  z.literal("silver"),
  z.literal("gold"),
  z.literal("navy"),
  z.literal("teal"),
  z.literal("lime"),
  z.literal("aqua"),
  z.literal("fuchsia"),
  z.literal("maroon"),
  z.literal("olive"),
  z.literal("cyan"),
  z.literal("aliceblue"),
  z.literal("antiquewhite"),
  z.literal("aquamarine"),
  z.literal("azure"),
  z.literal("beige"),
  z.literal("bisque"),
  z.literal("blanchedalmond"),
  z.literal("blueviolet"),
  z.literal("burlywood"),
  z.literal("cadetblue"),
  z.literal("chartreuse"),
  z.literal("chocolate"),
  z.literal("coral"),
  z.literal("cornflowerblue"),
  z.literal("cornsilk"),
  z.literal("crimson"),
  z.literal("darkblue"),
  z.literal("darkcyan"),
  z.literal("darkgoldenrod"),
  z.literal("darkgray"),
  z.literal("darkgrey"),
  z.literal("darkgreen"),
  z.literal("darkkhaki"),
  z.literal("darkmagenta"),
  z.literal("darkolivegreen"),
  z.literal("darkorange"),
  z.literal("darkorchid"),
  z.literal("darkred"),
  z.literal("darksalmon"),
  z.literal("darkseagreen"),
  z.literal("darkslateblue"),
  z.literal("darkslategray"),
  z.literal("darkslategrey"),
  z.literal("darkturquoise"),
  z.literal("darkviolet"),
  z.literal("deeppink"),
  z.literal("deepskyblue"),
  z.literal("dimgray"),
  z.literal("dimgrey"),
  z.literal("dodgerblue"),
  z.literal("firebrick"),
  z.literal("floralwhite"),
  z.literal("forestgreen"),
  z.literal("gainsboro"),
  z.literal("ghostwhite"),
  z.literal("goldenrod"),
  z.literal("greenyellow"),
  z.literal("honeydew"),
  z.literal("hotpink"),
  z.literal("indianred"),
  z.literal("indigo"),
  z.literal("ivory"),
  z.literal("khaki"),
  z.literal("lavender"),
  z.literal("lavenderblush"),
  z.literal("lawngreen"),
  z.literal("lemonchiffon"),
  z.literal("lightblue"),
  z.literal("lightcoral"),
  z.literal("lightcyan"),
  z.literal("lightgoldenrodyellow"),
  z.literal("lightgray"),
  z.literal("lightgrey"),
  z.literal("lightgreen"),
  z.literal("lightpink"),
  z.literal("lightsalmon"),
  z.literal("lightseagreen"),
  z.literal("lightskyblue"),
  z.literal("lightslategray"),
  z.literal("lightslategrey"),
  z.literal("lightsteelblue"),
  z.literal("lightyellow"),
  z.literal("limegreen"),
  z.literal("linen"),
  z.literal("magenta"),
  z.literal("mediumaquamarine"),
  z.literal("mediumblue"),
  z.literal("mediumorchid"),
  z.literal("mediumpurple"),
  z.literal("mediumseagreen"),
  z.literal("mediumslateblue"),
  z.literal("mediumspringgreen"),
  z.literal("mediumturquoise"),
  z.literal("mediumvioletred"),
  z.literal("midnightblue"),
  z.literal("mintcream"),
  z.literal("mistyrose"),
  z.literal("moccasin"),
  z.literal("navajowhite"),
  z.literal("oldlace"),
  z.literal("olivedrab"),
  z.literal("orangered"),
  z.literal("orchid"),
  z.literal("palegoldenrod"),
  z.literal("palegreen"),
  z.literal("paleturquoise"),
  z.literal("palevioletred"),
  z.literal("papayawhip"),
  z.literal("peachpuff"),
  z.literal("peru"),
  z.literal("plum"),
  z.literal("powderblue"),
  z.literal("rebeccapurple"),
  z.literal("rosybrown"),
  z.literal("royalblue"),
  z.literal("saddlebrown"),
  z.literal("salmon"),
  z.literal("sandybrown"),
  z.literal("seagreen"),
  z.literal("seashell"),
  z.literal("sienna"),
  z.literal("skyblue"),
  z.literal("slateblue"),
  z.literal("slategray"),
  z.literal("slategrey"),
  z.literal("snow"),
  z.literal("springgreen"),
  z.literal("steelblue"),
  z.literal("tan"),
  z.literal("thistle"),
  z.literal("tomato"),
  z.literal("turquoise"),
  z.literal("violet"),
  z.literal("wheat"),
  z.literal("whitesmoke"),
  z.literal("yellowgreen"),
];

export const namedColorsValues = namedColors.flatMap(getLiteralValues);

// Zod union schema for named colors
// Context for better error messages is provided at validation sites
export const namedColor = z.union(namedColors);

export type NamedColor = z.infer<typeof namedColor>;


=== File: packages/b_keywords/src/none.ts ===
// b_path:: packages/b_keywords/src/none.ts
import { z } from "zod";

export const none = z.literal("none");
export type None = z.infer<typeof none>;


=== File: packages/b_keywords/src/position.ts ===
// b_path:: packages/b_keywords/src/position.ts
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position_value
 */
export const positionKeyword = z.union([
  z.literal("center"),
  z.literal("left"),
  z.literal("right"),
  z.literal("top"),
  z.literal("bottom"),
  z.literal("x-start"),
  z.literal("x-end"),
  z.literal("y-start"),
  z.literal("y-end"),
  z.literal("block-start"),
  z.literal("block-end"),
  z.literal("inline-start"),
  z.literal("inline-end"),
  z.literal("start"),
  z.literal("end"),
]);

export type PositionKeyword = z.infer<typeof positionKeyword>;

export const positionHorizontalEdge = z.union([
  z.literal("left"),
  z.literal("right"),
  z.literal("x-start"),
  z.literal("x-end"),
]);

export type PositionHorizontalEdge = z.infer<typeof positionHorizontalEdge>;

export const positionVerticalEdge = z.union([
  z.literal("top"),
  z.literal("bottom"),
  z.literal("y-start"),
  z.literal("y-end"),
]);

export type PositionVerticalEdge = z.infer<typeof positionVerticalEdge>;


=== File: packages/b_keywords/src/radial-shape.ts ===
// b_path:: packages/b_keywords/src/radial-shape.ts
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient
 */
export const radialShape = z.union([z.literal("circle"), z.literal("ellipse")]);

export type RadialShape = z.infer<typeof radialShape>;


=== File: packages/b_keywords/src/radial-size.ts ===
// b_path:: packages/b_keywords/src/radial-size.ts
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient
 */
export const radialSizeKeyword = z.union([
  z.literal("closest-side"),
  z.literal("farthest-side"),
  z.literal("closest-corner"),
  z.literal("farthest-corner"),
]);

export type RadialSizeKeyword = z.infer<typeof radialSizeKeyword>;


=== File: packages/b_keywords/src/utils/index.ts ===
// b_path:: packages/b_keywords/src/utils/index.ts
export * from "./zod";


=== File: packages/b_keywords/src/utils/zod.ts ===
// b_path:: packages/b_keywords/src/utils/zod.ts
import { z } from "zod";

/**
 * Extract literal string values from a Zod schema.
 *
 * Recursively traverses ZodLiteral and ZodUnion schemas to collect all literal string values.
 *
 * @param schema
 * @returns Array of literal string values
 *
 */
export function getLiteralValues(schema: z.core.$ZodType): string[] {
  if (schema instanceof z.ZodLiteral) {
    return [String(schema.value)];
  }
  if (schema instanceof z.ZodUnion) {
    return schema.options.flatMap(getLiteralValues);
  }
  return [];
}


=== File: packages/b_keywords/tsup.config.ts ===
// b_path:: packages/b_keywords/tsup.config.ts
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/index.ts"],
  format: ["cjs", "esm"],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
  treeshake: true,
});


=== File: packages/b_keywords/vite.config.ts ===
// b_path:: packages/b_keywords/vite.config.ts
import { defineConfig } from "vite";

import tsconfigPaths from "vite-tsconfig-paths";

// https://vite.dev/config/
export default defineConfig({
  plugins: [tsconfigPaths()],
});


=== File: packages/b_parsers/src/angle.ts ===
// b_path:: packages/b_parsers/src/angle.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, type ParseResult } from "@b/types";
import type * as Type from "@b/types";
import * as Unit from "@b/units";

/**
 * Parse angle AST node from css-tree.
 *
 * @see https://drafts.csswg.org/css-values-4/#angles
 */
export function parseAngleNode(node: csstree.CssNode): ParseResult<Type.Angle> {
  if (node.type !== "Dimension") {
    return parseErr("angle", createError("invalid-syntax", `Expected angle dimension, but got node type ${node.type}`));
  }

  const value = Number.parseFloat(node.value);
  if (Number.isNaN(value)) {
    return parseErr("angle", createError("invalid-value", "Invalid angle value: not a number"));
  }

  if (!Unit.ANGLE_UNITS.includes(node.unit as (typeof Unit.ANGLE_UNITS)[number])) {
    return parseErr("angle", createError("invalid-value", `Invalid angle unit: '${node.unit}'`));
  }

  return parseOk({ value, unit: node.unit as (typeof Unit.ANGLE_UNITS)[number] });
}


=== File: packages/b_parsers/src/background/attachment.ts ===
// b_path:: packages/b_parsers/src/background/attachment.ts

import type * as csstree from "@eslint/css-tree";
import { BACKGROUND_ATTACHMENT, type BackgroundAttachment } from "@b/keywords";
import { createError, parseErr, parseOk, type ParseResult } from "@b/types";
import * as Ast from "@b/utils";

/**
 * Parse a single background-attachment value from a CSS AST node.
 *
 * Syntax: scroll | fixed | local
 *
 * @param valueNode - The Value node containing the attachment value
 * @returns ParseResult with BackgroundAttachment
 */
export function parse(valueNode: csstree.Value): ParseResult<BackgroundAttachment> {
  const nodes = Ast.nodeListToArray(valueNode.children);
  const node = nodes[0];

  if (!node || !Ast.isIdentifier(node)) {
    return parseErr("background-attachment", createError("invalid-syntax", "Expected attachment value"));
  }

  const val = node.name.toLowerCase();
  if (BACKGROUND_ATTACHMENT.includes(val as BackgroundAttachment)) {
    return parseOk(val as BackgroundAttachment);
  }

  return parseErr(
    "background-attachment",
    createError("invalid-value", `Invalid background-attachment value: '${val}'. Expected: scroll, fixed, or local`),
  );
}


=== File: packages/b_parsers/src/background/clip.ts ===
// b_path:: packages/b_parsers/src/background/clip.ts

import type * as csstree from "@eslint/css-tree";
import { BACKGROUND_CLIP, type BackgroundClip } from "@b/keywords";
import { createError, parseErr, parseOk, type ParseResult } from "@b/types";
import * as Ast from "@b/utils";

/**
 * Parse a single background-clip value from a CSS AST node.
 *
 * Syntax: border-box | padding-box | content-box | text
 *
 * Note: Universal functions (var, calc, etc.) are handled at the declaration layer.
 *
 * @param valueNode - The Value node containing the box value
 * @returns ParseResult with BackgroundClip string
 */
export function parse(valueNode: csstree.Value): ParseResult<BackgroundClip> {
  const nodes = Ast.nodeListToArray(valueNode.children);
  const node = nodes[0];

  if (!node || !Ast.isIdentifier(node)) {
    return parseErr("background-clip", createError("invalid-syntax", "Expected box value"));
  }

  const val = node.name.toLowerCase();
  if (BACKGROUND_CLIP.includes(val as BackgroundClip)) {
    return parseOk(val as BackgroundClip);
  }

  return parseErr(
    "background-clip",
    createError(
      "invalid-value",
      `Invalid background-clip value: '${val}'. Expected: border-box, padding-box, content-box, or text`,
    ),
  );
}


=== File: packages/b_parsers/src/background/index.ts ===
// b_path:: packages/b_parsers/src/background/index.ts

export * as Attachment from "./attachment";
export * as Clip from "./clip";
export * as Origin from "./origin";
export * as Repeat from "./repeat";
export * as Size from "./size";


=== File: packages/b_parsers/src/background/origin.ts ===
// b_path:: packages/b_parsers/src/background/origin.ts

import type * as csstree from "@eslint/css-tree";
import { BACKGROUND_ORIGIN, type BackgroundOrigin } from "@b/keywords";
import { createError, parseErr, parseOk, type ParseResult } from "@b/types";
import * as Ast from "@b/utils";

/**
 * Parse a single background-origin value from a CSS AST node.
 *
 * Syntax: border-box | padding-box | content-box
 *
 * @param valueNode - The Value node containing the box value
 * @returns ParseResult with BackgroundOrigin
 */
export function parse(valueNode: csstree.Value): ParseResult<BackgroundOrigin> {
  const nodes = Ast.nodeListToArray(valueNode.children);
  const node = nodes[0];

  if (!node || !Ast.isIdentifier(node)) {
    return parseErr("background-origin", createError("invalid-syntax", "Expected box value"));
  }

  const val = node.name.toLowerCase();
  if (BACKGROUND_ORIGIN.includes(val as BackgroundOrigin)) {
    return parseOk(val as BackgroundOrigin);
  }

  return parseErr(
    "background-origin",
    createError(
      "invalid-value",
      `Invalid background-origin value: '${val}'. Expected: border-box, padding-box, or content-box`,
    ),
  );
}


=== File: packages/b_parsers/src/background/repeat.ts ===
// b_path:: packages/b_parsers/src/background/repeat.ts

import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, type ParseResult, type CssValue } from "@b/types";
import * as Ast from "@b/utils";
import { parseNodeToCssValue } from "../utils/css-value-parser";

const REPETITION_VALUES = ["repeat", "space", "round", "no-repeat"] as const;
type RepetitionValue = (typeof REPETITION_VALUES)[number];

type RepeatStyle =
  | { kind: "shorthand"; value: "repeat-x" | "repeat-y" }
  | { kind: "explicit"; horizontal: RepetitionValue; vertical: RepetitionValue };

/**
 * Parse a single background-repeat value from a CSS AST node.
 *
 * Syntax: repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2} | var() | calc()
 *
 * @param valueNode - The Value node containing the repeat value
 * @returns ParseResult with RepeatStyle or CssValue
 */
export function parse(valueNode: csstree.Value): ParseResult<RepeatStyle | CssValue> {
  const allNodes = Ast.nodeListToArray(valueNode.children);
  const nodes = allNodes.filter((node) => node.type !== "WhiteSpace");

  if (nodes.length === 0) {
    return parseErr("background-repeat", createError("invalid-syntax", "Expected repeat value"));
  }

  const firstNode = nodes[0];
  if (!firstNode) {
    return parseErr("background-repeat", createError("invalid-syntax", "Expected repeat value"));
  }

  // Handle var(), calc(), and other CSS functions
  if (Ast.isFunctionNode(firstNode)) {
    return parseNodeToCssValue(firstNode);
  }

  if (nodes.length > 2) {
    return parseErr("background-repeat", createError("invalid-syntax", "Too many values for repeat style (max 2)"));
  }

  if (!Ast.isIdentifier(firstNode)) {
    return parseErr("background-repeat", createError("invalid-syntax", "Expected repeat value"));
  }

  const firstValue = firstNode.name.toLowerCase();

  // Check for shorthand
  if (firstValue === "repeat-x") {
    return parseOk({ kind: "shorthand", value: "repeat-x" });
  }
  if (firstValue === "repeat-y") {
    return parseOk({ kind: "shorthand", value: "repeat-y" });
  }

  // Parse explicit form
  if (!REPETITION_VALUES.includes(firstValue as RepetitionValue)) {
    return parseErr(
      "background-repeat",
      createError(
        "invalid-value",
        `Invalid repeat value: '${firstValue}'. Expected: repeat, space, round, no-repeat, repeat-x, repeat-y, or a CSS function like var()`,
      ),
    );
  }

  const horizontal = firstValue as RepetitionValue;

  // Check for second value
  if (nodes.length === 1) {
    // Single value - apply to both axes
    return parseOk({
      kind: "explicit",
      horizontal,
      vertical: horizontal,
    });
  }

  // Two values
  const secondNode = nodes[1];
  if (!secondNode || !Ast.isIdentifier(secondNode)) {
    return parseErr(
      "background-repeat",
      createError("invalid-syntax", `Expected second repeat value, got ${secondNode?.type}`),
    );
  }

  const secondValue = secondNode.name.toLowerCase();
  if (!REPETITION_VALUES.includes(secondValue as RepetitionValue)) {
    return parseErr(
      "background-repeat",
      createError(
        "invalid-value",
        `Invalid repeat value: '${secondValue}'. Expected: repeat, space, round, or no-repeat`,
      ),
    );
  }

  return parseOk({
    kind: "explicit",
    horizontal,
    vertical: secondValue as RepetitionValue,
  });
}


=== File: packages/b_parsers/src/background/size.ts ===
// b_path:: packages/b_parsers/src/background/size.ts

import type * as csstree from "@eslint/css-tree";
import * as Keywords from "@b/keywords";
import {
  createError,
  parseErr,
  parseOk,
  forwardParseErr,
  type ParseResult,
  type BgSize,
  type CssValue,
  type KeywordValue,
} from "@b/types";
import * as Ast from "@b/utils";
import { parseNodeToCssValue } from "../utils/css-value-parser";

/**
 * Parse a single <bg-size> value from a CSS AST node.
 *
 * Syntax: [ <length-percentage [0,∞]> | auto ]{1,2} | cover | contain
 *
 * @param valueNode - The Value node containing the bg-size
 * @returns ParseResult with BgSize
 */
export function parse(valueNode: csstree.Value): ParseResult<BgSize> {
  const children = Ast.nodeListToArray(valueNode.children);

  // Handle keywords: auto, cover, contain
  if (children.length === 1 && children[0].type === "Identifier") {
    const keyword = children[0].name;
    const keywordResult = Keywords.bgSize.safeParse(keyword);
    if (keywordResult.success) {
      return parseOk({ kind: "keyword", value: keywordResult.data });
    }
    // If it's not a bg-size keyword, it's invalid
    return parseErr(
      "background-size",
      createError(
        "invalid-syntax",
        `Invalid background-size keyword '${keyword}'. Expected 'auto', 'cover', 'contain', or a length/percentage.`,
      ),
    );
  }

  // Handle explicit sizes: 1 or 2 values (width [height])
  if (children.length === 1 || children.length === 2) {
    const widthResult = parseSizeComponent(children[0]);
    if (!widthResult.ok) return forwardParseErr<BgSize>(widthResult);
    const autoKeywordIR: KeywordValue = { kind: "keyword", value: "auto" };
    // If only one value, apply to both width and height
    if (children.length === 1) {
      return parseOk({
        kind: "explicit",
        width: widthResult.value,
        height: autoKeywordIR,
      });
    }

    // Two values: width height
    const heightResult = parseSizeComponent(children[1]);
    if (!heightResult.ok) return forwardParseErr<BgSize>(heightResult);

    return parseOk({
      kind: "explicit",
      width: widthResult.value,
      height: heightResult.value,
    });
  }

  return parseErr("background-size", createError("invalid-syntax", `Expected 1-2 size values, got ${children.length}`));
}

/**
 * Parse a single size component (width or height).
 * Valid values: auto | <length-percentage> | var() | calc() etc.
 */
function parseSizeComponent(node: csstree.CssNode): ParseResult<CssValue> {
  // Use the generic parser (handles keywords like 'auto', length, percentage, var(), calc(), etc.)
  return parseNodeToCssValue(node);
}


=== File: packages/b_parsers/src/blend-mode.ts ===
// b_path:: packages/b_parsers/src/blend-mode.ts

import type * as csstree from "@eslint/css-tree";
import { BLEND_MODE, type BlendMode } from "@b/keywords";
import { createError, parseErr, parseOk, type ParseResult } from "@b/types";
import * as Ast from "@b/utils";

/**
 * Parse CSS <blend-mode> value
 * @see https://drafts.fxtf.org/compositing/#ltblendmodegt
 */
export function parse(valueNode: csstree.Value): ParseResult<BlendMode> {
  const nodes = Ast.nodeListToArray(valueNode.children);
  const node = nodes[0];

  if (!node || !Ast.isIdentifier(node)) {
    return parseErr("blend-mode", createError("invalid-syntax", "Expected blend-mode value"));
  }

  const val = node.name.toLowerCase();
  if (BLEND_MODE.includes(val as BlendMode)) {
    return parseOk(val as BlendMode);
  }

  return parseErr("blend-mode", createError("invalid-value", `Invalid blend-mode: '${val}'`));
}


=== File: packages/b_parsers/src/color/color-function.ts ===
// b_path:: packages/b_parsers/src/color/color-function.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, forwardParseErr, type ParseResult } from "@b/types";
import type { ColorFunction } from "@b/types";
import { parseNodeToCssValue } from "../utils";
import { getChildren, getValues } from "@b/utils";
import * as Keywords from "@b/keywords";

/**
 * Parse color() function from css-tree AST.
 *
 * @see https://www.w3.org/TR/css-color-4/#color-function
 */
export function parseColorFunction(node: csstree.FunctionNode): ParseResult<ColorFunction> {
  if (node.name !== "color") {
    return parseErr("color-function", createError("invalid-syntax", "Expected color() function"));
  }

  const values = getValues(getChildren(node));

  if (values.length < 4) {
    return parseErr(
      "color",
      createError(
        "invalid-syntax",
        `color() function must have at least 4 values (space + 3 channels), got ${values.length}`,
      ),
    );
  }

  // First value must be the color space identifier
  const colorSpaceNode = values[0];
  if (!colorSpaceNode || colorSpaceNode.type !== "Identifier") {
    return parseErr(
      "color",
      createError("invalid-syntax", "color() function must start with a color space identifier"),
    );
  }

  const colorSpaceResult = Keywords.colorFunctionSpace.safeParse(colorSpaceNode.name);
  if (!colorSpaceResult.success) {
    return parseErr("color-function", createError("invalid-syntax", `Invalid color space: ${colorSpaceNode.name}`));
  }

  // Parse the three channel values
  const c1Result = parseNodeToCssValue(values[1]);
  if (!c1Result.ok) return forwardParseErr<ColorFunction>(c1Result);

  const c2Result = parseNodeToCssValue(values[2]);
  if (!c2Result.ok) return forwardParseErr<ColorFunction>(c2Result);

  const c3Result = parseNodeToCssValue(values[3]);
  if (!c3Result.ok) return forwardParseErr<ColorFunction>(c3Result);

  const colorFunc: ColorFunction = {
    kind: "color",
    colorSpace: colorSpaceResult.data,
    channels: [c1Result.value, c2Result.value, c3Result.value],
  };

  // Optional alpha channel (5th value after the 4 required)
  if (values.length === 5) {
    const alphaResult = parseNodeToCssValue(values[4]);
    if (!alphaResult.ok) return forwardParseErr<ColorFunction>(alphaResult);
    colorFunc.alpha = alphaResult.value;
  }

  return parseOk(colorFunc);
}


=== File: packages/b_parsers/src/color/color.ts ===
// b_path:: packages/b_parsers/src/color/color.ts
import * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, type ParseResult } from "@b/types";
import type * as Type from "@b/types";
import { parseNodeToCssValue } from "../utils";
import { parseRgbFunction } from "./rgb";
import { parseHslFunction } from "./hsl";
import { parseHwbFunction } from "./hwb";
import { parseLabFunction } from "./lab";
import { parseLchFunction } from "./lch";
import { parseOklabFunction } from "./oklab";
import { parseOklchFunction } from "./oklch";
import { parseColorFunction } from "./color-function";

/**
 * Parse color AST node with auto-detection.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
 */
export function parseNode(node: csstree.CssNode): ParseResult<Type.Color> {
  if (node.type === "Hash") {
    const value = node.value.toLowerCase();
    // Validate hex color format (3, 4, 6, or 8 hex digits)
    const hexPattern = /^[0-9a-f]{3}$|^[0-9a-f]{4}$|^[0-9a-f]{6}$|^[0-9a-f]{8}$/;
    if (!hexPattern.test(value)) {
      return parseErr("color", createError("invalid-value", `Invalid hex color: #${value}`));
    }
    return parseOk({ kind: "hex", value: `#${value}` } as Type.Color);
  }

  if (node.type === "Function") {
    const funcName = node.name.toLowerCase();

    // Handle var() which can represent any color
    if (funcName === "var") {
      const result = parseNodeToCssValue(node);
      if (result.ok && result.value.kind === "variable") {
        return parseOk(result.value as Type.Color);
      }
      return result as ParseResult<Type.Color>;
    }

    switch (funcName) {
      case "rgb":
      case "rgba":
        return parseRgbFunction(node);
      case "hsl":
      case "hsla":
        return parseHslFunction(node);
      case "hwb":
        return parseHwbFunction(node);
      case "lab":
        return parseLabFunction(node);
      case "lch":
        return parseLchFunction(node);
      case "oklab":
        return parseOklabFunction(node);
      case "oklch":
        return parseOklchFunction(node);
      case "color":
        return parseColorFunction(node);
      default:
        return parseErr("color", createError("unsupported-kind", `Unsupported color function: ${funcName}`));
    }
  }

  if (node.type === "Identifier") {
    const keyword = node.name.toLowerCase();

    if (keyword === "transparent" || keyword === "currentcolor") {
      return parseOk({ kind: "special", keyword } as Type.Color);
    }

    return parseOk({ kind: "named", name: keyword } as Type.Color);
  }

  return parseErr("color", createError("invalid-syntax", `Invalid color node type: ${node.type}`));
}

/**
 * Parse color value string with auto-detection.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
 */
export function parse(value: string): ParseResult<Type.Color> {
  try {
    const ast = csstree.parse(value, { context: "value" });

    let firstNode: csstree.CssNode | null = null;
    csstree.walk(ast, {
      enter(node: csstree.CssNode) {
        if (!firstNode && node.type !== "Value") {
          firstNode = node;
        }
      },
    });

    if (!firstNode) {
      return parseErr("color", createError("invalid-syntax", "Empty value"));
    }

    return parseNode(firstNode);
  } catch (e) {
    return parseErr(
      "color",
      createError("invalid-syntax", `Failed to parse color: ${e instanceof Error ? e.message : String(e)}`),
    );
  }
}


=== File: packages/b_parsers/src/color/hsl.ts ===
// b_path:: packages/b_parsers/src/color/hsl.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, forwardParseErr, type ParseResult } from "@b/types";
import type { HSLColor } from "@b/types";
import { parseNodeToCssValue } from "../utils";
import { getChildren, getValues } from "@b/utils";

/**
 * Parse hsl() or hsla() function
 * @see https://drafts.csswg.org/css-color/#the-hsl-notation
 */
export function parseHslFunction(node: csstree.FunctionNode): ParseResult<HSLColor> {
  if (node.name !== "hsl" && node.name !== "hsla") {
    return parseErr("hsl", createError("invalid-syntax", "Expected hsl() or hsla() function"));
  }

  const values = getValues(getChildren(node));

  if (values.length < 3 || values.length > 4) {
    return parseErr("hsl", createError("invalid-syntax", `HSL function must have 3 or 4 values, got ${values.length}`));
  }

  const hResult = parseNodeToCssValue(values[0]);
  if (!hResult.ok) return forwardParseErr<HSLColor>(hResult);

  const sResult = parseNodeToCssValue(values[1]);
  if (!sResult.ok) return forwardParseErr<HSLColor>(sResult);

  const lResult = parseNodeToCssValue(values[2]);
  if (!lResult.ok) return forwardParseErr<HSLColor>(lResult);

  const hsl: HSLColor = {
    kind: "hsl",
    h: hResult.value,
    s: sResult.value,
    l: lResult.value,
  };

  if (values.length === 4) {
    const alphaResult = parseNodeToCssValue(values[3]);
    if (!alphaResult.ok) return forwardParseErr<HSLColor>(alphaResult);
    hsl.alpha = alphaResult.value;
  }

  return parseOk(hsl);
}


=== File: packages/b_parsers/src/color/hwb.ts ===
// b_path:: packages/b_parsers/src/color/hwb.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, forwardParseErr, type ParseResult } from "@b/types";
import type { HWBColor } from "@b/types";
import { parseNodeToCssValue } from "../utils";
import { getChildren, getValues } from "@b/utils";

/**
 * Parse hwb() function
 * @see https://drafts.csswg.org/css-color/#the-hwb-notation
 */
export function parseHwbFunction(node: csstree.FunctionNode): ParseResult<HWBColor> {
  if (node.name !== "hwb") {
    return parseErr("hwb", createError("invalid-syntax", "Expected hwb() function"));
  }

  const values = getValues(getChildren(node));

  if (values.length < 3 || values.length > 4) {
    return parseErr("hwb", createError("invalid-syntax", `HWB function must have 3 or 4 values, got ${values.length}`));
  }

  const hResult = parseNodeToCssValue(values[0]);
  if (!hResult.ok) return forwardParseErr<HWBColor>(hResult);

  const wResult = parseNodeToCssValue(values[1]);
  if (!wResult.ok) return forwardParseErr<HWBColor>(wResult);

  const bResult = parseNodeToCssValue(values[2]);
  if (!bResult.ok) return forwardParseErr<HWBColor>(bResult);

  const hwb: HWBColor = {
    kind: "hwb",
    h: hResult.value,
    w: wResult.value,
    b: bResult.value,
  };

  if (values.length === 4) {
    const alphaResult = parseNodeToCssValue(values[3]);
    if (!alphaResult.ok) return forwardParseErr<HWBColor>(alphaResult);
    hwb.alpha = alphaResult.value;
  }

  return parseOk(hwb);
}


=== File: packages/b_parsers/src/color/index.ts ===
// b_path:: packages/b_parsers/src/color/index.ts
export * from "@b/utils";
export * from "./color";
export * from "./color-function";
export * from "./rgb";
export * from "./hsl";
export * from "./hwb";
export * from "./lab";
export * from "./lch";
export * from "./oklab";
export * from "./oklch";


=== File: packages/b_parsers/src/color/lab.ts ===
// b_path:: packages/b_parsers/src/color/lab.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, forwardParseErr, type ParseResult } from "@b/types";
import type { LABColor } from "@b/types";
import { parseNodeToCssValue } from "../utils";
import { getChildren, getValues } from "@b/utils";

/**
 * Parse lab() function
 * @see https://drafts.csswg.org/css-color/#lab-colors
 */
export function parseLabFunction(node: csstree.FunctionNode): ParseResult<LABColor> {
  if (node.name !== "lab") {
    return parseErr("lab", createError("invalid-syntax", "Expected lab() function"));
  }

  const values = getValues(getChildren(node));

  if (values.length < 3 || values.length > 4) {
    return parseErr("lab", createError("invalid-syntax", `LAB function must have 3 or 4 values, got ${values.length}`));
  }

  const lResult = parseNodeToCssValue(values[0]);
  if (!lResult.ok) return forwardParseErr<LABColor>(lResult);

  const aResult = parseNodeToCssValue(values[1]);
  if (!aResult.ok) return forwardParseErr<LABColor>(aResult);

  const bResult = parseNodeToCssValue(values[2]);
  if (!bResult.ok) return forwardParseErr<LABColor>(bResult);

  const lab: LABColor = {
    kind: "lab",
    l: lResult.value,
    a: aResult.value,
    b: bResult.value,
  };

  if (values.length === 4) {
    const alphaResult = parseNodeToCssValue(values[3]);
    if (!alphaResult.ok) return forwardParseErr<LABColor>(alphaResult);
    lab.alpha = alphaResult.value;
  }

  return parseOk(lab);
}


=== File: packages/b_parsers/src/color/lch.ts ===
// b_path:: packages/b_parsers/src/color/lch.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, forwardParseErr, type ParseResult } from "@b/types";
import type { LCHColor } from "@b/types";
import { parseNodeToCssValue } from "../utils";
import { getChildren, getValues } from "@b/utils";

/**
 * Parse lch() function
 * @see https://drafts.csswg.org/css-color/#lch-colors
 */
export function parseLchFunction(node: csstree.FunctionNode): ParseResult<LCHColor> {
  if (node.name !== "lch") {
    return parseErr("lch", createError("invalid-syntax", "Expected lch() function"));
  }

  const values = getValues(getChildren(node));

  if (values.length < 3 || values.length > 4) {
    return parseErr("lch", createError("invalid-syntax", `LCH function must have 3 or 4 values, got ${values.length}`));
  }

  const lResult = parseNodeToCssValue(values[0]);
  if (!lResult.ok) return forwardParseErr<LCHColor>(lResult);

  const cResult = parseNodeToCssValue(values[1]);
  if (!cResult.ok) return forwardParseErr<LCHColor>(cResult);

  const hResult = parseNodeToCssValue(values[2]);
  if (!hResult.ok) return forwardParseErr<LCHColor>(hResult);

  const lch: LCHColor = {
    kind: "lch",
    l: lResult.value,
    c: cResult.value,
    h: hResult.value,
  };

  if (values.length === 4) {
    const alphaResult = parseNodeToCssValue(values[3]);
    if (!alphaResult.ok) return forwardParseErr<LCHColor>(alphaResult);
    lch.alpha = alphaResult.value;
  }

  return parseOk(lch);
}


=== File: packages/b_parsers/src/color/oklab.ts ===
// b_path:: packages/b_parsers/src/color/oklab.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, forwardParseErr, type ParseResult } from "@b/types";
import type { OKLabColor } from "@b/types";
import { parseNodeToCssValue } from "../utils";
import { getChildren, getValues } from "@b/utils";

/**
 * Parse oklab() function
 * @see https://drafts.csswg.org/css-color/#ok-lab
 */
export function parseOklabFunction(node: csstree.FunctionNode): ParseResult<OKLabColor> {
  if (node.name !== "oklab") {
    return parseErr("oklab", createError("invalid-syntax", "Expected oklab() function"));
  }

  const values = getValues(getChildren(node));

  if (values.length < 3 || values.length > 4) {
    return parseErr(
      "oklab",
      createError("invalid-syntax", `OKLab function must have 3 or 4 values, got ${values.length}`),
    );
  }

  const lResult = parseNodeToCssValue(values[0]);
  if (!lResult.ok) return forwardParseErr<OKLabColor>(lResult);

  const aResult = parseNodeToCssValue(values[1]);
  if (!aResult.ok) return forwardParseErr<OKLabColor>(aResult);

  const bResult = parseNodeToCssValue(values[2]);
  if (!bResult.ok) return forwardParseErr<OKLabColor>(bResult);

  const oklab: OKLabColor = {
    kind: "oklab",
    l: lResult.value,
    a: aResult.value,
    b: bResult.value,
  };

  if (values.length === 4) {
    const alphaResult = parseNodeToCssValue(values[3]);
    if (!alphaResult.ok) return forwardParseErr<OKLabColor>(alphaResult);
    oklab.alpha = alphaResult.value;
  }

  return parseOk(oklab);
}


=== File: packages/b_parsers/src/color/oklch.ts ===
// b_path:: packages/b_parsers/src/color/oklch.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, forwardParseErr, type ParseResult } from "@b/types";
import type { OKLCHColor } from "@b/types";
import { parseNodeToCssValue } from "../utils";
import { getChildren, getValues } from "@b/utils";

/**
 * Parse oklch() function
 * @see https://drafts.csswg.org/css-color/#ok-lch
 */
export function parseOklchFunction(node: csstree.FunctionNode): ParseResult<OKLCHColor> {
  if (node.name !== "oklch") {
    return parseErr("oklch", createError("invalid-syntax", "Expected oklch() function"));
  }

  const values = getValues(getChildren(node));

  if (values.length < 3 || values.length > 4) {
    return parseErr(
      "oklch",
      createError("invalid-syntax", `OKLCH function must have 3 or 4 values, got ${values.length}`),
    );
  }

  const lResult = parseNodeToCssValue(values[0]);
  if (!lResult.ok) return forwardParseErr<OKLCHColor>(lResult);

  const cResult = parseNodeToCssValue(values[1]);
  if (!cResult.ok) return forwardParseErr<OKLCHColor>(cResult);

  const hResult = parseNodeToCssValue(values[2]);
  if (!hResult.ok) return forwardParseErr<OKLCHColor>(hResult);

  const oklch: OKLCHColor = {
    kind: "oklch",
    l: lResult.value,
    c: cResult.value,
    h: hResult.value,
  };

  if (values.length === 4) {
    const alphaResult = parseNodeToCssValue(values[3]);
    if (!alphaResult.ok) return forwardParseErr<OKLCHColor>(alphaResult);
    oklch.alpha = alphaResult.value;
  }

  return parseOk(oklch);
}


=== File: packages/b_parsers/src/color/rgb.ts ===
// b_path:: packages/b_parsers/src/color/rgb.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, forwardParseErr, type ParseResult } from "@b/types";
import type { RGBColor } from "@b/types";
import { parseNodeToCssValue } from "../utils";
import { getChildren, getValues } from "@b/utils";

/**
 * Parse rgb() or rgba() function from css-tree AST.
 *
 * @see https://drafts.csswg.org/css-color/#rgb-functions
 */
export function parseRgbFunction(node: csstree.FunctionNode): ParseResult<RGBColor> {
  if (node.name !== "rgb" && node.name !== "rgba") {
    return parseErr("rgb", createError("invalid-syntax", "Expected rgb() or rgba() function"));
  }

  const values = getValues(getChildren(node));

  if (values.length < 3 || values.length > 4) {
    return parseErr("rgb", createError("invalid-syntax", `RGB function must have 3 or 4 values, got ${values.length}`));
  }

  const rResult = parseNodeToCssValue(values[0]);
  if (!rResult.ok) return forwardParseErr<RGBColor>(rResult);

  const gResult = parseNodeToCssValue(values[1]);
  if (!gResult.ok) return forwardParseErr<RGBColor>(gResult);

  const bResult = parseNodeToCssValue(values[2]);
  if (!bResult.ok) return forwardParseErr<RGBColor>(bResult);

  const rgb: RGBColor = {
    kind: "rgb",
    r: rResult.value,
    g: gResult.value,
    b: bResult.value,
  };

  if (values.length === 4) {
    const alphaResult = parseNodeToCssValue(values[3]);
    if (!alphaResult.ok) return forwardParseErr<RGBColor>(alphaResult);
    rgb.alpha = alphaResult.value;
  }

  return parseOk(rgb);
}


=== File: packages/b_parsers/src/gradient/color-stop.ts ===
// b_path:: packages/b_parsers/src/gradient/color-stop.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, type ParseResult } from "@b/types";
import type * as Type from "@b/types";
import { parseNodeToCssValue } from "../utils";
import * as Color from "../color";

/**
 * Parse color stop or color hint from CSS AST nodes.
 *
 * Color hint: A single length/percentage value representing the midpoint transition.
 * Color stop: A color value optionally followed by 1-2 position values.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient#color-stops
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient#color-hints
 */
export function fromNodes(nodes: csstree.CssNode[]): ParseResult<Type.ColorStopOrHint> {
  if (nodes.length === 0) {
    return parseErr("color-stops", createError("missing-value", "Color stop requires at least a color value"));
  }

  const firstNode = nodes[0];
  if (!firstNode) {
    return parseErr("color-stops", createError("missing-value", "Color stop requires at least a color value"));
  }

  // Try parsing as color first
  const colorResult = Color.parseNode(firstNode);

  // If it's not a color and we only have one node, it might be a color hint
  if (!colorResult.ok && nodes.length === 1) {
    // Try parsing as a length/percentage (color hint)
    const hintResult = parseNodeToCssValue(firstNode);
    if (hintResult.ok) {
      const hint = hintResult.value;
      // Validate that it's actually a length-percentage (not just any CSS value)
      // Color hints must be <length-percentage> per CSS spec
      if (
        (hint.kind === "literal" &&
          (hint.unit === "%" ||
            hint.unit === "px" ||
            hint.unit === "em" ||
            hint.unit === "rem" ||
            hint.unit === "vw" ||
            hint.unit === "vh" ||
            hint.unit === "vmin" ||
            hint.unit === "vmax")) ||
        hint.kind === "variable" ||
        hint.kind === "calc"
      ) {
        return parseOk({
          kind: "hint" as const,
          position: hint,
        });
      }
    }
    // Not a color or valid hint
    return parseErr(
      "color-stops",
      createError("invalid-value", `Invalid color value: ${colorResult.issues[0]?.message}`),
    );
  }

  // Must be a color stop
  if (!colorResult.ok) {
    return parseErr(
      "color-stops",
      createError("invalid-value", `Invalid color value: ${colorResult.issues[0]?.message}`),
    );
  }

  if (nodes.length === 1) {
    return parseOk({ color: colorResult.value });
  }

  // Parse position(s) as CssValue to support var/calc
  const positions: Type.CssValue[] = [];

  for (let i = 1; i < nodes.length; i++) {
    const posNode = nodes[i];
    if (!posNode) continue;

    const posResult = parseNodeToCssValue(posNode);
    if (posResult.ok) {
      positions.push(posResult.value);
    } else {
      return parseErr(
        "color-stops",
        createError("invalid-value", `Invalid color stop position: ${posResult.issues[0]?.message}`),
      );
    }
  }

  if (positions.length === 0) {
    return parseOk({ color: colorResult.value });
  }

  if (positions.length === 1) {
    return parseOk({
      color: colorResult.value,
      position: positions[0],
    });
  }

  if (positions.length === 2) {
    return parseOk({
      color: colorResult.value,
      position: [positions[0], positions[1]] as [Type.CssValue, Type.CssValue],
    });
  }

  return parseErr("color-stops", createError("invalid-value", "Color stop can have at most 2 positions"));
}


=== File: packages/b_parsers/src/gradient/conic.ts ===
// b_path:: packages/b_parsers/src/gradient/conic.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, forwardParseErr, type ParseResult } from "@b/types";
import type * as Type from "@b/types";
import { parseNodeToCssValue } from "../utils";
import { parsePosition2D } from "../position";
import * as ColorStop from "./color-stop";
import * as SharedParsing from "../utils/shared-parsing";
import * as Utils from "../utils";

/**
 * Parse conic gradient from CSS function AST with flexible component ordering.
 * Supports CSS spec: [ [ [ from <angle> ]? [ at <position> ]? ] || <color-interpolation-method> ]?
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient
 */
export function fromFunction(fn: csstree.FunctionNode): ParseResult<Type.ConicGradient> {
  const functionName = fn.name.toLowerCase();
  const isRepeating = functionName === "repeating-conic-gradient";

  if (!isRepeating && functionName !== "conic-gradient") {
    return parseErr(
      "conic-gradient",
      createError("invalid-value", `Expected conic-gradient or repeating-conic-gradient, got: ${functionName}`),
    );
  }

  const children = fn.children.toArray();
  if (children.length === 0) {
    return parseErr("conic-gradient", createError("missing-value", "conic-gradient requires at least 2 color stops"));
  }

  let fromAngle: Type.CssValue | undefined;
  let position: Type.Position2D | undefined;
  let colorInterpolationMethod: Type.ColorInterpolationMethod | undefined;

  let idx = 0;
  let hasFromAngle = false;
  let hasPosition = false;
  let hasInterpolation = false;

  // Flexible component parsing: accept components in any order
  while (idx < children.length) {
    const node = children[idx];
    if (!node) break;

    // Skip commas between components (backwards compatibility)
    if (node.type === "Operator" && node.value === ",") {
      idx++;
      continue;
    }

    // Recognize component by first token
    if (node.type === "Identifier") {
      const value = node.name.toLowerCase();

      // From angle: "from <angle>"
      if (value === "from") {
        if (hasFromAngle) {
          return parseErr("conic-gradient", createError("invalid-syntax", "Duplicate 'from' angle component"));
        }
        hasFromAngle = true;
        idx++;

        const angleNode = children[idx];
        if (
          !angleNode ||
          angleNode.type === "Operator" ||
          (angleNode.type === "Identifier" && ["at", "in", "from"].includes(angleNode.name.toLowerCase()))
        ) {
          return parseErr(
            "conic-gradient",
            createError("invalid-syntax", "conic-gradient 'from' keyword requires an angle value"),
          );
        }

        const angleResult = parseNodeToCssValue(angleNode);
        if (!angleResult.ok) {
          return forwardParseErr<Type.ConicGradient>(angleResult);
        }
        fromAngle = angleResult.value;
        idx++;
        continue;
      }

      // Position: "at <position>"
      if (value === "at") {
        if (hasPosition) {
          return parseErr("conic-gradient", createError("invalid-syntax", "Duplicate position component"));
        }
        hasPosition = true;
        idx++;

        const positionNodes: csstree.CssNode[] = [];
        while (idx < children.length) {
          const posNode = children[idx];
          if (!posNode) break;
          if (posNode.type === "Operator" && posNode.value === ",") break;
          if (posNode.type === "Identifier" && posNode.name.toLowerCase() === "at") break;
          if (posNode.type === "Identifier" && posNode.name.toLowerCase() === "in") break;
          if (posNode.type === "Identifier" && posNode.name.toLowerCase() === "from") break;

          positionNodes.push(posNode);
          idx++;
        }

        if (positionNodes.length === 0) {
          return parseErr(
            "conic-gradient",
            createError("invalid-syntax", "conic-gradient 'at' keyword requires position values"),
          );
        }
        const posResult = parsePosition2D(positionNodes, 0);
        if (!posResult.ok) {
          return forwardParseErr<Type.ConicGradient>(posResult);
        }
        position = posResult.value.position;
        continue;
      }

      // Color interpolation: "in <colorspace>"
      if (value === "in") {
        if (hasInterpolation) {
          return parseErr("conic-gradient", createError("invalid-syntax", "Duplicate color interpolation method"));
        }
        hasInterpolation = true;

        const interpolationResult = Utils.parseColorInterpolationMethod(children, idx);
        if (!interpolationResult) {
          return parseErr(
            "conic-gradient",
            createError("invalid-syntax", "conic-gradient 'in' keyword requires a color space"),
          );
        }
        colorInterpolationMethod = interpolationResult.method;
        idx = interpolationResult.nextIndex;
        continue;
      }

      // Could be a color stop (named color) - break to color stop parsing
      break;
    }

    // Function or Hash → color stop
    if (node.type === "Function" || node.type === "Hash") {
      break;
    }

    // Dimension, Number, Percentage → could be angle or color stop
    // If we have fromAngle already, it's likely a color stop
    if (node.type === "Dimension" || node.type === "Number" || node.type === "Percentage") {
      // Without 'from' keyword, dimensions are likely color stops
      break;
    }

    // Unknown token
    return parseErr("conic-gradient", createError("invalid-value", `Unexpected token in gradient: ${node.type}`));
  }

  // Parse color stops
  const stopGroups = Utils.Ast.splitNodesByComma(children, { startIndex: idx });

  const colorStops: Type.ColorStopOrHint[] = [];
  const issues: Type.Issue[] = [];

  for (const stopNodes of stopGroups) {
    const stopResult = ColorStop.fromNodes(stopNodes);
    if (stopResult.ok) {
      colorStops.push(stopResult.value);
    } else {
      issues.push(...stopResult.issues);
    }
  }

  if (issues.length > 0) {
    return {
      ok: false,
      value: {
        kind: "conic",
        fromAngle,
        position,
        colorInterpolationMethod,
        colorStops,
        repeating: isRepeating,
      },
      issues,
    };
  }

  if (colorStops.length < 2) {
    return parseErr("conic-gradient", createError("invalid-value", "conic-gradient requires at least 2 color stops"));
  }

  return parseOk({
    kind: "conic",
    fromAngle,
    position,
    colorInterpolationMethod,
    colorStops,
    repeating: isRepeating,
  });
}

/**
 * Parse a CSS conic gradient value into IR.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient
 */
export function parse(css: string): ParseResult<Type.ConicGradient> {
  const funcResult = SharedParsing.parseCssToGradientFunction(css, ["conic-gradient", "repeating-conic-gradient"]);
  if (!funcResult.ok) {
    return forwardParseErr<Type.ConicGradient>(funcResult);
  }

  const result = fromFunction(funcResult.value);

  // Add warning if parentheses are unbalanced
  const parenIssue = SharedParsing.validateParentheses(css, "conic");
  if (result.ok && parenIssue) {
    return {
      ...result,
      issues: [...result.issues, parenIssue],
    };
  }

  return result;
}


=== File: packages/b_parsers/src/gradient/gradient.ts ===
// b_path:: packages/b_parsers/src/gradient/gradient.ts
import type { ParseResult } from "@b/types";
import type * as Type from "@b/types";
import type * as csstree from "@eslint/css-tree";
import * as Radial from "./radial";
import * as Linear from "./linear";
import * as Conic from "./conic";
import { createError, parseErr } from "@b/types";

/**
 * Unified gradient parser that detects gradient type and dispatches to appropriate parser.
 *
 * Supports:
 * - linear-gradient() / repeating-linear-gradient()
 * - radial-gradient() / repeating-radial-gradient()
 * - conic-gradient() / repeating-conic-gradient()
 *
 * @param css - CSS gradient function string
 * @returns Parsed gradient IR
 */
export function parse(css: string): ParseResult<Type.Gradient> {
  const trimmed = css.trim();

  if (trimmed.startsWith("radial-gradient(") || trimmed.startsWith("repeating-radial-gradient(")) {
    return Radial.parse(css);
  }

  if (trimmed.startsWith("linear-gradient(") || trimmed.startsWith("repeating-linear-gradient(")) {
    return Linear.parse(css);
  }

  if (trimmed.startsWith("conic-gradient(") || trimmed.startsWith("repeating-conic-gradient(")) {
    return Conic.parse(css);
  }

  return {
    ok: false,
    issues: [
      {
        code: "invalid-value",
        severity: "error",
        message: `Expected gradient function (linear-gradient, radial-gradient, or conic-gradient), got: ${trimmed.slice(0, 50)}`,
      },
    ],
  };
}

/**
 * AST-native gradient parser from FunctionNode.
 *
 * Dispatches to appropriate gradient parser based on function name.
 * Part of AST-native architecture refactoring.
 *
 * @param node - css-tree FunctionNode representing gradient
 * @returns Parsed gradient IR
 */
export function parseFromNode(node: csstree.FunctionNode): ParseResult<Type.Gradient> {
  const funcName = node.name.toLowerCase();

  if (funcName.includes("radial")) {
    return Radial.fromFunction(node);
  }

  if (funcName.includes("linear")) {
    return Linear.fromFunction(node);
  }

  if (funcName.includes("conic")) {
    return Conic.fromFunction(node);
  }

  return parseErr("gradient", createError("unsupported-kind", `Not a gradient function: ${funcName}`));
}


=== File: packages/b_parsers/src/gradient/index.ts ===
// b_path:: packages/b_parsers/src/gradient/index.ts
export * as ColorStop from "./color-stop";
export * as Linear from "./linear";
export * as Radial from "./radial";
export * as Conic from "./conic";
export * from "./gradient";


=== File: packages/b_parsers/src/gradient/linear.ts ===
// b_path:: packages/b_parsers/src/gradient/linear.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, forwardParseErr, type ParseResult } from "@b/types";
import type * as Type from "@b/types";
import { parseNodeToCssValue } from "../utils";
import * as ColorStop from "./color-stop";
import * as SharedParsing from "../utils/shared-parsing";
import * as Utils from "../utils";
import { isCssValueFunction } from "../utils/css-value-functions";

/**
 * Parse gradient direction from nodes.
 */
function parseDirection(
  nodes: csstree.CssNode[],
  startIdx: number,
): ParseResult<{ direction: Type.GradientDirection; nextIdx: number }> {
  let idx = startIdx;
  const node = nodes[idx];

  if (!node) {
    return parseErr("linear-gradient", createError("missing-value", "Expected direction value"));
  }

  if (node.type === "Dimension" || node.type === "Number" || isCssValueFunction(node)) {
    const angleResult = parseNodeToCssValue(node);
    if (angleResult.ok) {
      return parseOk({
        direction: {
          kind: "angle",
          value: angleResult.value,
        },
        nextIdx: idx + 1,
      });
    }
  }

  if (node.type === "Identifier" && node.name.toLowerCase() === "to") {
    idx++;
    const firstKeyword = nodes[idx];
    if (!firstKeyword || firstKeyword.type !== "Identifier") {
      return parseErr("linear-gradient", createError("invalid-syntax", "Expected side or corner keyword after 'to'"));
    }

    const first = firstKeyword.name.toLowerCase();
    idx++;

    const secondKeyword = nodes[idx];
    if (secondKeyword && secondKeyword.type === "Identifier") {
      const second = secondKeyword.name.toLowerCase();
      const corner = `${first} ${second}`;
      if (["top left", "top right", "bottom left", "bottom right"].includes(corner)) {
        return parseOk({
          direction: {
            kind: "to-corner",
            value: corner as "top left" | "top right" | "bottom left" | "bottom right",
          },
          nextIdx: idx + 1,
        });
      }
    }

    if (["top", "right", "bottom", "left"].includes(first)) {
      return parseOk({
        direction: {
          kind: "to-side",
          value: first as "top" | "right" | "bottom" | "left",
        },
        nextIdx: idx,
      });
    }

    return parseErr("linear-gradient", createError("invalid-value", `Invalid direction keyword: ${first}`));
  }

  return parseErr("linear-gradient", createError("invalid-syntax", "Invalid direction syntax"));
}

/**
 * Parse linear gradient from CSS function AST with flexible component ordering.
 * Supports CSS spec: [ <linear-gradient-syntax> ]?
 * Where direction (angle/to-side/to-corner) and interpolation can appear in any order
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient
 */
export function fromFunction(fn: csstree.FunctionNode): ParseResult<Type.LinearGradient> {
  const functionName = fn.name.toLowerCase();
  const isRepeating = functionName === "repeating-linear-gradient";

  if (!isRepeating && functionName !== "linear-gradient") {
    return parseErr(
      "linear-gradient",
      createError("invalid-value", `Expected linear-gradient or repeating-linear-gradient, got: ${functionName}`),
    );
  }

  const children = fn.children.toArray();
  if (children.length === 0) {
    return parseErr("linear-gradient", createError("missing-value", "linear-gradient requires at least 2 color stops"));
  }

  let direction: Type.GradientDirection | undefined;
  let colorInterpolationMethod: Type.ColorInterpolationMethod | undefined;

  let idx = 0;
  let hasDirection = false;
  let hasInterpolation = false;

  // Flexible component parsing: accept direction and interpolation in any order
  while (idx < children.length) {
    const node = children[idx];
    if (!node) break;

    // Skip commas between components (backwards compatibility)
    if (node.type === "Operator" && node.value === ",") {
      idx++;
      continue;
    }

    // Recognize component by first token
    if (node.type === "Identifier") {
      const value = node.name.toLowerCase();

      // Color interpolation: "in <colorspace>"
      if (value === "in") {
        if (hasInterpolation) {
          return parseErr("linear-gradient", createError("invalid-syntax", "Duplicate color interpolation method"));
        }
        hasInterpolation = true;

        const interpolationResult = Utils.parseColorInterpolationMethod(children, idx);
        if (interpolationResult) {
          colorInterpolationMethod = interpolationResult.method;
          idx = interpolationResult.nextIndex;
        }
        continue;
      }

      // Direction: "to <side>" or "to <corner>"
      if (value === "to") {
        if (hasDirection) {
          return parseErr("linear-gradient", createError("invalid-syntax", "Duplicate direction component"));
        }

        const dirResult = parseDirection(children, idx);
        if (dirResult.ok) {
          hasDirection = true;
          direction = dirResult.value.direction;
          idx = dirResult.value.nextIdx;
          continue;
        }
        // If 'to' is present but the direction is invalid, it's a syntax error.
        // Do not fall back to parsing it as a color.
        return forwardParseErr<Type.LinearGradient>(dirResult);
      }

      // Could be a color stop (named color) - break to color stop parsing
      break;
    }

    // Dimension, Number → angle direction
    if (node.type === "Dimension" || node.type === "Number") {
      if (hasDirection) {
        // Could be a color stop position - break to color stop parsing
        break;
      }
      hasDirection = true;

      const dirResult = parseDirection(children, idx);
      if (dirResult.ok) {
        direction = dirResult.value.direction;
        idx = dirResult.value.nextIdx;
      } else {
        // Not a valid direction, might be color stop
        hasDirection = false;
        break;
      }
      continue;
    }

    // Function (calc/var) → could be angle direction, but be conservative
    if (isCssValueFunction(node)) {
      if (!hasDirection) {
        const funcName = node.type === "Function" ? node.name.toLowerCase() : "";

        // Special case for var(): it's ambiguous
        // Count total comma-separated groups to disambiguate:
        // - 2 groups: var(), var() → both are color stops
        // - 3+ groups: var(), color, color → first is direction
        if (funcName === "var") {
          const allGroups = Utils.Ast.splitNodesByComma(children, { startIndex: 0 });
          if (allGroups.length === 2) {
            // Only 2 items: must be 2 color stops
            break;
          }
        }

        // Try parsing as direction
        const dirResult = parseDirection(children, idx);
        if (dirResult.ok) {
          hasDirection = true;
          direction = dirResult.value.direction;
          idx = dirResult.value.nextIdx;
          continue;
        }
      }
      // Not a direction, must be color stop
      break;
    }

    // Function (color) or Hash → color stop
    if (node.type === "Function" || node.type === "Hash") {
      break;
    }

    // Unknown token
    return parseErr("linear-gradient", createError("invalid-value", `Unexpected token in gradient: ${node.type}`));
  }

  // Parse color stops
  const stopGroups = Utils.Ast.splitNodesByComma(children, { startIndex: idx });

  const colorStops: Type.ColorStopOrHint[] = [];
  const issues: Type.Issue[] = [];

  for (const stopNodes of stopGroups) {
    const stopResult = ColorStop.fromNodes(stopNodes);
    if (stopResult.ok) {
      colorStops.push(stopResult.value);
    } else {
      issues.push(...stopResult.issues);
    }
  }

  if (issues.length > 0) {
    return {
      ok: false,
      value: {
        kind: "linear",
        direction,
        colorInterpolationMethod,
        colorStops,
        repeating: isRepeating,
      },
      issues,
    };
  }

  if (colorStops.length < 2) {
    return parseErr("linear-gradient", createError("invalid-value", "linear-gradient requires at least 2 color stops"));
  }

  return parseOk({
    kind: "linear",
    direction,
    colorInterpolationMethod,
    colorStops,
    repeating: isRepeating,
  });
}

/**
 * Parse a CSS linear gradient value into IR.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient
 */
export function parse(css: string): ParseResult<Type.LinearGradient> {
  const funcResult = SharedParsing.parseCssToGradientFunction(css, ["linear-gradient", "repeating-linear-gradient"]);
  if (!funcResult.ok) {
    return forwardParseErr<Type.LinearGradient>(funcResult);
  }

  const result = fromFunction(funcResult.value);

  // Add warning if parentheses are unbalanced
  const parenIssue = SharedParsing.validateParentheses(css, "linear");
  if (result.ok && parenIssue) {
    return {
      ...result,
      issues: [...result.issues, parenIssue],
    };
  }

  return result;
}


=== File: packages/b_parsers/src/gradient/radial.ts ===
// b_path:: packages/b_parsers/src/gradient/radial.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, forwardParseErr, type ParseResult } from "@b/types";
import type * as Type from "@b/types";
import type { RadialShape, RadialSizeKeyword } from "@b/keywords";
import { parsePosition2D } from "../position";
import { parseNodeToCssValue } from "../utils";
import * as ColorStop from "./color-stop";
import * as SharedParsing from "../utils/shared-parsing";
import * as Utils from "../utils";
import { isCssValueFunction } from "../utils/css-value-functions";

/**
 * Parse radial gradient shape and size from nodes.
 */
function parseShapeAndSize(
  nodes: csstree.CssNode[],
  startIdx: number,
): ParseResult<{
  shape?: RadialShape;
  size?: Type.RadialGradientSize;
  nextIdx: number;
}> {
  let idx = startIdx;
  let shape: RadialShape | undefined;
  let size: Type.RadialGradientSize | undefined;

  const node = nodes[idx];
  if (!node) {
    return parseOk({ nextIdx: idx });
  }

  if (node.type === "Identifier") {
    const value = node.name.toLowerCase();

    if (value === "circle" || value === "ellipse") {
      shape = value as RadialShape;
      idx++;

      const nextNode = nodes[idx];
      if (nextNode?.type === "Identifier") {
        const sizeKeyword = nextNode.name.toLowerCase();
        if (["closest-side", "closest-corner", "farthest-side", "farthest-corner"].includes(sizeKeyword)) {
          size = {
            kind: "keyword",
            value: sizeKeyword as RadialSizeKeyword,
          };
          idx++;
        }
      } else if (
        nextNode &&
        (nextNode.type === "Dimension" || nextNode.type === "Percentage" || isCssValueFunction(nextNode))
      ) {
        if (shape === "circle") {
          const radiusResult = parseNodeToCssValue(nextNode);
          if (radiusResult.ok) {
            size = {
              kind: "circle-explicit",
              radius: radiusResult.value,
            };
            idx++;
          }
        } else {
          const rxResult = parseNodeToCssValue(nextNode);
          if (rxResult.ok) {
            idx++;
            const ryNode = nodes[idx];
            if (ryNode && (ryNode.type === "Dimension" || ryNode.type === "Percentage" || isCssValueFunction(ryNode))) {
              const ryResult = parseNodeToCssValue(ryNode);
              if (ryResult.ok) {
                size = {
                  kind: "ellipse-explicit",
                  radiusX: rxResult.value,
                  radiusY: ryResult.value,
                };
                idx++;
              }
            }
          }
        }
      }
    } else if (["closest-side", "closest-corner", "farthest-side", "farthest-corner"].includes(value)) {
      size = {
        kind: "keyword",
        value: value as RadialSizeKeyword,
      };
      idx++;

      const nextNode = nodes[idx];
      if (nextNode?.type === "Identifier") {
        const shapeValue = nextNode.name.toLowerCase();
        if (shapeValue === "circle" || shapeValue === "ellipse") {
          shape = shapeValue as RadialShape;
          idx++;
        }
      }
    }
  } else if (node.type === "Dimension" || node.type === "Percentage") {
    // Only parse bare dimensions/percentages as sizes, not functions
    // Functions as first node are likely colors (rgb, hsl, var, etc.)
    const firstResult = parseNodeToCssValue(node);
    if (firstResult.ok) {
      idx++;
      const secondNode = nodes[idx];

      if (
        secondNode &&
        (secondNode.type === "Dimension" || secondNode.type === "Percentage" || isCssValueFunction(secondNode))
      ) {
        const secondResult = parseNodeToCssValue(secondNode);
        if (secondResult.ok) {
          size = {
            kind: "ellipse-explicit",
            radiusX: firstResult.value,
            radiusY: secondResult.value,
          };
          idx++;

          // Check for shape after explicit ellipse size
          const shapeNode = nodes[idx];
          if (shapeNode?.type === "Identifier") {
            const shapeValue = shapeNode.name.toLowerCase();
            if (shapeValue === "circle" || shapeValue === "ellipse") {
              shape = shapeValue as RadialShape;
              idx++;
            }
          }
        }
      } else {
        size = {
          kind: "circle-explicit",
          radius: firstResult.value,
        };

        // Check for shape after explicit circle size
        const shapeNode = nodes[idx];
        if (shapeNode?.type === "Identifier") {
          const shapeValue = shapeNode.name.toLowerCase();
          if (shapeValue === "circle" || shapeValue === "ellipse") {
            shape = shapeValue as RadialShape;
            idx++;
          }
        }
      }
    }
  }

  return parseOk({ shape, size, nextIdx: idx });
}

/**
 * Parse radial gradient from CSS function AST with flexible component ordering.
 * Supports CSS spec: [ [ [ <radial-shape> || <radial-size> ]? [ at <position> ]? ] || <color-interpolation-method> ]?
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient
 */
export function fromFunction(fn: csstree.FunctionNode): ParseResult<Type.RadialGradient> {
  const functionName = fn.name.toLowerCase();
  const isRepeating = functionName === "repeating-radial-gradient";

  if (!isRepeating && functionName !== "radial-gradient") {
    return parseErr(
      "radial-gradient",
      createError("invalid-value", `Expected radial-gradient or repeating-radial-gradient, got: ${functionName}`),
    );
  }

  const children = fn.children.toArray();
  if (children.length === 0) {
    return parseErr("radial-gradient", createError("missing-value", "radial-gradient requires at least 2 color stops"));
  }

  let shape: RadialShape | undefined;
  let size: Type.RadialGradientSize | undefined;
  let position: Type.Position2D | undefined;
  let colorInterpolationMethod: Type.ColorInterpolationMethod | undefined;

  let idx = 0;
  let hasShape = false;
  let hasSize = false;
  let hasPosition = false;
  let hasInterpolation = false;

  // Flexible component parsing: accept components in any order
  while (idx < children.length) {
    const node = children[idx];
    if (!node) break;

    // Skip commas between components (backwards compatibility)
    if (node.type === "Operator" && node.value === ",") {
      idx++;
      continue;
    }

    // Recognize component by first token
    if (node.type === "Identifier") {
      const value = node.name.toLowerCase();

      // Position component: "at <position>"
      if (value === "at") {
        if (hasPosition) {
          return parseErr("radial-gradient", createError("invalid-syntax", "Duplicate position component"));
        }
        hasPosition = true;
        idx++;

        const positionNodes: csstree.CssNode[] = [];
        while (idx < children.length) {
          const posNode = children[idx];
          if (!posNode) break;
          if (posNode.type === "Operator" && posNode.value === ",") break;
          if (posNode.type === "Identifier" && posNode.name.toLowerCase() === "at") break;
          if (posNode.type === "Identifier" && posNode.name.toLowerCase() === "in") break;
          if (posNode.type === "Identifier" && ["circle", "ellipse"].includes(posNode.name.toLowerCase())) break;
          if (
            posNode.type === "Identifier" &&
            ["closest-side", "closest-corner", "farthest-side", "farthest-corner"].includes(posNode.name.toLowerCase())
          )
            break;

          positionNodes.push(posNode);
          idx++;
        }

        if (positionNodes.length > 0) {
          const posResult = parsePosition2D(positionNodes, 0);
          if (posResult.ok) {
            position = posResult.value.position;
          } else {
            return forwardParseErr<Type.RadialGradient>(posResult);
          }
        }
        continue;
      }

      // Color interpolation: "in <colorspace>"
      if (value === "in") {
        if (hasInterpolation) {
          return parseErr("radial-gradient", createError("invalid-syntax", "Duplicate color interpolation method"));
        }
        hasInterpolation = true;

        const interpolationResult = Utils.parseColorInterpolationMethod(children, idx);
        if (interpolationResult) {
          colorInterpolationMethod = interpolationResult.method;
          idx = interpolationResult.nextIndex;
        }
        continue;
      }

      // Shape: "circle" or "ellipse" - parse shape and potentially adjacent size
      if (value === "circle" || value === "ellipse") {
        if (hasShape || hasSize) {
          return parseErr("radial-gradient", createError("invalid-syntax", "Duplicate shape/size component"));
        }

        // Use the old parseShapeAndSize function which handles shape+size together
        const shapeAndSizeResult = parseShapeAndSize(children, idx);
        if (shapeAndSizeResult.ok) {
          shape = shapeAndSizeResult.value.shape;
          size = shapeAndSizeResult.value.size;
          // Mark both as parsed since they're a combined component
          hasShape = true;
          hasSize = true;
          idx = shapeAndSizeResult.value.nextIdx;
        } else {
          return forwardParseErr<Type.RadialGradient>(shapeAndSizeResult);
        }
        continue;
      }

      // Size keyword: "closest-side" etc. - parse size and potentially adjacent shape
      if (["closest-side", "closest-corner", "farthest-side", "farthest-corner"].includes(value)) {
        if (hasSize || hasShape) {
          return parseErr("radial-gradient", createError("invalid-syntax", "Duplicate shape/size component"));
        }

        // Use parseShapeAndSize starting from this size keyword
        const shapeAndSizeResult = parseShapeAndSize(children, idx);
        if (shapeAndSizeResult.ok) {
          shape = shapeAndSizeResult.value.shape;
          size = shapeAndSizeResult.value.size;
          // Mark both as parsed since they're a combined component
          hasShape = true;
          hasSize = true;
          idx = shapeAndSizeResult.value.nextIdx;
        } else {
          return forwardParseErr<Type.RadialGradient>(shapeAndSizeResult);
        }
        continue;
      }

      // Could be a color stop (named color) - break to color stop parsing
      break;
    }

    // Dimension or Percentage → explicit size - parse size and potentially adjacent shape
    if (node.type === "Dimension" || node.type === "Percentage") {
      if (hasSize || hasShape) {
        // Could be a color stop position - break to color stop parsing
        break;
      }

      // Use parseShapeAndSize starting from this dimension
      const shapeAndSizeResult = parseShapeAndSize(children, idx);
      if (shapeAndSizeResult.ok) {
        shape = shapeAndSizeResult.value.shape;
        size = shapeAndSizeResult.value.size;
        // Mark both as parsed since they're a combined component
        hasShape = true;
        hasSize = true;
        idx = shapeAndSizeResult.value.nextIdx;
      } else {
        // Not a valid size, might be color stop
        break;
      }
      continue;
    }

    // Function or Hash → color stop, break to color stop parsing
    if (node.type === "Function" || node.type === "Hash") {
      break;
    }

    // Unknown token
    return parseErr("radial-gradient", createError("invalid-value", `Unexpected token in gradient: ${node.type}`));
  }

  // Parse color stops
  const stopGroups = Utils.Ast.splitNodesByComma(children, { startIndex: idx });

  const colorStops: Type.ColorStopOrHint[] = [];
  const issues: Type.Issue[] = [];

  for (const stopNodes of stopGroups) {
    const stopResult = ColorStop.fromNodes(stopNodes);
    if (stopResult.ok) {
      colorStops.push(stopResult.value);
    } else {
      issues.push(...stopResult.issues);
    }
  }

  if (issues.length > 0) {
    return {
      ok: false,
      value: {
        kind: "radial",
        shape,
        size,
        position,
        colorInterpolationMethod,
        colorStops,
        repeating: isRepeating,
      },
      issues,
    };
  }

  if (colorStops.length < 2) {
    return parseErr("radial-gradient", createError("invalid-value", "radial-gradient requires at least 2 color stops"));
  }

  return parseOk({
    kind: "radial",
    shape,
    size,
    position,
    colorInterpolationMethod,
    colorStops,
    repeating: isRepeating,
  });
}

/**
 * Parse a CSS radial gradient value into IR.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient
 */
export function parse(css: string): ParseResult<Type.RadialGradient> {
  const funcResult = SharedParsing.parseCssToGradientFunction(css, ["radial-gradient", "repeating-radial-gradient"]);
  if (!funcResult.ok) {
    return forwardParseErr<Type.RadialGradient>(funcResult);
  }

  const result = fromFunction(funcResult.value);

  // Add warning if parentheses are unbalanced
  const parenIssue = SharedParsing.validateParentheses(css, "radial");
  if (result.ok && parenIssue) {
    return {
      ...result,
      issues: [...result.issues, parenIssue],
    };
  }

  return result;
}


=== File: packages/b_parsers/src/image/image.ts ===
// b_path:: packages/b_parsers/src/image/image.ts

import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, forwardParseErr, type ParseResult, type Image } from "@b/types";
import * as Ast from "@b/utils";
import * as Gradient from "../gradient";
import * as Url from "../url";

export function parse(valueNode: csstree.Value): ParseResult<Image> {
  if (!valueNode || !valueNode.children) {
    return parseErr("image", createError("invalid-value", "Invalid AST node: missing children"));
  }

  const children = Ast.nodeListToArray(valueNode.children);

  if (children.length === 0) {
    return parseErr("image", createError("missing-value", "Empty image value"));
  }

  const firstNode = children[0];

  // Handle "none" keyword
  if (Ast.isIdentifier(firstNode) && firstNode.name.toLowerCase() === "none") {
    return parseOk({ kind: "none" });
  }

  // Handle Url node (css-tree parses url() as Url type, not Function)
  if (firstNode.type === "Url") {
    return parseOk({
      kind: "url",
      url: firstNode.value,
    });
  }

  // Handle url() function (for completeness)
  if (Ast.isFunctionNode(firstNode, "url")) {
    const urlResult = Url.parseUrlFromNode(firstNode);

    if (urlResult.ok) {
      return parseOk({
        kind: "url",
        url: urlResult.value.value,
      });
    }
    return forwardParseErr<Image>(urlResult);
  }

  // Handle gradient functions
  if (Ast.isFunctionNode(firstNode)) {
    const funcName = (firstNode as csstree.FunctionNode).name.toLowerCase();

    if (funcName.includes("gradient")) {
      const gradientResult = Gradient.parseFromNode(firstNode);

      if (gradientResult.ok) {
        return parseOk({
          kind: "gradient",
          gradient: gradientResult.value,
        });
      }
      return forwardParseErr<Image>(gradientResult);
    }
  }

  return parseErr(
    "image",
    createError("invalid-value", "Unsupported image value", {
      suggestion: "Use url(), gradient, or 'none'",
    }),
  );
}


=== File: packages/b_parsers/src/image/index.ts ===
// b_path:: packages/b_parsers/src/image/index.ts
export * from "./image";


=== File: packages/b_parsers/src/index.ts ===
// b_path:: packages/b_parsers/src/index.ts
export * as Angle from "./angle";
export * as Background from "./background";
export * as BlendMode from "./blend-mode";
export * as Color from "./color";
export * as Gradient from "./gradient";
export * as Image from "./image";
export * as Length from "./length";
export * as Position from "./position";
export * as Url from "./url";
export * as Utils from "./utils";
export * as Math from "./math";


=== File: packages/b_parsers/src/length.ts ===
// b_path:: packages/b_parsers/src/length.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, type ParseResult } from "@b/types";
import type * as Type from "@b/types";
import * as Unit from "@b/units";

/**
 * Parse length AST node from css-tree.
 *
 * @see https://drafts.csswg.org/css-values-4/#lengths
 */
export function parseLengthNode(node: csstree.CssNode): ParseResult<Type.Length> {
  if (node.type !== "Dimension") {
    return parseErr(
      "length",
      createError("invalid-syntax", `Expected length dimension, but got node type ${node.type}`),
    );
  }

  const value = Number.parseFloat(node.value);
  if (Number.isNaN(value)) {
    return parseErr("length", createError("invalid-value", "Invalid length value: not a number"));
  }

  const allLengthUnits = [...Unit.ABSOLUTE_LENGTH_UNITS, ...Unit.FONT_LENGTH_UNITS, ...Unit.VIEWPORT_LENGTH_UNITS];

  if (!allLengthUnits.includes(node.unit as (typeof allLengthUnits)[number])) {
    return parseErr("length", createError("invalid-value", `Invalid length unit: '${node.unit}'`));
  }

  return parseOk({
    value,
    unit: node.unit as (typeof allLengthUnits)[number],
  });
}

/**
 * Parse length or percentage AST node from css-tree.
 *
 * @see https://drafts.csswg.org/css-values-4/#percentage-value
 */
export function parseLengthPercentageNode(node: csstree.CssNode): ParseResult<Type.LengthPercentage> {
  if (node.type === "Number") {
    const val = Number.parseFloat(node.value);
    if (val !== 0) {
      return parseErr("length", createError("invalid-value", "Unitless values must be zero"));
    }
    return parseOk({ value: 0, unit: "px" });
  }

  if (node.type === "Dimension") {
    const value = Number.parseFloat(node.value);
    if (Number.isNaN(value)) {
      return parseErr("length", createError("invalid-value", "Invalid length value: not a number"));
    }

    const allLengthUnits = [...Unit.ABSOLUTE_LENGTH_UNITS, ...Unit.FONT_LENGTH_UNITS, ...Unit.VIEWPORT_LENGTH_UNITS];

    if (!allLengthUnits.includes(node.unit as (typeof allLengthUnits)[number])) {
      return parseErr("length", createError("invalid-value", `Invalid length unit: '${node.unit}'`));
    }

    return parseOk({
      value,
      unit: node.unit as (typeof allLengthUnits)[number],
    });
  }

  if (node.type === "Percentage") {
    const value = Number.parseFloat(node.value);
    if (Number.isNaN(value)) {
      return parseErr("length", createError("invalid-value", "Invalid percentage value: not a number"));
    }
    return parseOk({ value, unit: Unit.PERCENTAGE_UNIT });
  }

  return parseErr(
    "length",
    createError("invalid-syntax", `Expected length or percentage, but got node type ${node.type}`),
  );
}

/**
 * Parse number AST node from css-tree.
 *
 * @see https://drafts.csswg.org/css-values-4/#numbers
 */
export function parseNumberNode(node: csstree.CssNode): ParseResult<number> {
  if (node.type !== "Number") {
    return parseErr("length", createError("invalid-syntax", `Expected number, but got node type ${node.type}`));
  }

  const value = Number.parseFloat(node.value);
  if (Number.isNaN(value)) {
    return parseErr("length", createError("invalid-value", "Invalid number value: not a number"));
  }

  return parseOk(value);
}


=== File: packages/b_parsers/src/math/calc.ts ===
// b_path:: packages/b_parsers/src/math/calc.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, type ParseResult, type CssValue, type Issue } from "@b/types";
import { parseNodeToCssValue } from "../utils";

type Operator = "+" | "-" | "*" | "/";
type InfixToken = CssValue | Operator;

const PRECEDENCE: Record<Operator, number> = {
  "+": 1,
  "-": 1,
  "*": 2,
  "/": 2,
};

/**
 * Parses a `calc()` expression from AST nodes into a valid expression tree.
 *
 * This implementation uses the Shunting-yard algorithm to correctly handle
 * CSS operator precedence (multiplication/division before addition/subtraction).
 *
 * The process involves three main steps:
 * 1. **Tokenization:** Convert css-tree nodes into an infix list of `CssValue` and `Operator` tokens.
 * 2. **Shunting-yard:** Convert the infix token list to a postfix (Reverse Polish Notation) list.
 * 3. **Tree Building:** Build the final `calc-operation` tree from the postfix list.
 *
 * @param nodes - Array of expression nodes inside `calc()`
 * @returns Result containing the root `CssValue` of the expression tree.
 */
function parseCalcExpression(nodes: csstree.CssNode[]): ParseResult<CssValue> {
  const issues: Issue[] = [];

  // --- Step 1: Tokenize into an Infix expression array ---
  const infix: InfixToken[] = [];
  const expressionNodes = nodes.filter((n) => n.type !== "WhiteSpace");

  for (const node of expressionNodes) {
    if (node.type === "Operator") {
      const op = node.value.trim() as Operator;
      if (PRECEDENCE[op] !== undefined) {
        infix.push(op);
      } else {
        issues.push(createError("invalid-syntax", `Unsupported operator in calc(): ${op}`));
      }
    } else {
      const operandResult = parseNodeToCssValue(node);
      if (operandResult.ok) {
        infix.push(operandResult.value);
        issues.push(...operandResult.issues);
      } else {
        issues.push(...operandResult.issues);
        // If an operand fails to parse, we can't continue building the tree.
        return parseErr("calc", createError("invalid-value", "Invalid operand in calculation"));
      }
    }
  }

  // --- Step 2: Shunting-yard algorithm (Infix to Postfix/RPN) ---
  const postfix: InfixToken[] = [];
  const operatorStack: Operator[] = [];

  for (const token of infix) {
    if (typeof token === "object") {
      // Token is a CssValue (operand)
      postfix.push(token);
    } else {
      // Token is an Operator
      const op1 = token;
      while (operatorStack.length > 0 && PRECEDENCE[operatorStack[operatorStack.length - 1]] >= PRECEDENCE[op1]) {
        postfix.push(operatorStack.pop()!);
      }
      operatorStack.push(op1);
    }
  }

  while (operatorStack.length > 0) {
    postfix.push(operatorStack.pop()!);
  }

  // --- Step 3: Build Expression Tree from Postfix (RPN) ---
  const buildStack: CssValue[] = [];

  for (const token of postfix) {
    if (typeof token === "object") {
      // Token is a CssValue (operand)
      buildStack.push(token);
    } else {
      // Token is an Operator
      if (buildStack.length < 2) {
        return parseErr(
          "calc",
          createError("invalid-syntax", `Malformed calc expression: missing operands for operator '${token}'`),
        );
      }
      const right = buildStack.pop()!;
      const left = buildStack.pop()!;
      buildStack.push({
        kind: "calc-operation",
        operator: token,
        left,
        right,
      });
    }
  }

  if (buildStack.length !== 1) {
    return parseErr("calc", createError("invalid-syntax", "Malformed calc expression: too many values."));
  }

  const resultTree = buildStack[0];
  const finalResult: ParseResult<CssValue> = parseOk(resultTree, "calc");

  if (issues.length > 0) {
    finalResult.issues.push(...issues);
  }

  return finalResult;
}

/**
 * Parse calc() function from CSS function AST.
 *
 * @see https://drafts.csswg.org/css-values-4/#calc-func
 */
export function parseCalcFunction(node: csstree.FunctionNode): ParseResult<{ kind: "calc"; value: CssValue }> {
  const funcName = node.name.toLowerCase();

  if (funcName !== "calc") {
    return parseErr("calc", createError("invalid-syntax", "Expected calc() function"));
  }

  const expressionNodes = node.children.toArray();

  if (expressionNodes.length === 0) {
    return parseErr("calc", createError("invalid-syntax", "calc() expression must not be empty"));
  }

  const expressionResult = parseCalcExpression(expressionNodes);

  if (expressionResult.ok) {
    return parseOk({
      kind: "calc",
      value: expressionResult.value,
    });
  }

  // Partial IR on error
  return {
    ok: false,
    value: expressionResult.value ? { kind: "calc", value: expressionResult.value } : undefined,
    issues: expressionResult.issues,
    property: "calc",
  };
}


=== File: packages/b_parsers/src/math/clamp.ts ===
// b_path:: packages/b_parsers/src/math/clamp.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, type ParseResult, type CssValue } from "@b/types";
import { parseNodeToCssValue } from "../utils";
import { splitNodesByComma } from "../utils/ast";

/**
 * Parses clamp() function from CSS AST.
 *
 * @see https://drafts.csswg.org/css-values-4/#funcdef-clamp
 */
export function parseClampFunction(
  node: csstree.FunctionNode,
): ParseResult<{ kind: "clamp"; min: CssValue; preferred: CssValue; max: CssValue }> {
  if (node.name.toLowerCase() !== "clamp") {
    return parseErr("clamp", createError("invalid-syntax", "Expected clamp() function"));
  }

  const children = node.children.toArray();
  const groups = splitNodesByComma(children, { trimWhitespace: true });

  if (groups.length !== 3) {
    return parseErr(
      "clamp",
      createError("invalid-syntax", "clamp() requires exactly three arguments: min, preferred, max"),
    );
  }

  const args: CssValue[] = [];
  const issues: ReturnType<typeof createError>[] = [];

  // Parse min, preferred, max arguments
  for (let i = 0; i < 3; i++) {
    const group = groups[i];

    if (group.length !== 1 || !group[0]) {
      issues.push(createError("invalid-syntax", `clamp() argument ${i + 1} must be a single value`));
      // Push placeholder to maintain structure
      args.push({ kind: "keyword", value: "invalid" });
      continue;
    }

    const result = parseNodeToCssValue(group[0]);

    if (result.ok) {
      args.push(result.value);
      issues.push(...result.issues);
    } else {
      issues.push(...result.issues);
      // Preserve partial IR if available
      args.push(result.value || { kind: "keyword", value: "error" });
    }
  }

  if (args.length !== 3) {
    return parseErr("clamp", createError("invalid-value", "Failed to parse all three arguments for clamp()"));
  }

  const [min, preferred, max] = args;

  const finalIR = {
    kind: "clamp" as const,
    min,
    preferred,
    max,
  };

  if (issues.some((i) => i.severity === "error")) {
    return {
      ok: false,
      value: finalIR,
      issues,
      property: "clamp",
    };
  }

  return parseOk(finalIR);
}


=== File: packages/b_parsers/src/math/index.ts ===
// b_path:: packages/b_parsers/src/math/index.ts
export * from "./calc";
export * from "./minmax";
export * from "./clamp";


=== File: packages/b_parsers/src/math/minmax.ts ===
// b_path:: packages/b_parsers/src/math/minmax.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, type ParseResult, type CssValue } from "@b/types";
import { parseNodeToCssValue } from "../utils";
import { splitNodesByComma } from "../utils/ast";

/**
 * Parses min() or max() function from CSS AST.
 *
 * @see https://drafts.csswg.org/css-values-4/#funcdef-min
 * @see https://drafts.csswg.org/css-values-4/#funcdef-max
 */
export function parseMinmaxFunction(
  node: csstree.FunctionNode,
): ParseResult<{ kind: "min" | "max"; values: CssValue[] }> {
  const funcName = node.name.toLowerCase();

  if (funcName !== "min" && funcName !== "max") {
    return parseErr("minmax", createError("invalid-syntax", "Expected min() or max() function"));
  }

  const children = node.children.toArray();
  const groups = splitNodesByComma(children, { trimWhitespace: true });

  if (groups.length < 2) {
    return parseErr("minmax", createError("invalid-syntax", `${funcName}() requires at least two arguments`));
  }

  const values: CssValue[] = [];
  const issues: ReturnType<typeof createError>[] = [];

  // Parse each argument recursively
  for (const group of groups) {
    if (group.length === 0) continue;

    // Handle single-node arguments
    if (group.length === 1) {
      const result = parseNodeToCssValue(group[0]);

      if (result.ok) {
        values.push(result.value);
        issues.push(...result.issues);
      } else {
        issues.push(...result.issues);
        // Preserve partial IR if available
        if (result.value) {
          values.push(result.value);
        }
      }
    } else {
      // Multiple nodes in group (unexpected for simple arguments)
      issues.push(createError("invalid-syntax", `Unexpected multiple nodes in ${funcName}() argument`));

      // Try parsing first node anyway
      const result = parseNodeToCssValue(group[0]);
      if (result.value) {
        values.push(result.value);
      }
    }
  }

  const finalIR = {
    kind: funcName as "min" | "max",
    values,
  };

  if (issues.some((i) => i.severity === "error")) {
    return {
      ok: false,
      value: finalIR,
      issues,
      property: funcName,
    };
  }

  return parseOk(finalIR);
}


=== File: packages/b_parsers/src/position.ts ===
// b_path:: packages/b_parsers/src/position.ts
import type * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, type ParseResult } from "@b/types";
import type * as Type from "@b/types";
import { parseNodeToCssValue } from "./utils";

/**
 * Parse 2D position from array of AST nodes.
 * Supports 1, 2, 3, and 4-value position syntax.
 *
 * @see https://drafts.csswg.org/css-backgrounds-3/#typedef-bg-position
 */
export function parsePosition2D(
  nodes: csstree.CssNode[],
  startIdx: number,
): ParseResult<{ position: Type.Position2D; nextIdx: number }> {
  let idx = startIdx;

  if (idx >= nodes.length) {
    return parseErr("position", createError("invalid-syntax", "Expected position value"));
  }

  // Collect all position values
  const positionValues: Type.CssValue[] = [];
  while (idx < nodes.length && nodes[idx]?.type !== "Operator") {
    const node = nodes[idx];
    if (!node) break;

    const value = parseNodeToCssValue(node);
    if (!value.ok) break;

    positionValues.push(value.value);
    idx++;
  }

  if (positionValues.length === 0) {
    return parseErr("position", createError("invalid-syntax", "Expected position value"));
  }

  // Parse based on number of values
  const result = parsePositionValues(positionValues);
  if (!result.ok) {
    return parseErr("position", result.issues[0] ?? createError("invalid-syntax", "Failed to parse position"));
  }

  return parseOk({ position: result.value, nextIdx: idx });
}

/**
 * Parse position values based on count (1, 2, 3, or 4 values)
 */
function parsePositionValues(values: Type.CssValue[]): ParseResult<Type.Position2D> {
  switch (values.length) {
    case 1:
      return parse1Value(values);
    case 2:
      return parse2Value(values);
    case 3:
      return parse3Value(values);
    case 4:
      return parse4Value(values);
    default:
      return parseErr("position", createError("invalid-syntax", `Invalid position syntax: ${values.length} values`));
  }
}

/**
 * Parse 1-value syntax: center | left | top | 50%
 */
function parse1Value(values: Type.CssValue[]): ParseResult<Type.Position2D> {
  const val = values[0];
  if (!val) return parseErr("position", createError("invalid-syntax", "Missing position value"));

  // Handle axis-specific keywords
  if (val.kind === "keyword") {
    if (val.value === "top" || val.value === "bottom") {
      return parseOk({
        horizontal: { kind: "keyword", value: "center" },
        vertical: val,
      });
    }
    if (val.value === "left" || val.value === "right") {
      return parseOk({
        horizontal: val,
        vertical: { kind: "keyword", value: "center" },
      });
    }
    // center
    return parseOk({
      horizontal: val,
      vertical: { kind: "keyword", value: "center" },
    });
  }

  // Assume horizontal
  return parseOk({
    horizontal: val,
    vertical: { kind: "keyword", value: "center" },
  });
}

/**
 * Parse 2-value syntax: left top | 50% 75%
 */
function parse2Value(values: Type.CssValue[]): ParseResult<Type.Position2D> {
  const h = values[0];
  const v = values[1];
  if (!h || !v) return parseErr("position", createError("invalid-syntax", "Missing position values"));

  return parseOk({ horizontal: h, vertical: v });
}

/**
 * Parse 3-value syntax: left 15% top | center top 20px | right 10% center
 */
function parse3Value(values: Type.CssValue[]): ParseResult<Type.Position2D> {
  const v0 = values[0];
  const v1 = values[1];
  const v2 = values[2];
  if (!v0 || !v1 || !v2) return parseErr("position", createError("invalid-syntax", "Missing position values"));

  // Pattern 1: [edge] [offset] [keyword/edge]
  const edge1 = getEdgeKeyword(v0);
  if (edge1) {
    // First pair is edge+offset
    const isHorizontal1 = edge1 === "left" || edge1 === "right";

    // Check if v2 is also an edge
    const edge2 = getEdgeKeyword(v2);
    if (edge2) {
      const isHorizontal2 = edge2 === "left" || edge2 === "right";
      if (isHorizontal1 === isHorizontal2) {
        return parseErr("position", createError("invalid-syntax", "Both edges on same axis"));
      }
    }

    // v2 can be any keyword (edge or center)
    if (isHorizontal1) {
      return parseOk({
        horizontal: { edge: edge1, offset: v1 },
        vertical: v2,
      });
    }
    return parseOk({
      horizontal: v2,
      vertical: { edge: edge1, offset: v1 },
    });
  }

  // Pattern 2: [keyword] [edge] [offset] - e.g., center top 20px
  const edge2Alt = getEdgeKeyword(v1);
  if (edge2Alt) {
    const isHorizontal = edge2Alt === "left" || edge2Alt === "right";
    if (isHorizontal) {
      return parseOk({
        horizontal: { edge: edge2Alt, offset: v2 },
        vertical: v0,
      });
    }
    return parseOk({
      horizontal: v0,
      vertical: { edge: edge2Alt, offset: v2 },
    });
  }

  return parseErr("position", createError("invalid-syntax", "Invalid 3-value position syntax"));
}

/**
 * Parse 4-value syntax: left 15% top 20px
 */
function parse4Value(values: Type.CssValue[]): ParseResult<Type.Position2D> {
  const v0 = values[0];
  const v1 = values[1];
  const v2 = values[2];
  const v3 = values[3];
  if (!v0 || !v1 || !v2 || !v3) {
    return parseErr("position", createError("invalid-syntax", "Missing position values"));
  }

  // Pattern: [edge] [offset] [edge] [offset]
  const edge1 = getEdgeKeyword(v0);
  const edge2 = getEdgeKeyword(v2);

  if (!edge1 || !edge2) {
    return parseErr("position", createError("invalid-syntax", "Expected edge keywords at positions 1 and 3"));
  }

  // Determine which pair is horizontal vs vertical
  const isHorizontal1 = edge1 === "left" || edge1 === "right";
  const isHorizontal2 = edge2 === "left" || edge2 === "right";

  if (isHorizontal1 === isHorizontal2) {
    return parseErr("position", createError("invalid-syntax", "Both pairs on same axis"));
  }

  if (isHorizontal1) {
    return parseOk({
      horizontal: { edge: edge1, offset: v1 },
      vertical: { edge: edge2, offset: v3 },
    });
  }
  return parseOk({
    horizontal: { edge: edge2, offset: v3 },
    vertical: { edge: edge1, offset: v1 },
  });
}

/**
 * Get edge keyword from a CssValue, or undefined if not an edge keyword
 */
function getEdgeKeyword(value: Type.CssValue): "left" | "right" | "top" | "bottom" | undefined {
  if (value.kind === "keyword") {
    const kw = value.value;
    if (kw === "left" || kw === "right" || kw === "top" || kw === "bottom") {
      return kw;
    }
  }
  return undefined;
}


=== File: packages/b_parsers/src/url.ts ===
// b_path:: packages/b_parsers/src/url.ts
import { createError, parseErr, parseOk, type ParseResult } from "@b/types";
import type { Url } from "@b/types";
import type * as csstree from "@eslint/css-tree";

/**
 * Parse a CSS url() function.
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/url
 *
 * @example
 * ```ts
 * parseUrl("url(image.png)")
 * parseUrl('url("image.png")')
 * parseUrl("url('image.png')")
 * ```
 */
export function parseUrl(input: string): ParseResult<Url> {
  const trimmed = input.trim();

  // Must start with url(
  if (!trimmed.startsWith("url(")) {
    return parseErr("url", createError("invalid-syntax", `Expected url() function, got: ${input}`));
  }

  // Must end with )
  if (!trimmed.endsWith(")")) {
    return parseErr(
      "url",
      createError("invalid-syntax", `Invalid url() function: missing closing parenthesis in "${input}"`),
    );
  }

  // Extract content between url( and )
  const content = trimmed.slice(4, -1).trim();

  // Handle quoted strings
  const quotedMatch = content.match(/^(['"])(.*)\1$/);
  if (quotedMatch) {
    return parseOk({
      kind: "url",
      value: quotedMatch[2],
    });
  }

  // Handle unquoted URL
  if (content) {
    return parseOk({
      kind: "url",
      value: content,
    });
  }

  return parseErr("url", createError("invalid-syntax", `Empty url() function in "${input}"`));
}

/**
 * Parse a CSS url() function from AST node.
 * AST-native version for improved performance and error locations.
 *
 * @param node - FunctionNode representing url()
 * @returns Parsed URL IR
 */
export function parseUrlFromNode(node: csstree.FunctionNode): ParseResult<Url> {
  if (node.name.toLowerCase() !== "url") {
    return parseErr("url", createError("invalid-syntax", `Expected url() function, got: ${node.name}()`));
  }

  const children = node.children.toArray();

  // url() should have exactly one child (the URL string or identifier)
  if (children.length === 0) {
    return parseErr("url", createError("invalid-syntax", "Empty url() function"));
  }

  if (children.length > 1) {
    return parseErr("url", createError("invalid-syntax", "url() function should have exactly one argument"));
  }

  const child = children[0];

  // Handle string literals (quoted)
  if (child.type === "String") {
    return parseOk({
      kind: "url",
      value: child.value,
    });
  }

  // Handle raw URL (identifier or url token)
  if (child.type === "Url") {
    return parseOk({
      kind: "url",
      value: child.value,
    });
  }

  // Handle identifier (unquoted URL)
  if (child.type === "Identifier") {
    return parseOk({
      kind: "url",
      value: child.name,
    });
  }

  // Unexpected child type
  return parseErr("url", createError("invalid-syntax", `Unexpected content in url() function: ${child.type}`));
}


=== File: packages/b_parsers/src/utils/ast/functions.ts ===
// b_path:: packages/b_parsers/src/utils/ast/functions.ts
import * as csstree from "@eslint/css-tree";
import { createError, parseErr, parseOk, type ParseResult } from "@b/types";

/**
 * Find a function node by name in a CSS AST.
 *
 * Walks the AST to find the first function node with the specified name.
 * Function name matching is case-insensitive to match CSS spec behavior.
 *
 * @param ast - CSS AST to search
 * @param functionNames - Function name(s) to search for (case-insensitive)
 * @returns Result containing FunctionNode or error message
 *
 * @example
 * ```typescript
 * const result = findFunctionNode(ast, ["linear-gradient", "repeating-linear-gradient"]);
 * if (result.ok) {
 *   console.log(result.value.name); // "linear-gradient"
 * }
 * ```
 */
export function findFunctionNode(
  ast: csstree.CssNode,
  functionNames: string | string[],
): ParseResult<csstree.FunctionNode> {
  const names = Array.isArray(functionNames) ? functionNames : [functionNames];
  const lowerNames = names.map((name) => name.toLowerCase());
  let foundNode: csstree.FunctionNode | null = null;

  try {
    csstree.walk(ast, {
      visit: "Function",
      enter(node: csstree.CssNode) {
        if (node.type === "Function" && lowerNames.includes(node.name.toLowerCase())) {
          foundNode = node;
        }
      },
    });

    if (!foundNode) {
      return parseErr(
        "function-node",
        createError("missing-value", `No function found with name(s): ${names.join(", ")}`),
      );
    }

    return parseOk(foundNode);
  } catch (e) {
    return parseErr(
      "css-ast",
      createError("invalid-syntax", `Failed to search AST: ${e instanceof Error ? e.message : String(e)}`),
    );
  }
}

/**
 * Parse CSS string into AST with error handling.
 *
 * @param css - CSS string to parse
 * @param context - CSS parsing context ("value", "declaration", etc.)
 * @returns Result containing CSS AST or error message
 *
 * @example
 * ```typescript
 * const result = parseCssString("linear-gradient(red, blue)", "value");
 * if (result.ok) {
 *   // Work with AST
 * }
 * ```
 */
export function parseCssString(css: string, context: "value" | "declaration" = "value"): ParseResult<csstree.CssNode> {
  try {
    const ast = csstree.parse(css, { context });
    return parseOk(ast);
  } catch (e) {
    return parseErr(
      "css-ast",
      createError("invalid-syntax", `Failed to parse CSS: ${e instanceof Error ? e.message : String(e)}`),
    );
  }
}


=== File: packages/b_parsers/src/utils/ast/index.ts ===
// b_path:: packages/b_parsers/src/utils/ast/index.ts
export * from "./functions";
export * from "./split-by-comma";


=== File: packages/b_parsers/src/utils/ast/split-by-comma.ts ===
// b_path:: packages/b_parsers/src/utils/ast/split-by-comma.ts
import type * as csstree from "@eslint/css-tree";

export interface SplitByCommaOptions {
  /** Start index in nodes array (default: 0) */
  startIndex?: number;
  /** Allow empty groups between commas (default: false) */
  allowEmpty?: boolean;
  /** Skip whitespace nodes (default: true) */
  trimWhitespace?: boolean;
}

/**
 * Split array of AST nodes by comma operators.
 *
 * Used for parsing comma-separated function arguments.
 * Returns array of node groups, where each group is the nodes between commas.
 *
 * **Important:** Only splits on top-level commas, ignoring commas inside nested functions.
 *
 * @param nodes - Array of AST nodes to split
 * @param options - Parsing options
 * @returns Array of node groups (each group is nodes between commas)
 *
 * @example
 * ```typescript
 * // For linear-gradient(45deg, red, blue 50%, green)
 * // After parsing direction, start from index 2
 * const groups = splitNodesByComma(children, { startIndex: 2 });
 * // Returns: [[red], [blue, 50%], [green]]
 * ```
 */
export function splitNodesByComma(nodes: csstree.CssNode[], options: SplitByCommaOptions = {}): csstree.CssNode[][] {
  const { startIndex = 0, allowEmpty = false, trimWhitespace = true } = options;

  const groups: csstree.CssNode[][] = [];
  let currentGroup: csstree.CssNode[] = [];

  for (let i = startIndex; i < nodes.length; i++) {
    const node = nodes[i];
    if (!node) continue;

    if (trimWhitespace && node.type === "WhiteSpace") {
      continue;
    }

    // Track nesting depth - enter function
    if (node.type === "Function") {
      currentGroup.push(node);
      // Functions contain their own children, no need to track depth here
      // The function node itself contains all nested content
      continue;
    }

    // Only split on top-level commas (when not inside a function)
    if (node.type === "Operator" && "value" in node && node.value === ",") {
      if (currentGroup.length > 0 || allowEmpty) {
        groups.push(currentGroup);
        currentGroup = [];
      }
    } else {
      currentGroup.push(node);
    }
  }

  if (currentGroup.length > 0 || allowEmpty) {
    groups.push(currentGroup);
  }

  return groups;
}

/**
 * Check if a comma exists at the given index.
 *
 * @param nodes - Array of AST nodes
 * @param index - Index to check
 * @returns True if node at index is a comma operator
 */
export function isCommaAt(nodes: csstree.CssNode[], index: number): boolean {
  const node = nodes[index];
  return Boolean(node && node.type === "Operator" && "value" in node && node.value === ",");
}

/**
 * Skip comma at index if present, return next index.
 *
 * @param nodes - Array of AST nodes
 * @param index - Current index
 * @returns Index after comma if present, otherwise same index
 *
 * @example
 * ```typescript
 * let idx = 5;
 * idx = skipComma(children, idx); // Skips comma if at index 5
 * ```
 */
export function skipComma(nodes: csstree.CssNode[], index: number): number {
  return isCommaAt(nodes, index) ? index + 1 : index;
}


=== File: packages/b_parsers/src/utils/color-interpolation.ts ===
// b_path:: packages/b_parsers/src/utils/color-interpolation.ts
import type * as csstree from "@eslint/css-tree";
import type { ColorInterpolationMethod } from "@b/types";
import type { HueInterpolationMethod } from "@b/keywords";

// Hue method keywords (not valid color spaces)
const HUE_METHOD_KEYWORDS = ["longer", "shorter", "increasing", "decreasing"];

/**
 * Parse color interpolation method from gradient nodes.
 *
 * Handles syntax: `in <color-space> [<hue-interpolation-method>]`
 *
 * @example
 * // "in hsl"
 * // "in hsl longer hue"
 * // "in oklch shorter hue"
 *
 * @param nodes - Array of CSS AST nodes
 * @param startIndex - Index to start parsing from (should point to "in" keyword)
 * @returns Color interpolation method and next index, or undefined if not found
 */
export function parseColorInterpolationMethod(
  nodes: csstree.CssNode[],
  startIndex: number,
): { method: ColorInterpolationMethod; nextIndex: number } | undefined {
  let idx = startIndex;
  const node = nodes[idx];

  // Must start with "in" keyword
  if (!node || node.type !== "Identifier" || node.name.toLowerCase() !== "in") {
    return undefined;
  }

  idx++;
  const spaceNode = nodes[idx];

  // Must have color space identifier
  if (!spaceNode || spaceNode.type !== "Identifier") {
    return undefined;
  }

  const space = spaceNode.name.toLowerCase();

  // Reject hue method keywords as color spaces
  if (HUE_METHOD_KEYWORDS.includes(space)) {
    return undefined;
  }

  let method: ColorInterpolationMethod = { colorSpace: space } as ColorInterpolationMethod;
  idx++;

  // Optional: hue interpolation method (e.g., "longer hue", "shorter hue")
  const hueNode = nodes[idx];
  if (hueNode?.type === "Identifier") {
    const hueWord1 = hueNode.name.toLowerCase();

    if (hueWord1 === "longer" || hueWord1 === "shorter" || hueWord1 === "increasing" || hueWord1 === "decreasing") {
      idx++;
      const hueNode2 = nodes[idx];

      if (hueNode2?.type === "Identifier" && hueNode2.name.toLowerCase() === "hue") {
        method = {
          colorSpace: space,
          hueInterpolationMethod: `${hueWord1} hue` as HueInterpolationMethod,
        } as ColorInterpolationMethod;
        idx++;
      }
    }
  }

  return { method, nextIndex: idx };
}


=== File: packages/b_parsers/src/utils/css-value-functions.ts ===
// b_path:: packages/b_parsers/src/utils/css-value-functions.ts
import type * as csstree from "@eslint/css-tree";

/**
 * Check if a Function node is a CSS value function (var, calc, clamp, min, max)
 * and not a color function (rgb, hsl, hwb, lab, lch, oklch, oklab, etc.)
 *
 * This is useful for distinguishing between:
 * - CSS value functions that can appear in size/position contexts
 * - Color functions that should be treated as color stops
 *
 * @example
 * isCssValueFunction(varNode) // true - var(--value)
 * isCssValueFunction(calcNode) // true - calc(50% + 10px)
 * isCssValueFunction(rgbNode) // false - rgb(255, 0, 0)
 * isCssValueFunction(hslNode) // false - hsl(0, 100%, 50%)
 */
export function isCssValueFunction(node: csstree.CssNode): boolean {
  if (node.type !== "Function") return false;
  const funcName = node.name.toLowerCase();
  return ["var", "calc", "clamp", "min", "max"].includes(funcName);
}


=== File: packages/b_parsers/src/utils/css-value-parser.ts ===
// b_path:: packages/b_parsers/src/utils/css-value-parser.ts
import type * as csstree from "@eslint/css-tree";
import { forwardParseErr, type ParseResult, type CssValue } from "@b/types";
import { parseCssValueNode } from "@b/utils";
import { parseComplexFunction } from "./function-dispatcher";

/**
 * CSS value parser with full complex function support.
 *
 * ✅ **USE THIS** for property parsing.
 *
 * This is the correct entry point for parsing CSS values in property parsers.
 * It handles all CSS functions including:
 * - Gradients: linear-gradient(), radial-gradient(), conic-gradient()
 * - Colors: rgb(), hsl(), lab(), lch(), oklch(), oklab(), color()
 * - Math: calc(), min(), max(), clamp()
 * - Plus all basic values: numbers, dimensions, percentages, keywords, var()
 *
 * Implementation:
 * - Function nodes → Try complex function dispatcher first
 * - Fallback → Basic parser from @b/utils for primitives
 *
 * @param node - CSS AST node to parse
 * @returns ParseResult with CssValue (may include complex function IRs)
 *
 * @example
 * ```typescript
 * // In property parser:
 * import { parseNodeToCssValue } from "@b/parsers";
 *
 * const result = parseNodeToCssValue(node);
 * if (result.ok && result.value.kind === "gradient") {
 *   // Gradient IR available
 * }
 * ```
 */
export function parseNodeToCssValue(node: csstree.CssNode): ParseResult<CssValue> {
  // For function nodes, try the complex function dispatcher first
  if (node.type === "Function") {
    const complexResult = parseComplexFunction(node);
    if (complexResult) {
      if (complexResult.ok) {
        return complexResult;
      }
      // The complex parser encountered an error while parsing
      return forwardParseErr<CssValue>(complexResult);
    }
  }

  // Fall back to basic parser for primitives and unknown functions
  return parseCssValueNode(node);
}


=== File: packages/b_parsers/src/utils/function-dispatcher.ts ===
// b_path:: packages/b_parsers/src/utils/function-dispatcher.ts
import type * as csstree from "@eslint/css-tree";
import type { ParseResult, CssValue } from "@b/types";
import * as Color from "../color";
import * as MathFunctions from "../math";

/**
 * Central function dispatcher for complex CSS functions.
 *
 * Maps function names to their specialized parsers.
 * This prevents duplication and ensures consistent routing.
 *
 * NOTE: var() and generic functions are NOT handled here - they're
 * handled inline in parseCssValueNode due to their generic nature.
 */

type FunctionParser = (node: csstree.FunctionNode) => ParseResult<CssValue>;

const PARSER_MAP: Record<string, FunctionParser> = {
  // Math functions
  calc: MathFunctions.parseCalcFunction as FunctionParser,
  min: MathFunctions.parseMinmaxFunction as FunctionParser,
  max: MathFunctions.parseMinmaxFunction as FunctionParser,
  clamp: MathFunctions.parseClampFunction as FunctionParser,

  // Color space functions
  rgb: Color.parseRgbFunction as FunctionParser,
  rgba: Color.parseRgbFunction as FunctionParser,
  hsl: Color.parseHslFunction as FunctionParser,
  hsla: Color.parseHslFunction as FunctionParser,
  hwb: Color.parseHwbFunction as FunctionParser,
  lab: Color.parseLabFunction as FunctionParser,
  lch: Color.parseLchFunction as FunctionParser,
  oklab: Color.parseOklabFunction as FunctionParser,
  oklch: Color.parseOklchFunction as FunctionParser,
};

/**
 * Delegates parsing of a Function AST node to the appropriate specialized parser.
 *
 * Returns null if the function is not recognized (caller should handle as generic function).
 *
 * @param node - CSS Function node
 * @returns ParseResult for known functions, null for unknown functions
 */
export function parseComplexFunction(node: csstree.FunctionNode): ParseResult<CssValue> | null {
  const funcName = node.name.toLowerCase();
  const parser = PARSER_MAP[funcName];

  if (parser) {
    return parser(node);
  }

  return null; // Not a recognized complex function
}


=== File: packages/b_parsers/src/utils/index.ts ===
// b_path:: packages/b_parsers/src/utils/index.ts
export * as Ast from "./ast";
export * from "./color-interpolation";
export * from "./css-value-functions";
export * from "./function-dispatcher";
export * from "./css-value-parser";
export * from "./shared-parsing";


=== File: packages/b_parsers/src/utils/shared-parsing.ts ===
// b_path:: packages/b_parsers/src/utils/shared-parsing.ts
import type * as csstree from "@eslint/css-tree";
import { createWarning, parseOk, type ParseResult, forwardParseErr } from "@b/types";
import type * as Type from "@b/types";
import * as Utils from ".";

/**
 * Parse color interpolation method from "in" keyword.
 *
 * Looks for "in <color-space> [<hue-method>]" pattern.
 *
 * @returns Result with method and next index, or forwards parse error
 */
// export function parseColorInterpolationMethod(
//   children: csstree.CssNode[],
//   idx: number,
// ): ParseResult<{ method: Type.ColorInterpolationMethod | undefined; nextIdx: number }> {
//   const inNode = children[idx];
//   if (inNode?.type === "Identifier" && inNode.name.toLowerCase() === "in") {
//     const interpolationResult = Utils.parseColorInterpolationMethod(children, idx);
//     if (!interpolationResult) {
//       return parseOk({ method: undefined, nextIdx: idx });
//     }
//     return parseOk({
//       method: interpolationResult.method,
//       nextIdx: interpolationResult.nextIndex,
//     });
//   }

//   return parseOk({ method: undefined, nextIdx: idx });
// }

/**
 * Parse CSS string to gradient function node.
 *
 * Validates CSS syntax and finds the gradient function.
 *
 * @param css - CSS gradient string
 * @param gradientNames - Function names to look for (e.g., ["linear-gradient", "repeating-linear-gradient"])
 * @returns Result with function node
 */
export function parseCssToGradientFunction(css: string, gradientNames: string[]): ParseResult<csstree.FunctionNode> {
  const astResult = Utils.Ast.parseCssString(css, "value");
  if (!astResult.ok) {
    return forwardParseErr<csstree.FunctionNode>(astResult);
  }

  const funcResult = Utils.Ast.findFunctionNode(astResult.value, gradientNames);
  if (!funcResult.ok) {
    return forwardParseErr<csstree.FunctionNode>(funcResult);
  }

  return parseOk(funcResult.value);
}

/**
 * Validate parentheses are balanced in CSS string.
 *
 * Returns a warning issue if unbalanced, undefined if balanced.
 *
 * @param css - CSS gradient string
 * @param gradientType - Type name for warning message
 * @returns Warning issue or undefined
 */
export function validateParentheses(css: string, gradientType: string): Type.Issue | undefined {
  const openCount = (css.match(/\(/g) || []).length;
  const closeCount = (css.match(/\)/g) || []).length;

  if (openCount !== closeCount) {
    return createWarning("invalid-syntax", `Unbalanced parentheses in ${gradientType}-gradient`, {
      property: "gradient",
      suggestion: "Check that all parentheses are properly closed",
    });
  }

  return undefined;
}


=== File: packages/b_parsers/tsup.config.ts ===
// b_path:: packages/b_parsers/tsup.config.ts
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/index.ts"],
  format: ["cjs", "esm"],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
  treeshake: true,
});


=== File: packages/b_parsers/vite.config.ts ===
// b_path:: packages/b_parsers/vite.config.ts
import { defineConfig } from "vite";

import tsconfigPaths from "vite-tsconfig-paths";

// https://vite.dev/config/
export default defineConfig({
  plugins: [tsconfigPaths()],
});


=== File: packages/b_types/src/angle.ts ===
// b_path:: packages/b_types/src/angle.ts
import { z } from "zod";
import { angleUnitSchema } from "@b/units";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/angle
 */
export const angleSchema = z
  .object({
    value: z.number(),
    unit: angleUnitSchema.optional(),
  })
  .strict();

export type Angle = z.infer<typeof angleSchema>;


=== File: packages/b_types/src/bg-size.ts ===
// b_path:: packages/b_types/src/bg-size.ts

import { z } from "zod";
import { cssValueSchema } from "./values/css-value";
import * as Keywords from "@b/keywords";

/**
 * Represents a single <bg-size> component value.
 * Used by background-size and mask-size.
 * Syntax: [ <length-percentage> | auto ]{1,2} | cover | contain
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/background-size
 */
export const bgSizeSchema = z.discriminatedUnion("kind", [
  // Handles 'cover' and 'contain'
  z.object({
    kind: z.literal("keyword"),
    value: Keywords.bgSize,
  }),
  // Handles 1-value syntax ('auto', '50%') and 2-value syntax ('50% auto')
  z.object({
    kind: z.literal("explicit"),
    // The width and height are just CssValues! This allows for literals,
    // keywords ('auto'), var(), and calc() all for free.
    width: cssValueSchema,
    height: cssValueSchema,
  }),
]);

export type BgSize = z.infer<typeof bgSizeSchema>;


=== File: packages/b_types/src/color-interpolation-method.ts ===
// b_path:: packages/b_types/src/color-interpolation-method.ts
import { z } from "zod";
import * as Keywords from "@b/keywords";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color-interpolation-method
 */
export const colorInterpolationMethodSchema = z.union([
  z
    .object({
      colorSpace: Keywords.rectangularColorSpace,
    })
    .strict(),
  z
    .object({
      colorSpace: Keywords.polarColorSpace,
      hueInterpolationMethod: Keywords.hueInterpolationMethod.optional(),
    })
    .strict(),
]);

export type ColorInterpolationMethod = z.infer<typeof colorInterpolationMethodSchema>;


=== File: packages/b_types/src/color-stop.ts ===
// b_path:: packages/b_types/src/color-stop.ts
import { z } from "zod";
import { cssValueSchema } from "./values";
import { colorSchema } from "./color";

/**
 * Color hint (transition midpoint) between color stops.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient#color-hints
 */
export const colorHintSchema = z
  .object({
    kind: z.literal("hint"),
    position: cssValueSchema, // length-percentage
  })
  .strict();

export type ColorHint = z.infer<typeof colorHintSchema>;

/**
 * Color stop in a gradient.
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient#color-stops
 */
export const colorStopSchema = z
  .object({
    kind: z.literal("stop").optional(), // Optional for backward compatibility
    color: colorSchema,
    position: z
      .union([
        cssValueSchema, // Single position (length/percentage/angle or var/calc)
        z.tuple([cssValueSchema, cssValueSchema]), // Two positions
      ])
      .optional(),
  })
  .strict();

export type ColorStop = z.infer<typeof colorStopSchema>;

/**
 * Color stop or hint in a gradient.
 */
export const colorStopOrHintSchema = z.union([colorStopSchema, colorHintSchema]);

export type ColorStopOrHint = z.infer<typeof colorStopOrHintSchema>;

export const colorStopListSchema = z.array(colorStopOrHintSchema).min(2);

export type ColorStopList = z.infer<typeof colorStopListSchema>;


=== File: packages/b_types/src/color/color-function.ts ===
// b_path:: packages/b_types/src/color/color-function.ts
import { z } from "zod";
import { cssValueSchema } from "../values";

/**
 * color() function representation using CssValue for flexible value types
 * Supports literals, variables (var()), keywords (none), and relative color syntax
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/color
 */
export const colorFunctionSchema = z
  .object({
    kind: z.literal("color"),
    colorSpace: z.enum([
      "srgb",
      "srgb-linear",
      "display-p3",
      "a98-rgb",
      "prophoto-rgb",
      "rec2020",
      "xyz",
      "xyz-d50",
      "xyz-d65",
    ]),
    channels: z.tuple([cssValueSchema, cssValueSchema, cssValueSchema]),
    alpha: cssValueSchema.optional(),
  })
  .strict();

export type ColorFunction = z.infer<typeof colorFunctionSchema>;


=== File: packages/b_types/src/color/color.ts ===
// b_path:: packages/b_types/src/color/color.ts
import { z } from "zod";
import { hexColorSchema } from "./hex";
import { namedColorSchema } from "./named";
import { rgbColorSchema } from "./rgb";
import { hslColorSchema } from "./hsl";
import { hwbColorSchema } from "./hwb";
import { labColorSchema } from "./lab";
import { lchColorSchema } from "./lch";
import { oklabColorSchema } from "./oklab";
import { oklchColorSchema } from "./oklch";
import { specialColorSchema } from "./special";
import { colorFunctionSchema } from "./color-function";
import { variableReferenceSchema } from "../values/css-value";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value
 */
export const colorSchema = z.union([
  hexColorSchema,
  namedColorSchema,
  rgbColorSchema,
  hslColorSchema,
  hwbColorSchema,
  labColorSchema,
  lchColorSchema,
  oklabColorSchema,
  oklchColorSchema,
  specialColorSchema,
  colorFunctionSchema,
  variableReferenceSchema,
]);

export type Color = z.infer<typeof colorSchema>;


=== File: packages/b_types/src/color/hex.ts ===
// b_path:: packages/b_types/src/color/hex.ts
import { z } from "zod";

/**
 * Hex color schema supporting 3, 4, 6, and 8 digit formats (case-insensitive).
 * - #rgb (3 digits)
 * - #rgba (4 digits)
 * - #rrggbb (6 digits)
 * - #rrggbbaa (8 digits)
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/hex-color
 */
export const hexColorSchema = z
  .object({
    kind: z.literal("hex"),
    value: z.string().regex(/^#([0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/i),
  })
  .strict();

export type HexColor = z.infer<typeof hexColorSchema>;


=== File: packages/b_types/src/color/hsl.ts ===
// b_path:: packages/b_types/src/color/hsl.ts
import { z } from "zod";
import { cssValueSchema } from "../values";

/**
 * HSL color representation using CssValue for flexible value types
 * Supports literals, variables (var()), keywords (none), and relative color syntax
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hsl
 */
export const hslColorSchema = z
  .object({
    kind: z.literal("hsl"),
    h: cssValueSchema,
    s: cssValueSchema,
    l: cssValueSchema,
    alpha: cssValueSchema.optional(),
  })
  .strict();

export type HSLColor = z.infer<typeof hslColorSchema>;


=== File: packages/b_types/src/color/hwb.ts ===
// b_path:: packages/b_types/src/color/hwb.ts
import { z } from "zod";
import { cssValueSchema } from "../values";

/**
 * HWB color representation using CssValue for flexible value types
 * Supports literals, variables (var()), keywords (none), and relative color syntax
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hwb
 */
export const hwbColorSchema = z
  .object({
    kind: z.literal("hwb"),
    h: cssValueSchema,
    w: cssValueSchema,
    b: cssValueSchema,
    alpha: cssValueSchema.optional(),
  })
  .strict();

export type HWBColor = z.infer<typeof hwbColorSchema>;


=== File: packages/b_types/src/color/index.ts ===
// b_path:: packages/b_types/src/color/index.ts
export * from "./color-function";
export * from "./color";
export * from "./hex";
export * from "./hsl";
export * from "./hwb";
export * from "./lab";
export * from "./lch";
export * from "./named";
export * from "./oklab";
export * from "./oklch";
export * from "./rgb";
export * from "./special";


=== File: packages/b_types/src/color/lab.ts ===
// b_path:: packages/b_types/src/color/lab.ts
import { z } from "zod";
import { cssValueSchema } from "../values";

/**
 * LAB color representation using CssValue for flexible value types
 * Supports literals, variables (var()), keywords (none), and relative color syntax
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/lab
 */
export const labColorSchema = z
  .object({
    kind: z.literal("lab"),
    l: cssValueSchema,
    a: cssValueSchema,
    b: cssValueSchema,
    alpha: cssValueSchema.optional(),
  })
  .strict();

export type LABColor = z.infer<typeof labColorSchema>;


=== File: packages/b_types/src/color/lch.ts ===
// b_path:: packages/b_types/src/color/lch.ts
import { z } from "zod";
import { cssValueSchema } from "../values";

/**
 * LCH color representation using CssValue for flexible value types
 * Supports literals, variables (var()), keywords (none), and relative color syntax
 * @see https://drafts.csswg.org/css-color/#lch-colors
 */
export const lchColorSchema = z
  .object({
    kind: z.literal("lch"),
    l: cssValueSchema,
    c: cssValueSchema,
    h: cssValueSchema,
    alpha: cssValueSchema.optional(),
  })
  .strict();

export type LCHColor = z.infer<typeof lchColorSchema>;


=== File: packages/b_types/src/color/named.ts ===
// b_path:: packages/b_types/src/color/named.ts
import { z } from "zod";
import * as Keywords from "@b/keywords";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/named-color
 */
export const namedColorSchema = z
  .object({
    kind: z.literal("named"),
    name: Keywords.namedColor,
  })
  .strict();

export type NamedColor = z.infer<typeof namedColorSchema>;


=== File: packages/b_types/src/color/oklab.ts ===
// b_path:: packages/b_types/src/color/oklab.ts
import { z } from "zod";
import { cssValueSchema } from "../values";

/**
 * OKLab color representation using CssValue for flexible value types
 * Supports literals, variables (var()), keywords (none), and relative color syntax
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/oklab
 */
export const oklabColorSchema = z
  .object({
    kind: z.literal("oklab"),
    l: cssValueSchema,
    a: cssValueSchema,
    b: cssValueSchema,
    alpha: cssValueSchema.optional(),
  })
  .strict();

export type OKLabColor = z.infer<typeof oklabColorSchema>;


=== File: packages/b_types/src/color/oklch.ts ===
// b_path:: packages/b_types/src/color/oklch.ts
import { z } from "zod";
import { cssValueSchema } from "../values";

/**
 * OKLCH color representation using CssValue for flexible value types
 * Supports literals, variables (var()), keywords (none), and relative color syntax
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/oklch
 */
export const oklchColorSchema = z
  .object({
    kind: z.literal("oklch"),
    l: cssValueSchema,
    c: cssValueSchema,
    h: cssValueSchema,
    alpha: cssValueSchema.optional(),
  })
  .strict();

export type OKLCHColor = z.infer<typeof oklchColorSchema>;


=== File: packages/b_types/src/color/rgb.ts ===
// b_path:: packages/b_types/src/color/rgb.ts
import { z } from "zod";
import { cssValueSchema } from "../values";

/**
 * RGB color representation using CssValue for flexible value types
 * Supports literals, variables (var()), keywords (none), and relative color syntax
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/rgb
 */
export const rgbColorSchema = z
  .object({
    kind: z.literal("rgb"),
    r: cssValueSchema,
    g: cssValueSchema,
    b: cssValueSchema,
    alpha: cssValueSchema.optional(),
  })
  .strict();

export type RGBColor = z.infer<typeof rgbColorSchema>;


=== File: packages/b_types/src/color/special.ts ===
// b_path:: packages/b_types/src/color/special.ts
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#special_values
 */
export const specialColorSchema = z
  .object({
    kind: z.literal("special"),
    keyword: z.enum(["transparent", "currentcolor"]),
  })
  .strict();

export type SpecialColor = z.infer<typeof specialColorSchema>;


=== File: packages/b_types/src/gradient/conic.ts ===
// b_path:: packages/b_types/src/gradient/conic.ts
import { z } from "zod";
import { cssValueSchema } from "../values";
import { colorStopListSchema } from "../color-stop";
import { colorInterpolationMethodSchema } from "../color-interpolation-method";
import { position2DSchema } from "../position";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/conic-gradient
 */
export const conicGradientSchema = z
  .object({
    kind: z.literal("conic"),
    fromAngle: cssValueSchema.optional(), // Changed from angleSchema to support var/calc
    position: position2DSchema.optional(),
    colorInterpolationMethod: colorInterpolationMethodSchema.optional(),
    colorStops: colorStopListSchema,
    repeating: z.boolean(),
  })
  .strict();

export type ConicGradient = z.infer<typeof conicGradientSchema>;


=== File: packages/b_types/src/gradient/direction.ts ===
// b_path:: packages/b_types/src/gradient/direction.ts
import { z } from "zod";
import * as Keywords from "@b/keywords";
import { cssValueSchema } from "../values";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient
 */
export const gradientDirectionSchema = z.union([
  z
    .object({
      kind: z.literal("angle"),
      value: cssValueSchema, // Changed from angleSchema to support var/calc
    })
    .strict(),
  z
    .object({
      kind: z.literal("to-side"),
      value: Keywords.gradientSide,
    })
    .strict(),
  z
    .object({
      kind: z.literal("to-corner"),
      value: Keywords.gradientCorner,
    })
    .strict(),
]);

export type GradientDirection = z.infer<typeof gradientDirectionSchema>;


=== File: packages/b_types/src/gradient/index.ts ===
// b_path:: packages/b_types/src/gradient/index.ts
export * from "./conic";
export * from "./direction";
export * from "./linear";
export * from "./radial";
export * from "./radial-size";

import { z } from "zod";
import { conicGradientSchema } from "./conic";
import { linearGradientSchema } from "./linear";
import { radialGradientSchema } from "./radial";

export const gradientSchema = z.union([linearGradientSchema, radialGradientSchema, conicGradientSchema]);

export type Gradient = z.infer<typeof gradientSchema>;


=== File: packages/b_types/src/gradient/linear.ts ===
// b_path:: packages/b_types/src/gradient/linear.ts
import { z } from "zod";
import { colorStopListSchema } from "../color-stop";
import { colorInterpolationMethodSchema } from "../color-interpolation-method";
import { gradientDirectionSchema } from "./direction";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/linear-gradient
 */
export const linearGradientSchema = z
  .object({
    kind: z.literal("linear"),
    direction: gradientDirectionSchema.optional(),
    colorInterpolationMethod: colorInterpolationMethodSchema.optional(),
    colorStops: colorStopListSchema,
    repeating: z.boolean(),
  })
  .strict();

export type LinearGradient = z.infer<typeof linearGradientSchema>;


=== File: packages/b_types/src/gradient/radial-size.ts ===
// b_path:: packages/b_types/src/gradient/radial-size.ts
import { z } from "zod";
import * as Keywords from "@b/keywords";
import { cssValueSchema } from "../values";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient
 */
export const radialGradientSizeSchema = z.union([
  z
    .object({
      kind: z.literal("keyword"),
      value: Keywords.radialSizeKeyword,
    })
    .strict(),
  z
    .object({
      kind: z.literal("circle-explicit"),
      radius: cssValueSchema,
    })
    .strict(),
  z
    .object({
      kind: z.literal("ellipse-explicit"),
      radiusX: cssValueSchema,
      radiusY: cssValueSchema,
    })
    .strict(),
]);

export type RadialGradientSize = z.infer<typeof radialGradientSizeSchema>;


=== File: packages/b_types/src/gradient/radial.ts ===
// b_path:: packages/b_types/src/gradient/radial.ts
import { z } from "zod";
import * as Keywords from "@b/keywords";
import { colorStopListSchema } from "../color-stop";
import { colorInterpolationMethodSchema } from "../color-interpolation-method";
import { position2DSchema } from "../position";
import { radialGradientSizeSchema } from "./radial-size";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/gradient/radial-gradient
 */
export const radialGradientSchema = z
  .object({
    kind: z.literal("radial"),
    shape: Keywords.radialShape.optional(),
    size: radialGradientSizeSchema.optional(),
    position: position2DSchema.optional(),
    colorInterpolationMethod: colorInterpolationMethodSchema.optional(),
    colorStops: colorStopListSchema,
    repeating: z.boolean(),
  })
  .strict();

export type RadialGradient = z.infer<typeof radialGradientSchema>;


=== File: packages/b_types/src/image.ts ===
// b_path:: packages/b_types/src/image.ts

import { z } from "zod";
import type { Gradient } from "./gradient";

/**
 * Represents a CSS <image> value.
 *
 * CSS Spec: <image> = <url> | <gradient> | <image()> | <image-set()> | <cross-fade()> | <element()> | none
 *
 * Currently supported:
 * - <url> - url() function
 * - <gradient> - All gradient types (linear, radial, conic, repeating)
 * - "none" - No image (valid per CSS spec for background-image)
 *
 * Not yet supported (future):
 * - <image()> - image() function with fallbacks
 * - <image-set()> - Responsive images
 * - <cross-fade()> - Image blending
 * - <element()> - Reference to DOM element
 *
 * @see https://www.w3.org/TR/css-images-3/#image-values
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/image
 */
export const imageSchema = z.discriminatedUnion("kind", [
  z
    .object({
      kind: z.literal("url"),
      url: z.string(),
    })
    .strict(),
  z
    .object({
      kind: z.literal("gradient"),
      gradient: z.lazy(() => z.any()) as z.ZodType<Gradient>,
    })
    .strict(),
  z
    .object({
      kind: z.literal("none"),
    })
    .strict(),
]);

export type Image = z.infer<typeof imageSchema>;


=== File: packages/b_types/src/index.ts ===
// b_path:: packages/b_types/src/index.ts
/**
 * b_types - Zod schemas and Result system
 *
 * @packageDocumentation
 */

export * from "./result";
export * from "./values";
export * from "./color";
export * from "./angle";
export * from "./length";
export * from "./percentage";
export * from "./length-percentage";
export * from "./position";
export * from "./url";
export * from "./image";
export * from "./repeat-style";
export * from "./color-stop";
export * from "./color-interpolation-method";
export * from "./gradient";
export * from "./bg-size";


=== File: packages/b_types/src/length-percentage.ts ===
// b_path:: packages/b_types/src/length-percentage.ts
import { z } from "zod";
import { lengthSchema } from "./length";
import { percentageSchema } from "./percentage";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/length-percentage
 */
export const lengthPercentageSchema = z.union([lengthSchema, percentageSchema]);

export type LengthPercentage = z.infer<typeof lengthPercentageSchema>;


=== File: packages/b_types/src/length.ts ===
// b_path:: packages/b_types/src/length.ts
import { z } from "zod";
import { lengthUnitSchema } from "@b/units";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/length
 */
export const lengthSchema = z
  .object({
    value: z.number(),
    unit: lengthUnitSchema,
  })
  .strict();

export type Length = z.infer<typeof lengthSchema>;


=== File: packages/b_types/src/percentage.ts ===
// b_path:: packages/b_types/src/percentage.ts
import { z } from "zod";
import { percentageUnitSchema } from "@b/units";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/percentage
 */
export const percentageSchema = z
  .object({
    value: z.number(),
    unit: percentageUnitSchema,
  })
  .strict();

export type Percentage = z.infer<typeof percentageSchema>;


=== File: packages/b_types/src/position.ts ===
// b_path:: packages/b_types/src/position.ts
import { z } from "zod";
import { cssValueSchema } from "./values";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/position_value
 */

// Edge offset for 3/4-value position syntax
export const positionEdgeOffsetSchema = z
  .object({
    edge: z.enum(["left", "right", "top", "bottom"]),
    offset: cssValueSchema,
  })
  .strict();

export type PositionEdgeOffset = z.infer<typeof positionEdgeOffsetSchema>;

// Position can be simple value or edge+offset
export const position2DSchema = z
  .object({
    horizontal: z.union([cssValueSchema, positionEdgeOffsetSchema]),
    vertical: z.union([cssValueSchema, positionEdgeOffsetSchema]),
  })
  .strict();

export type Position2D = z.infer<typeof position2DSchema>;


=== File: packages/b_types/src/repeat-style.ts ===
// b_path:: packages/b_types/src/repeat-style.ts

import { z } from "zod";

/**
 * Represents a single <repetition> keyword.
 *
 * CSS Spec: <repetition> = repeat | space | round | no-repeat
 *
 * @see https://www.w3.org/TR/css-backgrounds-3/#typedef-repeat-style
 */
export const repetitionSchema = z.union([
  z.literal("repeat"),
  z.literal("space"),
  z.literal("round"),
  z.literal("no-repeat"),
]);

export type Repetition = z.infer<typeof repetitionSchema>;

/**
 * Represents a CSS <repeat-style> value.
 *
 * CSS Spec: <repeat-style> = repeat-x | repeat-y | [repeat | space | round | no-repeat]{1,2}
 *
 * Two forms:
 * - Shorthand: "repeat-x" or "repeat-y" (single keyword)
 * - Explicit: One or two <repetition> values (horizontal [vertical])
 *
 * When only one value is specified, it applies to both axes.
 *
 * @see https://www.w3.org/TR/css-backgrounds-3/#background-repeat
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/background-repeat
 */
export const repeatStyleSchema = z.discriminatedUnion("kind", [
  // Shorthand keywords: repeat-x, repeat-y
  z
    .object({
      kind: z.literal("shorthand"),
      value: z.union([z.literal("repeat-x"), z.literal("repeat-y")]),
    })
    .strict(),
  // Explicit: 1 or 2 repetition values
  z
    .object({
      kind: z.literal("explicit"),
      horizontal: repetitionSchema,
      vertical: repetitionSchema,
    })
    .strict(),
]);

export type RepeatStyle = z.infer<typeof repeatStyleSchema>;


=== File: packages/b_types/src/result/core.ts ===
// b_path:: packages/b_types/src/result/core.ts
/**
 * Core Result type for operations that may fail.
 *
 * Provides a type-safe way to handle errors without throwing exceptions.
 * Inspired by Rust's Result<T, E> and functional programming patterns.
 *
 * @module
 */

/**
 * Result type for operations that may fail.
 *
 * A discriminated union that ensures type safety:
 * - When `ok: true`, `value` is guaranteed to be present (type T)
 * - When `ok: false`, `error` is guaranteed to be present (type E)
 *
 * @example
 * ```typescript
 * import { Result, ok, err } from "@b/types";
 *
 * function divide(a: number, b: number): Result<number, string> {
 *   if (b === 0) return err("Division by zero");
 *   return ok(a / b);
 * }
 *
 * const result = divide(10, 2);
 * if (result.ok) {
 *   console.log(result.value); // 5 (type: number)
 * } else {
 *   console.error(result.error); // string
 * }
 * ```
 *
 * @public
 */
export type Result<T, E = Error> = { ok: true; value: T; error: undefined } | { ok: false; value: undefined; error: E };

/**
 * Create a successful result.
 *
 * @example
 * ```typescript
 * const result = ok(42);
 * console.log(result.ok); // true
 * console.log(result.value); // 42
 * console.log(result.error); // undefined
 * ```
 *
 * @public
 */
export function ok<T>(value: T): Result<T, never> {
  return { ok: true, value, error: undefined };
}

/**
 * Create an error result.
 *
 * @example
 * ```typescript
 * const result = err("Something went wrong");
 * console.log(result.ok); // false
 * console.log(result.error); // "Something went wrong"
 * console.log(result.value); // undefined
 * ```
 *
 * @public
 */
export function err<E>(error: E): Result<never, E> {
  return { ok: false, value: undefined, error };
}

/**
 * Convert a Zod SafeParseReturnType to a Result.
 *
 * @example
 * ```typescript
 * import { z } from "zod";
 * import { fromZod } from "@b/types";
 *
 * const schema = z.number();
 * const zodResult = schema.safeParse("not a number");
 * const result = fromZod(zodResult);
 *
 * if (!result.ok) {
 *   console.error(result.error); // ZodError
 * }
 * ```
 *
 * @public
 */
export function fromZod<T, E = unknown>(
  zodResult: { success: true; data: T } | { success: false; error: E },
): Result<T, E> {
  if (zodResult.success) {
    return ok(zodResult.data);
  }
  return err(zodResult.error);
}

/**
 * Unwrap a result, throwing if it's an error.
 * Use sparingly - prefer explicit error handling.
 *
 * @example
 * ```typescript
 * const result = ok(42);
 * const value = unwrap(result); // 42
 *
 * const errorResult = err("Failed");
 * unwrap(errorResult); // throws Error("Failed")
 * ```
 *
 * @public
 */
export function unwrap<T, E>(result: Result<T, E>): T {
  if (result.ok) {
    return result.value;
  }
  throw result.error instanceof Error ? result.error : new Error(String(result.error));
}

/**
 * Get the value or a default if error.
 *
 * @example
 * ```typescript
 * const result = err("Failed");
 * const value = unwrapOr(result, 42); // 42
 * ```
 *
 * @public
 */
export function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {
  return result.ok ? result.value : defaultValue;
}

/**
 * Map over a successful result.
 *
 * @example
 * ```typescript
 * const result = ok(2);
 * const doubled = map(result, x => x * 2);
 * console.log(doubled.value); // 4
 * ```
 *
 * @public
 */
export function map<T, U, E>(result: Result<T, E>, fn: (value: T) => U): Result<U, E> {
  return result.ok ? ok(fn(result.value)) : result;
}

/**
 * Chain results together (flatMap).
 *
 * @example
 * ```typescript
 * const result = ok(2);
 * const doubled = andThen(result, x =>
 *   x > 0 ? ok(x * 2) : err("Must be positive")
 * );
 * ```
 *
 * @public
 */
export function andThen<T, U, E>(result: Result<T, E>, fn: (value: T) => Result<U, E>): Result<U, E> {
  return result.ok ? fn(result.value) : result;
}


=== File: packages/b_types/src/result/generate.ts ===
// b_path:: packages/b_types/src/result/generate.ts
/**
 * GenerateResult type for IR → CSS generation operations.
 *
 * @module
 */

import type { Issue } from "./issue";

/**
 * Context for generation to enable path propagation through nested calls.
 *
 * @example
 * ```typescript
 * const context: GenerateContext = {
 *   parentPath: ["list", 0, "gradient", "colorStops", 0],
 *   property: "background-image"
 * };
 * ```
 *
 * @public
 */
export interface GenerateContext {
  /** Path from root to current position in IR tree */
  parentPath?: (string | number)[];
  /** CSS property being generated */
  property?: string;
}

/**
 * Result of generating CSS from intermediate representation.
 *
 * A discriminated union that ensures type safety:
 * - When `ok: true`, `value` is guaranteed to be present (CSS string)
 * - When `ok: false`, `value` is undefined
 *
 * ⚠️ **IMPORTANT**: Unlike ParseResult, GenerateResult does NOT support partial success.
 * - When `ok: false`, `value` is always undefined (no partial CSS strings)
 * - Generation is all-or-nothing: either produces valid CSS or fails completely
 * - Always check `issues` array for warnings even when `ok: true`
 *
 * **Issues array** allows warnings even on success. Generators can succeed with warnings
 * (e.g., clamped values, deprecated syntax).
 *
 * @example Success with warnings
 * ```typescript
 * const result = generateColor(rgbIR);
 * // { ok: true, value: "rgb(255 100 50)", issues: [warning about clamped value] }
 * if (result.ok) {
 *   console.log(result.value); // Use CSS string
 *   if (result.issues.length > 0) {
 *     logWarnings(result.issues); // Handle warnings
 *   }
 * }
 * ```
 *
 * @example Total failure
 * ```typescript
 * const result = generateGradient(invalidIR);
 * // { ok: false, value: undefined, issues: [error about missing field] }
 * if (!result.ok) {
 *   console.error(result.issues); // No partial CSS, must handle error
 * }
 * ```
 *
 * @public
 */
export type GenerateResult =
  | { ok: true; value: string; property?: string; issues: Issue[] }
  | { ok: false; value?: undefined; property?: string; issues: Issue[] };

/**
 * Create a successful GenerateResult.
 *
 * @example
 * ```typescript
 * return generateOk("#ff0000");
 * return generateOk("#ff0000", "color");  // with property
 * ```
 *
 * @public
 */
export function generateOk(value: string, property?: string): GenerateResult {
  const result: GenerateResult = {
    ok: true,
    value,
    issues: [],
  };
  if (property !== undefined) {
    result.property = property;
  }
  return result;
}

/**
 * Create a failed GenerateResult.
 *
 * Accepts either a single Issue or an array of Issues for multi-error scenarios.
 *
 * @example
 * ```typescript
 * // Single error
 * return generateErr(createError("invalid-ir", "Invalid IR structure"));
 *
 * // Multiple errors from Zod
 * return generateErr(zodErrorToIssues(zodError), "color");
 *
 * // With property
 * return generateErr(createError("missing-required-field", "Missing 'kind'"), "color");
 * ```
 *
 * @public
 */
export function generateErr(issues: Issue | Issue[], property?: string): GenerateResult {
  const result: GenerateResult = {
    ok: false,
    issues: Array.isArray(issues) ? issues : [issues],
  };
  if (property !== undefined) {
    result.property = property;
  }
  return result;
}

/**
 * Add an issue to a GenerateResult (preserves success state).
 *
 * Useful for adding warnings to successful generation.
 *
 * @example
 * ```typescript
 * let result = generateOk("#ff0000");
 * result = addGenerateIssue(result, warningIssue);
 * // result.ok is still true, but has a warning
 * ```
 *
 * @public
 */
export function addGenerateIssue(result: GenerateResult, issue: Issue): GenerateResult {
  return {
    ...result,
    issues: [...result.issues, issue],
  };
}

/**
 * Combine multiple GenerateResults into one (for list/array generation).
 *
 * All results must succeed for combined result to succeed.
 * All issues are collected regardless of success/failure.
 * CSS strings are joined with separator (default: ", ").
 *
 * @example
 * ```typescript
 * const results = [generateOk("red"), generateOk("blue")];
 * const combined = combineGenerateResults(results);
 * // { ok: true, value: "red, blue", issues: [] }
 *
 * // Custom separator
 * const spaced = combineGenerateResults(results, " ");
 * // { ok: true, value: "red blue", issues: [] }
 * ```
 *
 * @public
 */
export function combineGenerateResults(results: GenerateResult[], separator = ", "): GenerateResult {
  const allOk = results.every((r) => r.ok);
  const values = results.map((r) => r.value).filter((v): v is string => v !== undefined);
  const allIssues = results.flatMap((r) => r.issues);

  if (allOk && values.length === results.length) {
    return {
      ok: true,
      value: values.join(separator),
      issues: allIssues,
    };
  }

  return {
    ok: false,
    issues: allIssues,
  };
}

/**
 * Prepend parent path to all issues in a result.
 *
 * Used when calling nested generators to maintain full path context.
 *
 * @example
 * ```typescript
 * const colorResult = Color.generate(color);
 * const withPath = prependPathToIssues(colorResult, ["colorStops", 0, "color"]);
 * // Issues now have full path from parent context
 * ```
 *
 * @public
 */
export function prependPathToIssues(result: GenerateResult, pathPrefix: (string | number)[]): GenerateResult {
  if (pathPrefix.length === 0) {
    return result;
  }

  const issues = result.issues.map((issue) => ({
    ...issue,
    path: [...pathPrefix, ...(issue.path ?? [])],
  }));

  return {
    ...result,
    issues,
  };
}


=== File: packages/b_types/src/result/index.ts ===
// b_path:: packages/b_types/src/result/index.ts
/**
 * Result system for type-safe error handling.
 *
 * @module
 */

// Core Result type
export * from "./core";

// Issue tracking
export * from "./issue";

// Parse results
export * from "./parse";

// Generate results
export * from "./generate";


=== File: packages/b_types/src/result/issue.ts ===
// b_path:: packages/b_types/src/result/issue.ts
/**
 * Issue tracking for parse and generate operations.
 *
 * Provides structured error and warning reporting with strongly-typed codes.
 *
 * @module
 */

/**
 * Issue code categories for extensibility.
 *
 * Uses interface merging to allow packages to extend issue codes.
 * Each category maps to specific issue code strings.
 *
 * @public
 */
export interface IssueCodeMap {
  parse: "invalid-value" | "invalid-syntax" | "missing-value";
  generate: "invalid-ir" | "missing-required-field" | "unsupported-kind" | "unrecognized-keys" | "invalid-union";
  warning: "duplicate-property" | "deprecated-syntax" | "legacy-syntax";
}

/**
 * Union of all issue codes.
 *
 * Packages can extend IssueCodeMap via module augmentation to add custom codes.
 *
 * @example
 * ```typescript
 * // In b_parsers package
 * declare module "@b/types" {
 *   interface IssueCodeMap {
 *     parse: "invalid-gradient" | "invalid-color";
 *   }
 * }
 * ```
 *
 * @public
 */
export type IssueCode = IssueCodeMap[keyof IssueCodeMap];

/**
 * Issue reported during parsing or generation.
 *
 * Strongly typed for IDE autocomplete and type safety.
 * All fields are intentionally flat (no nested objects) for simplicity.
 *
 * @example
 * ```typescript
 * {
 *   code: "invalid-value",
 *   severity: "error",
 *   message: "Unknown named color 'notacolor'",
 *   property: "color",
 *   path: ["ir", "color", "value"]
 * }
 * ```
 *
 * @public
 */
export interface Issue {
  /** Issue code for categorization */
  code: IssueCode;
  /** Severity level */
  severity: "error" | "warning" | "info";
  /** Human-readable message */
  message: string;
  /** Optional CSS property name that caused the issue */
  property?: string;
  /** Optional suggestion for fixing the issue */
  suggestion?: string;
  /** Optional path to error in IR structure (for generation errors) */
  path?: (string | number)[];
  /** Optional expected type or value */
  expected?: string;
  /** Optional received type or value */
  received?: string;
}

/**
 * Create an error issue.
 *
 * @example
 * ```typescript
 * const issue = createError("invalid-value", "Invalid hex color");
 * ```
 *
 * @public
 */
export function createError(
  code: IssueCode,
  message: string,
  options?: {
    property?: string;
    suggestion?: string;
    path?: (string | number)[];
    expected?: string;
    received?: string;
  },
): Issue {
  return {
    code,
    severity: "error",
    message,
    ...options,
  };
}

/**
 * Create a warning issue.
 *
 * @example
 * ```typescript
 * const issue = createWarning("deprecated-syntax", "Use modern syntax", {
 *   suggestion: "Replace with new syntax"
 * });
 * ```
 *
 * @public
 */
export function createWarning(
  code: IssueCode,
  message: string,
  options?: {
    property?: string;
    suggestion?: string;
    path?: (string | number)[];
    expected?: string;
    received?: string;
  },
): Issue {
  return {
    code,
    severity: "warning",
    message,
    ...options,
  };
}

/**
 * Create an info issue.
 *
 * @example
 * ```typescript
 * const issue = createInfo("legacy-syntax", "Consider updating syntax");
 * ```
 *
 * @public
 */
export function createInfo(
  code: IssueCode,
  message: string,
  options?: {
    property?: string;
    suggestion?: string;
    path?: (string | number)[];
    expected?: string;
    received?: string;
  },
): Issue {
  return {
    code,
    severity: "info",
    message,
    ...options,
  };
}


=== File: packages/b_types/src/result/parse.ts ===
// b_path:: packages/b_types/src/result/parse.ts
/**
 * ParseResult type for CSS → IR parsing operations.
 *
 * @module
 */

import type { Issue } from "./issue";

/**
 * Result of parsing CSS to intermediate representation.
 *
 * Represents one of three states:
 * 1. **Success**: `ok: true`, `value` contains parsed data (type T)
 * 2. **Total failure**: `ok: false`, `value` is `undefined`, parsing failed early (fail-fast)
 * 3. **Partial success**: `ok: false`, `value` contains partial data (type T), some items parsed (multi-error)
 *
 * ⚠️ **CRITICAL**: Always check BOTH `ok` flag AND `value` field:
 * - When `ok: false`, `value` MAY still contain partial/recovered data
 * - When `ok: true`, always inspect `issues` array for warnings
 * - Never assume `ok: false` means `value` is undefined
 *
 * **When `ok: false`:**
 * - `issues` contains at least one error
 * - `value` is `undefined` for fail-fast parsers (e.g., single value parsing)
 * - `value` contains partial result for multi-error parsers (e.g., list parsing where some items succeeded)
 *
 * **Issues array** allows warnings even on success. Parsers can succeed with warnings.
 *
 * @example Fail-fast parser (single angle)
 * ```typescript
 * const result = parseAngle("invalid");
 * // { ok: false, value: undefined, issues: [error] }
 * ```
 *
 * @example Multi-error parser (background-image layers)
 * ```typescript
 * const result = parseBackgroundImage("url(a.png), invalid, url(b.png)");
 * // { ok: false, value: { kind: 'layers', layers: [valid1, valid3] }, issues: [error] }
 * // Two layers parsed successfully, one failed
 * ```
 *
 * @example Success with warnings
 * ```typescript
 * const result = parseColor("rgb(300 100 50)");
 * // { ok: true, value: rgbIR, issues: [warning] }
 * // Valid RGB syntax, but value out of range (warning)
 * ```
 *
 * @example Handling partial success correctly
 * ```typescript
 * const result = parseDeclaration(...);
 * if (result.ok) {
 *   // Full success - use value
 *   applyStyles(result.value);
 * } else if (result.value) {
 *   // Partial success - some data recovered despite errors
 *   applyStylesWithWarning(result.value, result.issues);
 * } else {
 *   // Total failure - no recoverable data
 *   handleError(result.issues);
 * }
 * ```
 *
 * @public
 */
export type ParseResult<T = unknown> =
  | { ok: true; value: T; property?: string; issues: Issue[] }
  | { ok: false; value?: undefined; property?: string; issues: Issue[] }
  | { ok: false; value: T; property?: string; issues: Issue[] };

/**
 * Create a successful ParseResult.
 *
 * @example
 * ```typescript
 * return parseOk(colorIR);
 * return parseOk(colorIR, "background-color");  // with property
 * ```
 *
 * @public
 */
export function parseOk<T>(value: T, property?: string): ParseResult<T> {
  const result: ParseResult<T> = {
    ok: true,
    value,
    issues: [],
  };
  if (property !== undefined) {
    result.property = property;
  }
  return result;
}

/**
 * Create a failed ParseResult.
 *
 * @example
 * ```typescript
 * return parseErr("invalid-value", "Invalid color format");
 * return parseErr("invalid-value", "Invalid hex color", {
 *   suggestion: "Use #RRGGBB format",
 *   property: "color"
 * });
 * ```
 *
 * @public
 */
export function parseErr<T = never>(property: string, issue: Issue): ParseResult<T> {
  const result: ParseResult<T> = {
    ok: false,
    property,
    issues: [issue],
  };
  // if (property !== undefined) {
  //   result.property = property;
  // }
  return result;
}

/**
 * Add an issue to a ParseResult (preserves success state).
 *
 * Useful for adding warnings to successful parses.
 *
 * @example
 * ```typescript
 * let result = parseOk(colorIR);
 * result = addIssue(result, warningIssue);
 * // result.ok is still true, but has a warning
 * ```
 *
 * @public
 */
export function addIssue<T>(result: ParseResult<T>, issue: Issue): ParseResult<T> {
  return {
    ...result,
    issues: [...result.issues, issue],
  };
}

/**
 * Creates a new ParseResult failure from an existing one, preserving issues
 * but ensuring the new result has the correct (undefined) value type.
 *
 * Use this when an early parse step fails and you need to forward the error
 * to the parent parser's return type without using `as` casts.
 *
 * @example
 * ```typescript
 * function parseHSL(node: CssValue): ParseResult<HSLColor> {
 *   const hResult = parseComponentH(node);
 *   if (!hResult.ok) return forwardParseErr<HSLColor>(hResult);
 *   // ...
 * }
 * ```
 *
 * @public
 */
export function forwardParseErr<T>(failedResult: ParseResult<unknown>): ParseResult<T> {
  return {
    ok: false,
    issues: failedResult.issues,
    property: failedResult.property,
  };
}

/**
 * Combine multiple ParseResults into one (for list/array parsing).
 *
 * All results must succeed for combined result to succeed.
 * All issues are collected regardless of success/failure.
 *
 * @example
 * ```typescript
 * const results = [parseOk(color1), parseOk(color2)];
 * const combined = combineResults(results);
 * // { ok: true, value: [color1, color2], issues: [] }
 * ```
 *
 * @public
 */
export function combineResults<T>(results: ParseResult<T>[]): ParseResult<T[]> {
  const allOk = results.every((r) => r.ok);
  const values = results.map((r) => r.value).filter((v): v is T => v !== undefined);
  const allIssues = results.flatMap((r) => r.issues);

  if (allOk && values.length === results.length) {
    return {
      ok: true,
      value: values,
      issues: allIssues,
    };
  }

  return {
    ok: false,
    issues: allIssues,
  };
}


=== File: packages/b_types/src/url.ts ===
// b_path:: packages/b_types/src/url.ts
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/url
 */
export const urlSchema = z
  .object({
    kind: z.literal("url"),
    value: z.string(),
  })
  .strict();

export type Url = z.infer<typeof urlSchema>;


=== File: packages/b_types/src/values/css-value.ts ===
// b_path:: packages/b_types/src/values/css-value.ts
import { z } from "zod";

/**
 * Represents a literal numeric value with optional unit
 * @see https://drafts.csswg.org/css-values-4/#numeric-types
 */
export const literalValueSchema = z
  .object({
    kind: z.literal("literal"),
    value: z.number(),
    unit: z.string().optional(),
  })
  .strict();

export const keywordValueSchema = z
  .object({
    kind: z.literal("keyword"),
    value: z.string(),
  })
  .strict();

/**
 * Represents a CSS custom property reference (var() function)
 * @see https://drafts.csswg.org/css-variables/#using-variables
 */
export const variableReferenceSchema: z.ZodType<{
  kind: "variable";
  name: string;
  fallback?: CssValue;
}> = z
  .object({
    kind: z.literal("variable"),
    name: z.string(),
    fallback: z.lazy((): z.ZodType<CssValue> => cssValueSchema).optional(),
  })
  .strict();

// --- NEW SCHEMAS ---

/**
 * Represents a CSS string literal (e.g., "Hello World")
 * @see https://drafts.csswg.org/css-values-4/#strings
 */
export const stringLiteralSchema = z
  .object({
    kind: z.literal("string"),
    value: z.string(),
  })
  .strict();

/**
 * Represents a CSS hex color value
 * (e.g., #RRGGBB or #RGB)
 */
export const hexColorValueSchema = z
  .object({
    kind: z.literal("hex-color"),
    value: z.string().regex(/^#([0-9a-fA-F]{3,4}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/),
  })
  .strict();

// --- END NEW SCHEMAS ---

export const listValueSchema: z.ZodType<{
  kind: "list";
  separator: " " | ",";
  values: CssValue[];
}> = z
  .object({
    kind: z.literal("list"),
    separator: z.enum([" ", ","]),
    values: z.array(z.lazy((): z.ZodType<CssValue> => cssValueSchema)),
  })
  .strict();

// Represents a single operation within a calc() expression
export const calcOperationSchema: z.ZodType<{
  kind: "calc-operation";
  operator: "+" | "-" | "*" | "/";
  // The operands can be any valid CSS value, including another operation
  left: CssValue;
  right: CssValue;
}> = z
  .object({
    kind: z.literal("calc-operation"),
    operator: z.enum(["+", "-", "*", "/"]),
    // Use z.lazy() for the recursive definition
    left: z.lazy((): z.ZodType<CssValue> => cssValueSchema),
    right: z.lazy((): z.ZodType<CssValue> => cssValueSchema),
  })
  .strict();

// A top-level calc() function just holds the root operation/value
export const calcFunctionSchema: z.ZodType<{
  kind: "calc";
  value: CssValue;
}> = z
  .object({
    kind: z.literal("calc"),
    // The value inside can be a simple literal or a complex operation tree
    value: z.lazy((): z.ZodType<CssValue> => cssValueSchema),
  })
  .strict();

// For min() and max()
export const minmaxFunctionSchema: z.ZodType<{
  kind: "min" | "max";
  values: CssValue[];
}> = z
  .object({
    kind: z.union([z.literal("min"), z.literal("max")]),
    values: z.array(z.lazy((): z.ZodType<CssValue> => cssValueSchema)),
  })
  .strict();

// For clamp()
export const clampFunctionSchema: z.ZodType<{
  kind: "clamp";
  min: CssValue;
  preferred: CssValue;
  max: CssValue;
}> = z
  .object({
    kind: z.literal("clamp"),
    // clamp() always has 3 arguments: min, preferred, max
    min: z.lazy((): z.ZodType<CssValue> => cssValueSchema),
    preferred: z.lazy((): z.ZodType<CssValue> => cssValueSchema),
    max: z.lazy((): z.ZodType<CssValue> => cssValueSchema),
  })
  .strict();

export const urlFunctionSchema = z
  .object({
    kind: z.literal("url"),
    url: z.string(),
  })
  .strict();

export const attrFunctionSchema: z.ZodType<{
  kind: "attr";
  name: string;
  typeOrUnit?: string; // e.g., "color", "px"
  fallback?: CssValue;
}> = z
  .object({
    kind: z.literal("attr"),
    name: z.string(),
    typeOrUnit: z.string().optional(),
    fallback: z.lazy((): z.ZodType<CssValue> => cssValueSchema).optional(),
  })
  .strict();

/**
 * NOTE: RGB/HSL color function schemas commented out - we are not sure these need to be here.
 * These create an inconsistency: why RGB/HSL but not LCH/OKLCH/LAB/etc?
 * Generic functionCallSchema handles all color functions consistently.
 * Specific color parsing happens in dedicated color parsers (packages/b_parsers/src/color/).
 *
 * If needed, uncomment and add ALL color function schemas, not just RGB/HSL.
 */
// export const rgbFunctionSchema: z.ZodType<{
//   kind: "rgb" | "rgba";
//   components: CssValue[];
// }> = z
//   .object({
//     kind: z.union([z.literal("rgb"), z.literal("rgba")]),
//     components: z.array(z.lazy((): z.ZodType<CssValue> => cssValueSchema)),
//   })
//   .strict();

// export const hslFunctionSchema: z.ZodType<{
//   kind: "hsl" | "hsla";
//   components: CssValue[];
// }> = z
//   .object({
//     kind: z.union([z.literal("hsl"), z.literal("hsla")]),
//     components: z.array(z.lazy((): z.ZodType<CssValue> => cssValueSchema)),
//   })
//   .strict();

/**
 * Represents a generic CSS function call (e.g., linear-gradient(...))
 */
export const functionCallSchema: z.ZodType<{
  kind: "function";
  name: string;
  args: CssValue[];
}> = z
  .object({
    kind: z.literal("function"),
    name: z.string(),
    args: z.array(z.lazy((): z.ZodType<CssValue> => cssValueSchema)),
  })
  .strict();

/**
 * Union of all possible CSS value representations
 * This is the foundation for representing authored CSS values
 * that may contain symbolic references (var()), keywords, or literals
 */
// export const cssValueSchema = z.union([literalValueSchema, variableReferenceSchema, keywordValueSchema]);

export const allCssValueSchema = [
  // Structural
  listValueSchema,

  // Primitives
  literalValueSchema,
  keywordValueSchema,
  stringLiteralSchema,
  variableReferenceSchema,

  // Functions
  urlFunctionSchema,
  functionCallSchema,
  calcFunctionSchema,
  attrFunctionSchema,
  clampFunctionSchema,
  minmaxFunctionSchema,
  calcOperationSchema,

  // NOTE: Color function schemas commented out for consistency
  // Only hexColorValueSchema remains as it's a simple literal type
  hexColorValueSchema,
  // All color functions (rgb, hsl, lch, oklch, lab, etc.) handled by functionCallSchema
  // lchColorSchema,
  // rgbFunctionSchema,
  // hslFunctionSchema,
];

export const cssValueSchema = z.union(allCssValueSchema, {
  error: () => "Expected valid CssValue (literal, keyword, variable, function, ...)",
});

export type LiteralValue = z.infer<typeof literalValueSchema>;
export type VariableReference = z.infer<typeof variableReferenceSchema>;
export type KeywordValue = z.infer<typeof keywordValueSchema>;
export type CssValue = z.infer<typeof cssValueSchema>;


=== File: packages/b_types/src/values/index.ts ===
// b_path:: packages/b_types/src/values/index.ts
export * from "./css-value";


=== File: packages/b_types/tsup.config.ts ===
// b_path:: packages/b_types/tsup.config.ts
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/index.ts"],
  format: ["cjs", "esm"],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
  treeshake: true,
});


=== File: packages/b_types/vite.config.ts ===
// b_path:: packages/b_types/vite.config.ts
import { defineConfig } from "vite";

import tsconfigPaths from "vite-tsconfig-paths";

// https://vite.dev/config/
export default defineConfig({
  plugins: [tsconfigPaths()],
});


=== File: packages/b_units/src/angle.ts ===
// b_path:: packages/b_units/src/angle.ts
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/angle
 */
export const angleUnitSchema = z.union([z.literal("deg"), z.literal("grad"), z.literal("rad"), z.literal("turn")]);

export const ANGLE_UNITS = angleUnitSchema.options.map((option) => option.value);

export type AngleUnit = z.infer<typeof angleUnitSchema>;


=== File: packages/b_units/src/index.ts ===
// b_path:: packages/b_units/src/index.ts
export * from "./angle";
export * from "./length-absolute";
export * from "./length-font";
export * from "./length-viewport";
export * from "./length";
export * from "./percentage";


=== File: packages/b_units/src/length-absolute.ts ===
// b_path:: packages/b_units/src/length-absolute.ts
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/length#absolute_length_units
 */
export const absoluteLengthUnitSchema = z.union([
  z.literal("px"),
  z.literal("pt"),
  z.literal("cm"),
  z.literal("mm"),
  z.literal("Q"),
  z.literal("in"),
  z.literal("pc"),
]);

export const ABSOLUTE_LENGTH_UNITS = absoluteLengthUnitSchema.options.map((option) => option.value);

export type AbsoluteLengthUnit = z.infer<typeof absoluteLengthUnitSchema>;


=== File: packages/b_units/src/length-font.ts ===
// b_path:: packages/b_units/src/length-font.ts
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/length#font-relative_lengths
 */
export const fontLengthUnitSchema = z.union([
  z.literal("em"),
  z.literal("ex"),
  z.literal("cap"),
  z.literal("ch"),
  z.literal("ic"),
  z.literal("rem"),
  z.literal("rex"),
  z.literal("rcap"),
  z.literal("rch"),
  z.literal("ric"),
  z.literal("lh"),
  z.literal("rlh"),
]);

export const FONT_LENGTH_UNITS = fontLengthUnitSchema.options.map((option) => option.value);

export type FontLengthUnit = z.infer<typeof fontLengthUnitSchema>;


=== File: packages/b_units/src/length-viewport.ts ===
// b_path:: packages/b_units/src/length-viewport.ts
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/length#viewport-percentage_lengths
 */
export const viewportLengthUnitSchema = z.union([
  z.literal("vw"),
  z.literal("vh"),
  z.literal("vi"),
  z.literal("vb"),
  z.literal("vmin"),
  z.literal("vmax"),
  z.literal("svw"),
  z.literal("svh"),
  z.literal("svi"),
  z.literal("svb"),
  z.literal("svmin"),
  z.literal("svmax"),
  z.literal("lvw"),
  z.literal("lvh"),
  z.literal("lvi"),
  z.literal("lvb"),
  z.literal("lvmin"),
  z.literal("lvmax"),
  z.literal("dvw"),
  z.literal("dvh"),
  z.literal("dvi"),
  z.literal("dvb"),
  z.literal("dvmin"),
  z.literal("dvmax"),
]);

export const VIEWPORT_LENGTH_UNITS = viewportLengthUnitSchema.options.map((option) => option.value);

export type ViewportLengthUnit = z.infer<typeof viewportLengthUnitSchema>;


=== File: packages/b_units/src/length.ts ===
// b_path:: packages/b_units/src/length.ts
import { z } from "zod";
import { absoluteLengthUnitSchema } from "./length-absolute";
import { fontLengthUnitSchema } from "./length-font";
import { viewportLengthUnitSchema } from "./length-viewport";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/length
 */
export const lengthUnitSchema = z.union([absoluteLengthUnitSchema, fontLengthUnitSchema, viewportLengthUnitSchema]);

export type LengthUnit = z.infer<typeof lengthUnitSchema>;


=== File: packages/b_units/src/percentage.ts ===
// b_path:: packages/b_units/src/percentage.ts
import { z } from "zod";

/**
 * @see https://developer.mozilla.org/en-US/docs/Web/CSS/percentage
 */
export const percentageUnitSchema = z.literal("%");

export const PERCENTAGE_UNIT = "%" as const;

export type PercentageUnit = z.infer<typeof percentageUnitSchema>;


=== File: packages/b_units/tsup.config.ts ===
// b_path:: packages/b_units/tsup.config.ts
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/index.ts"],
  format: ["cjs", "esm"],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
  treeshake: true,
});


=== File: packages/b_units/vite.config.ts ===
// b_path:: packages/b_units/vite.config.ts
import { defineConfig } from "vite";

import tsconfigPaths from "vite-tsconfig-paths";

// https://vite.dev/config/
export default defineConfig({
  plugins: [tsconfigPaths()],
});


=== File: packages/b_utils/src/generate/css-value.ts ===
// b_path:: packages/b_utils/src/generate/css-value.ts
import type { CssValue } from "@b/types";

/**
 * Generates CSS string representation from a CssValue
 * Handles all CSS value types including functions and operations
 * @see https://drafts.csswg.org/css-values-4/
 */
export function cssValueToCss(value: CssValue): string {
  switch (value.kind) {
    case "literal": {
      const { value: num, unit } = value;
      return unit ? `${num}${unit}` : String(num);
    }

    case "variable": {
      const { name, fallback } = value;
      if (fallback) {
        return `var(${name}, ${cssValueToCss(fallback)})`;
      }
      return `var(${name})`;
    }

    case "keyword": {
      return value.value;
    }

    case "list": {
      const { values, separator } = value;
      return values.map((v) => cssValueToCss(v)).join(separator);
    }

    case "calc": {
      return `calc(${cssValueToCss(value.value)})`;
    }

    case "calc-operation": {
      const { left, operator, right } = value;
      const leftStr = cssValueToCss(left);
      const rightStr = cssValueToCss(right);
      // Add spaces around operators for readability
      return `${leftStr} ${operator} ${rightStr}`;
    }

    case "min":
    case "max": {
      const { values } = value;
      const valuesStr = values.map((v) => cssValueToCss(v)).join(", ");
      return `${value.kind}(${valuesStr})`;
    }

    case "clamp": {
      const { min, preferred, max } = value;
      const minStr = cssValueToCss(min);
      const preferredStr = cssValueToCss(preferred);
      const maxStr = cssValueToCss(max);
      return `clamp(${minStr}, ${preferredStr}, ${maxStr})`;
    }

    case "url": {
      return `url(${value.url})`;
    }

    case "attr": {
      const { name, typeOrUnit, fallback } = value;
      let result = `attr(${name}`;
      if (typeOrUnit) {
        result += ` ${typeOrUnit}`;
      }
      if (fallback) {
        result += `, ${cssValueToCss(fallback)}`;
      }
      result += ")";
      return result;
    }

    case "function": {
      const { name, args } = value;
      const argsStr = args.map((arg) => cssValueToCss(arg)).join(", ");
      return `${name}(${argsStr})`;
    }

    // NOTE: RGB/HSL cases commented out - now handled by generic "function" case above
    // Keeping this comment for reference in case we need to restore special handling
    // case "rgb":
    // case "rgba":
    // case "hsl":
    // case "hsla": {
    //   const { components } = value;
    //   const componentsStr = components.map((c) => cssValueToCss(c)).join(", ");
    //   return `${value.kind}(${componentsStr})`;
    // }

    case "string": {
      return `"${value.value}"`;
    }

    case "hex-color": {
      return value.value;
    }
  }
}


=== File: packages/b_utils/src/generate/index.ts ===
// b_path:: packages/b_utils/src/generate/index.ts
export * from "./css-value";
export * from "./values";
export * from "./validation";


=== File: packages/b_utils/src/generate/validation.ts ===
// b_path:: packages/b_utils/src/generate/validation.ts

import type { z } from "zod";
import type { Issue } from "@b/types";
import { findClosestMatch } from "../string/levenshtein";

// Use Zod v4 core types (not deprecated)
type ZodIssue = z.core.$ZodIssue;
type ZodError = z.ZodError;
type ZodIssueInvalidUnion = z.core.$ZodIssueInvalidUnion;
type ZodIssueUnrecognizedKeys = z.core.$ZodIssueUnrecognizedKeys;

/**
 * Context for enhancing Zod error messages with domain-specific information.
 *
 * @public
 */
export interface ZodErrorContext {
  /** Type name being validated (e.g., "RGBColor") */
  typeName?: string;
  /** CSS property name (e.g., "background-color") */
  property?: string;
  /** Parent path for nested structures */
  parentPath?: (string | number)[];
  /** Valid keys for this schema (for typo suggestions) */
  validKeys?: string[];
  /** The actual value that was received (for union errors) */
  receivedValue?: unknown;
}

/**
 * Format a path array into a human-readable string.
 *
 * Converts an array path (e.g., from Zod validation) into dot notation
 * with bracket notation for array indices.
 *
 * @param path - Array of path segments (strings and numbers)
 * @returns Formatted path string
 *
 * @example
 * ```typescript
 * formatPath(["durations", 0, "unit"]) // "durations[0].unit"
 * formatPath(["value"]) // "value"
 * formatPath([]) // ""
 * ```
 *
 * @public
 */
export function formatPath(path: (string | number)[]): string {
  if (path.length === 0) return "";

  return path.reduce<string>((acc, segment, i) => {
    if (typeof segment === "number") return `${acc}[${segment}]`;
    if (i === 0) return String(segment);
    return `${acc}.${segment}`;
  }, "");
}

/**
 * Convert Zod validation errors to b_value Issue format.
 *
 * Zod creates deeply nested error structures for unions and complex schemas.
 * This recursively traverses the error tree and extracts actionable error messages
 * with path context for pinpointing the exact location of validation failures.
 *
 * Features:
 * - Recursively traverses union errors to collect all failures
 * - Includes path context in error messages (e.g., "durations[0].unit: ...")
 * - Preserves path array for programmatic access
 * - Adds expected/received information for type errors
 * - Provides "Did you mean?" suggestions for typos
 * - Filters out generic "Invalid input" messages
 *
 * @param zodError - Zod validation error from safeParse()
 * @param context - Optional context for enhanced error messages
 * @returns Array of Issue objects with detailed error information and path context
 *
 * @example
 * ```typescript
 * import { zodErrorToIssues } from "@/utils/generate";
 * import { rgbColorSchema } from "@/core/types/color";
 *
 * const validation = rgbColorSchema.safeParse(input);
 * if (!validation.success) {
 *   const issues = zodErrorToIssues(validation.error, {
 *     typeName: "RGBColor",
 *     property: "background-color"
 *   });
 *   // Rich error with context, path, and suggestions
 *   return { ok: false, issues };
 * }
 * ```
 *
 * @public
 */
export function zodErrorToIssues(zodError: ZodError, context?: ZodErrorContext): Issue[] {
  const issues: Issue[] = [];

  function traverse(zodIssues: readonly ZodIssue[], parentPath: (string | number)[] = []): void {
    for (const zodIssue of zodIssues) {
      if (zodIssue.code === "invalid_union") {
        const unionIssue = zodIssue as ZodIssueInvalidUnion;

        // If union has a custom message (not generic "Invalid input"), use it and DON'T traverse
        if (zodIssue.message !== "Invalid input") {
          const relativePath = zodIssue.path.filter(
            (p): p is string | number => typeof p === "string" || typeof p === "number",
          );
          const fullPath = [...parentPath, ...relativePath];

          issues.push(createIssue(zodIssue, fullPath, context));
          continue;
        }

        // Generic union error - traverse into all branches to collect specific errors
        const unionPath = [
          ...parentPath,
          ...zodIssue.path.filter((p): p is string | number => typeof p === "string" || typeof p === "number"),
        ];

        if (Array.isArray(unionIssue.errors)) {
          for (const errorGroup of unionIssue.errors) {
            if (Array.isArray(errorGroup)) {
              traverse(errorGroup, unionPath);
            }
          }
        }
      } else {
        // Skip generic "Invalid input" messages without path details
        if (zodIssue.message === "Invalid input" && zodIssue.path.length === 0) {
          continue;
        }

        // Convert path to (string | number)[] - filter out symbols if present
        const relativePath = zodIssue.path.filter(
          (p): p is string | number => typeof p === "string" || typeof p === "number",
        );
        const fullPath = [...parentPath, ...relativePath];

        issues.push(createIssue(zodIssue, fullPath, context));
      }
    }
  }

  traverse(zodError.issues, context?.parentPath);

  // Fallback if no specific errors found
  if (issues.length === 0) {
    issues.push({
      code: "invalid-ir",
      severity: "error",
      message: "Invalid IR structure",
      property: context?.property,
    });
  }

  return issues;
}

/**
 * Create an Issue from a ZodIssue with enhanced context.
 */
function createIssue(zodIssue: ZodIssue, fullPath: (string | number)[], context?: ZodErrorContext): Issue {
  const pathStr = formatPath(fullPath);
  const message = formatZodMessage(zodIssue, pathStr, context);
  const code = mapZodCode(zodIssue.code);

  return {
    code,
    severity: "error",
    message,
    property: context?.property,
    path: fullPath.length > 0 ? fullPath : undefined,
    suggestion: generateSuggestion(zodIssue, context),
    expected: extractExpected(zodIssue, context),
    received: extractReceived(zodIssue, context),
  };
}

/**
 * Map Zod error codes to our IssueCode types.
 */
function mapZodCode(zodCode: string): Issue["code"] {
  const mapping: Record<string, Issue["code"]> = {
    invalid_type: "invalid-ir",
    unrecognized_keys: "unrecognized-keys",
    invalid_union: "invalid-union",
    too_small: "missing-required-field",
    too_big: "invalid-value",
    invalid_literal: "invalid-value",
    invalid_enum_value: "invalid-value",
  };
  return mapping[zodCode] ?? "invalid-ir";
}

/**
 * Format Zod message with context.
 */
function formatZodMessage(issue: ZodIssue, pathStr: string, context?: ZodErrorContext): string {
  const typeStr = context?.typeName ? ` in ${context.typeName}` : "";

  switch (issue.code) {
    case "invalid_type": {
      const expected = "expected" in issue ? String(issue.expected) : "unknown";
      const received = "received" in issue ? String(issue.received) : "unknown";

      if (received === "undefined") {
        return pathStr ? `Missing required field at '${pathStr}'${typeStr}` : `Missing required field${typeStr}`;
      }
      return pathStr
        ? `Invalid type at '${pathStr}'${typeStr}: expected ${expected}, got ${received}`
        : `Invalid type${typeStr}: expected ${expected}, got ${received}`;
    }

    case "unrecognized_keys": {
      const keysIssue = issue as ZodIssueUnrecognizedKeys;
      const keys = keysIssue.keys.map((k) => `'${String(k)}'`).join(", ");
      return pathStr
        ? `Unrecognized key(s) at '${pathStr}'${typeStr}: ${keys}`
        : `Unrecognized key(s)${typeStr}: ${keys}`;
    }

    default:
      return pathStr ? `${pathStr}: ${issue.message}` : issue.message;
  }
}

/**
 * Generate actionable suggestions for fixing errors.
 */
function generateSuggestion(issue: ZodIssue, context?: ZodErrorContext): string | undefined {
  switch (issue.code) {
    case "invalid_type": {
      const expected = "expected" in issue ? String(issue.expected) : "unknown";
      const received = "received" in issue ? String(issue.received) : "unknown";

      if (received === "undefined") {
        const field = issue.path[issue.path.length - 1];
        const fieldStr = field ? String(field) : "This field";
        return `'${fieldStr}' is required`;
      }
      return `Expected ${expected}, received ${received}`;
    }

    case "unrecognized_keys": {
      const keysIssue = issue as ZodIssueUnrecognizedKeys;

      // Generate suggestions for all unrecognized keys
      if (context?.validKeys && keysIssue.keys.length > 0) {
        const validKeys = context.validKeys; // Type guard: now TypeScript knows it's string[]
        const suggestions = keysIssue.keys
          .map((unknownKey) => {
            const unknownKeyStr = String(unknownKey);
            const closestMatch = findClosestMatch(unknownKeyStr, validKeys);

            if (closestMatch) {
              return `Did you mean '${closestMatch}' instead of '${unknownKeyStr}'?`;
            }
            return `'${unknownKeyStr}' is not a valid key`;
          })
          .filter(Boolean);

        if (suggestions.length > 0) {
          return suggestions.join(" ");
        }
      }

      // Fallback when no context or no keys
      const keysList = keysIssue.keys.map((k) => `'${String(k)}'`).join(", ");
      return `Unrecognized key${keysIssue.keys.length > 1 ? "s" : ""}: ${keysList}`;
    }

    case "invalid_union": {
      // For union errors, try to suggest closest match
      if (context?.receivedValue && context?.validKeys && context.validKeys.length > 0) {
        const receivedStr = String(context.receivedValue);
        const suggestion = findClosestMatch(receivedStr, context.validKeys);
        if (suggestion) {
          return `Did you mean '${suggestion}'?`;
        }
      }

      // Fallback: show first few valid options
      if (context?.validKeys && context.validKeys.length > 0) {
        const preview = context.validKeys.slice(0, 5).join(", ");
        const more = context.validKeys.length > 5 ? `... (${context.validKeys.length - 5} more)` : "";
        return `Must be one of: ${preview}${more}`;
      }

      return undefined;
    }

    default:
      return undefined;
  }
}

/**
 * Extract expected value/type from ZodIssue.
 */
function extractExpected(issue: ZodIssue, context?: ZodErrorContext): string | undefined {
  if ("expected" in issue) {
    return String(issue.expected);
  }

  // For union errors, show valid options if available
  if (issue.code === "invalid_union" && context?.validKeys && context.validKeys.length > 0) {
    const preview = context.validKeys.slice(0, 3).join(" | ");
    const more = context.validKeys.length > 3 ? ` | ... (${context.validKeys.length} total)` : "";
    return preview + more;
  }

  return undefined;
}

/**
 * Extract received value/type from ZodIssue.
 */
function extractReceived(issue: ZodIssue, context?: ZodErrorContext): string | undefined {
  if ("received" in issue) {
    return String(issue.received);
  }

  // For union errors, use the received value from context if available
  if (issue.code === "invalid_union" && context?.receivedValue !== undefined) {
    return String(context.receivedValue);
  }

  return undefined;
}


=== File: packages/b_utils/src/generate/values.ts ===
// b_path:: packages/b_utils/src/generate/values.ts
import type * as Type from "@b/types";
import { cssValueToCss } from "./css-value";

/**
 * @see https://drafts.csswg.org/css-values-4/#lengths
 */
export function lengthToCss(length: Type.Length): string {
  return `${length.value}${length.unit}`;
}

/**
 * @see https://drafts.csswg.org/css-values-4/#percentage-value
 */
export function lengthPercentageToCss(lengthPercentage: Type.LengthPercentage): string {
  return `${lengthPercentage.value}${lengthPercentage.unit}`;
}

/**
 * @see https://drafts.csswg.org/css-values-4/#angles
 */
export function angleToCss(angle: Type.Angle): string {
  return `${angle.value}${angle.unit}`;
}

/**
 * @see https://drafts.csswg.org/css-values-4/#numbers
 */
export function numberToCss(number: number): string {
  return String(number);
}

/**
 * @see https://drafts.csswg.org/css-backgrounds-3/#typedef-bg-position
 */
export function position2DToCss(position: Type.Position2D): string {
  const h =
    "edge" in position.horizontal
      ? `${position.horizontal.edge} ${cssValueToCss(position.horizontal.offset)}`
      : cssValueToCss(position.horizontal);

  const v =
    "edge" in position.vertical
      ? `${position.vertical.edge} ${cssValueToCss(position.vertical.offset)}`
      : cssValueToCss(position.vertical);

  return `${h} ${v}`;
}

export function joinCssValues(values: string[]): string {
  return values.join(", ");
}

export function joinCssValuesWithSpaces(values: string[]): string {
  return values.join(" ");
}


=== File: packages/b_utils/src/index.ts ===
// b_path:: packages/b_utils/src/index.ts
export * from "./generate";
export * from "./parse";
export * from "./string";
export * from "./validation";


=== File: packages/b_utils/src/parse/ast.ts ===
// b_path:: packages/b_utils/src/parse/ast.ts
/**
 * AST utility functions for working with css-tree nodes
 * Part of the AST-native architecture refactoring
 */

import type * as csstree from "@eslint/css-tree";

/**
 * Split AST nodes by comma operators
 *
 * Replaces string-based splitByComma with AST-native approach.
 * Handles nested functions naturally via AST structure.
 *
 * @example
 * ```ts
 * // Input: [red, Function(calc), Operator(,), blue]
 * // Output: [[red, Function(calc)], [blue]]
 * const groups = splitNodesByComma(nodes);
 * ```
 */
export function splitNodesByComma(nodes: csstree.CssNode[]): csstree.CssNode[][] {
  const groups: csstree.CssNode[][] = [];
  let current: csstree.CssNode[] = [];

  for (const node of nodes) {
    if (node.type === "Operator" && node.value === ",") {
      if (current.length > 0) {
        groups.push(current);
        current = [];
      }
    } else {
      current.push(node);
    }
  }

  if (current.length > 0) {
    groups.push(current);
  }

  return groups;
}

/**
 * Check if node is a specific function
 *
 * Type guard for FunctionNode with optional name matching.
 *
 * @example
 * ```ts
 * if (isFunctionNode(node, "calc")) {
 *   // node is FunctionNode with name "calc"
 * }
 * ```
 */
export function isFunctionNode(node: csstree.CssNode, name?: string): node is csstree.FunctionNode {
  if (node.type !== "Function") return false;
  if (name) return node.name.toLowerCase() === name.toLowerCase();
  return true;
}

/**
 * Check if node is an identifier with optional value matching
 */
export function isIdentifier(node: csstree.CssNode, value?: string): node is csstree.Identifier {
  if (node.type !== "Identifier") return false;
  if (value) return node.name.toLowerCase() === value.toLowerCase();
  return true;
}

/**
 * Check if node is a dimension (number with unit)
 */
export function isDimension(node: csstree.CssNode): node is csstree.Dimension {
  return node.type === "Dimension";
}

/**
 * Check if node is a percentage
 */
export function isPercentage(node: csstree.CssNode): node is csstree.Percentage {
  return node.type === "Percentage";
}

/**
 * Check if node is a number
 */
export function isNumber(node: csstree.CssNode): boolean {
  return node.type === "Number";
}

/**
 * Convert AST node list to array
 *
 * css-tree uses linked lists, this converts to standard arrays.
 */
export function nodeListToArray(list: csstree.List<csstree.CssNode>): csstree.CssNode[] {
  return list.toArray();
}

/**
 * Extract location from a node, returning undefined if not available
 */
export function getNodeLocation(node: csstree.CssNode): csstree.CssLocationRange | undefined {
  return node.loc ?? undefined;
}

/**
 * Convert css-tree location to our SourceLocation format
 *
 * css-tree provides line/column ranges, we need offset/length.
 * This is a best-effort conversion - if source is available we calculate offset,
 * otherwise we return undefined (location tracking disabled).
 *
 * @param loc - css-tree location range
 * @param source - original source string (needed to calculate offsets)
 * @returns SourceLocation with offset/length, or undefined if not calculable
 */
export function convertLocation(
  loc: csstree.CssLocationRange | undefined,
  source?: string,
): { offset: number; length: number } | undefined {
  if (!loc || !source) return undefined;

  // Calculate offset from line/column
  const lines = source.split("\n");
  let offset = 0;

  // Add all complete lines before start line
  for (let i = 0; i < loc.start.line - 1; i++) {
    offset += lines[i].length + 1; // +1 for newline
  }

  // Add column offset on start line
  offset += loc.start.column - 1;

  // Calculate length
  let length = 0;
  if (loc.start.line === loc.end.line) {
    // Same line: just column difference
    length = loc.end.column - loc.start.column;
  } else {
    // Multiple lines: calculate total
    length = lines[loc.start.line - 1].length - (loc.start.column - 1);
    for (let i = loc.start.line; i < loc.end.line - 1; i++) {
      length += lines[i].length + 1;
    }
    length += loc.end.column;
  }

  return { offset, length };
}


=== File: packages/b_utils/src/parse/css-value-parser.ts ===
// b_path:: packages/b_utils/src/parse/css-value-parser.ts
import * as csstree from "@eslint/css-tree";
import { createError, forwardParseErr, parseErr, parseOk, type ParseResult } from "@b/types";
import type { CssValue } from "@b/types";

/**
 * ⚠️ **LOW-LEVEL API - Internal Use Only**
 *
 * Generic CSS value parser (NO complex function support).
 *
 * **DO NOT import this directly in property parsers.**
 * Use `@b/parsers/utils/parseNodeToCssValue` instead, which includes:
 * - Complex CSS functions (gradients, colors, math)
 * - Proper universal function handling (var, calc, etc.)
 * - Type-aware parsing for property-specific values
 *
 * This low-level parser does NOT handle complex CSS functions:
 * - ❌ Gradients: linear-gradient(), radial-gradient(), conic-gradient()
 * - ❌ Colors: rgb(), hsl(), lab(), lch(), oklch(), oklab(), color()
 * - ❌ Math: calc(), min(), max(), clamp()
 *
 * It only handles:
 * - ✅ Basic values: numbers, dimensions, percentages, keywords
 * - ✅ var() with fallback parsing
 * - ✅ String literals
 * - ✅ Hex colors (basic #RRGGBB)
 * - ✅ Generic function calls (as opaque CssValue, no semantic parsing)
 *
 * @internal Use via @b/parsers for property parsing
 * @see {@link @b/parsers/utils/parseNodeToCssValue} for property parsing
 */
export function parseCssValueNode(node: csstree.CssNode): ParseResult<CssValue> {
  switch (node.type) {
    case "Number": {
      const value = Number.parseFloat(node.value);
      if (Number.isNaN(value)) {
        return parseErr("number", createError("invalid-value", "Invalid number value"));
      }
      return parseOk({ kind: "literal", value });
    }

    case "Percentage": {
      const value = Number.parseFloat(node.value);
      if (Number.isNaN(value)) {
        return parseErr("percentage", createError("invalid-value", "Invalid percentage value"));
      }
      return parseOk({ kind: "literal", value, unit: "%" });
    }

    case "Dimension": {
      const value = Number.parseFloat(node.value);
      if (Number.isNaN(value)) {
        return parseErr("length", createError("invalid-value", "Invalid dimension value"));
      }
      return parseOk({ kind: "literal", value, unit: node.unit });
    }

    // --- NEW: Handle String Literals ---
    case "String": {
      // css-tree already removes the surrounding quotes
      return parseOk({ kind: "string", value: node.value });
    }
    // --- END NEW ---

    case "Identifier": {
      return parseOk({ kind: "keyword", value: node.name });
    }

    case "Function": {
      const funcName = node.name.toLowerCase();
      const children = node.children.toArray();

      // 1. Handle var() (Needs special inline parsing due to fallback)
      if (funcName === "var") {
        const varNameNode = children.find((n) => n.type !== "WhiteSpace");

        if (!varNameNode) {
          return parseErr(
            "var()",
            createError("invalid-syntax", "Invalid var() function: missing custom property name"),
          );
        }

        if (varNameNode.type !== "Identifier" || !varNameNode.name.startsWith("--")) {
          return parseErr(
            "var()",
            createError(
              "invalid-syntax",
              `Invalid var() function: expected a custom property name (--*), got ${varNameNode.type}`,
            ),
          );
        }

        const varName = varNameNode.name;
        let fallback: CssValue | undefined;
        const commaIndex = children.findIndex((n) => n.type === "Operator" && n.value === ",");

        // Handle fallback logic
        if (commaIndex !== -1) {
          const fallbackNodes = children.slice(commaIndex + 1).filter((n) => n.type !== "WhiteSpace");

          if (fallbackNodes.length === 0) {
            return parseErr(
              "var()",
              createError("invalid-syntax", "Invalid var() function: missing fallback value after comma"),
            );
          }

          // Handle Raw nodes - css-tree sometimes parses fallback values as Raw
          const firstNode = fallbackNodes[0];
          if (firstNode.type === "Raw") {
            // Parse the raw string as a CSS value
            try {
              const rawAst = csstree.parse(firstNode.value.trim(), { context: "value" });
              // biome-ignore lint/suspicious/noExplicitAny: css-tree List type not exposed in type definitions
              const rawChildren = (rawAst as any).children?.toArray();
              if (rawChildren && rawChildren.length > 0) {
                const fallbackResult = parseCssValueNode(rawChildren[0]);
                if (!fallbackResult.ok) {
                  return fallbackResult;
                }
                fallback = fallbackResult.value;
              }
            } catch {
              // If parsing fails, treat as invalid
              return parseErr(
                "var()",
                createError("invalid-syntax", `Invalid var() fallback value: ${firstNode.value}`),
              );
            }
          } else {
            // RECURSION: Parse the content of the fallback argument
            const fallbackResult = parseCssValueNode(firstNode);
            if (!fallbackResult.ok) {
              return fallbackResult;
            }
            fallback = fallbackResult.value;
          }
        }

        return parseOk({
          kind: "variable",
          name: varName,
          ...(fallback && { fallback }),
        });
      }

      // 2. FALLBACK: Generic Function Call (for all other functions)
      // NOTE: Complex functions (calc, rgb, etc.) should be handled by calling
      // parseNodeToCssValue from @b/parsers instead of this function directly.
      // This fallback handles unknown functions generically.
      const args: CssValue[] = [];
      const argumentNodes = children.filter((n) => n.type !== "WhiteSpace" && n.type !== "Operator");

      for (const child of argumentNodes) {
        // RECURSION: This handles the nested primitives or other functions inside
        const argResult = parseCssValueNode(child);
        if (argResult.ok) {
          args.push(argResult.value);
        } else {
          return forwardParseErr<CssValue>(argResult);
        }
      }

      return parseOk({ kind: "function", name: node.name, args: args });
    }

    // Hash nodes (#RRGGBB) represent hex colors
    // Property-specific color parsers handle full Color IR;
    // this handles generic hex color values
    case "Hash": {
      const value = node.value.toLowerCase();
      return parseOk({ kind: "hex-color", value: `#${value}` });
    }

    default: {
      return parseErr("css-value", createError("unsupported-kind", `Unsupported node type: ${node.type}`));
    }
  }
}

/**
 * Extract non-whitespace children from a function node
 */
export function getChildren(node: csstree.FunctionNode): csstree.CssNode[] {
  const children: csstree.CssNode[] = [];
  node.children.forEach((child) => {
    if (child.type !== "WhiteSpace") {
      children.push(child);
    }
  });
  return children;
}

/**
 * Extract values from children, filtering out operator nodes
 */
export function getValues(children: csstree.CssNode[]): csstree.CssNode[] {
  const values: csstree.CssNode[] = [];
  for (const child of children) {
    if (child.type !== "Operator") {
      values.push(child);
    }
  }
  return values;
}


=== File: packages/b_utils/src/parse/index.ts ===
// b_path:: packages/b_utils/src/parse/index.ts
export * from "./ast";
export * from "./css-value-parser";
export * from "./test-utils";


=== File: packages/b_utils/src/parse/test-utils.ts ===
// b_path:: packages/b_utils/src/parse/test-utils.ts
import * as csstree from "@eslint/css-tree";

/**
 * Extract a function node from a CSS function string for testing
 *
 * @param input - CSS function string (e.g., "rgb(255 0 0)", "calc(100% - 20px)")
 * @returns The parsed FunctionNode
 * @throws Error if parsing fails or result is not a function
 */
export function extractFunctionFromValue(input: string): csstree.FunctionNode {
  const ast = csstree.parse(input, { context: "value" });

  if (ast.type !== "Value") {
    throw new Error("Expected Value node");
  }

  const func = ast.children.first;
  if (func?.type !== "Function") {
    throw new Error(`Expected Function node, got ${func?.type}`);
  }

  return func;
}


=== File: packages/b_utils/src/string/index.ts ===
// b_path:: packages/b_utils/src/string/index.ts

export * from "./levenshtein";


=== File: packages/b_utils/src/string/levenshtein.ts ===
// b_path:: packages/b_utils/src/string/levenshtein.ts

/**
 * Calculate Levenshtein distance between two strings.
 * Used for "Did you mean X?" suggestions.
 *
 * @param a - First string
 * @param b - Second string
 * @returns Minimum number of single-character edits (insertions, deletions, substitutions)
 *
 * @example
 * ```typescript
 * levenshteinDistance("kitten", "sitting"); // 3
 * levenshteinDistance("hello", "hello"); // 0
 * ```
 *
 * @see https://en.wikipedia.org/wiki/Levenshtein_distance
 *
 * @public
 */
export function levenshteinDistance(a: string, b: string): number {
  const matrix: number[][] = [];

  // Initialize first column and row
  for (let i = 0; i <= b.length; i++) {
    matrix[i] = [i];
  }
  for (let j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }

  // Fill in the rest
  for (let i = 1; i <= b.length; i++) {
    for (let j = 1; j <= a.length; j++) {
      if (b[i - 1] === a[j - 1]) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        matrix[i][j] = Math.min(
          matrix[i - 1][j - 1] + 1, // substitution
          matrix[i][j - 1] + 1, // insertion
          matrix[i - 1][j] + 1, // deletion
        );
      }
    }
  }

  return matrix[b.length][a.length];
}

/**
 * Find closest match from a list of valid options.
 * Returns undefined if no close match found.
 *
 * @param input - The string to match
 * @param validOptions - List of valid options
 * @param maxDistance - Maximum distance to consider (default: 3)
 * @returns Closest matching string, or undefined if none found within maxDistance
 *
 * @example
 * ```typescript
 * const colors = ["red", "blue", "green"];
 * findClosestMatch("gren", colors); // "green"
 * findClosestMatch("xyz", colors); // undefined
 * ```
 *
 * @public
 */
export function findClosestMatch(input: string, validOptions: string[], maxDistance = 3): string | undefined {
  let closestMatch: string | undefined;
  let minDistance = Number.POSITIVE_INFINITY;

  for (const option of validOptions) {
    const distance = levenshteinDistance(input.toLowerCase(), option.toLowerCase());

    if (distance < minDistance && distance <= maxDistance) {
      minDistance = distance;
      closestMatch = option;
    }
  }

  return closestMatch;
}


=== File: packages/b_utils/src/validation/index.ts ===
// b_path:: packages/b_utils/src/validation/index.ts

export {
  checkAlpha,
  checkHue,
  checkLiteralRange,
  checkPercentage,
  checkRGBComponent,
  collectWarnings,
} from "./semantic";


=== File: packages/b_utils/src/validation/semantic.ts ===
// b_path:: packages/b_utils/src/validation/semantic.ts

import type { CssValue, Issue } from "@b/types";
import { createWarning } from "@b/types";

/**
 * Check if a literal value is in expected range.
 * Returns warning if out of range, undefined if OK or not applicable.
 *
 * Only validates literal values - returns undefined for variables, calc, etc.
 *
 * @param value - CssValue to check
 * @param min - Minimum valid value (inclusive)
 * @param max - Maximum valid value (inclusive)
 * @param context - Context for error message
 * @returns Warning issue if out of range, undefined otherwise
 *
 * @example
 * ```typescript
 * const warning = checkLiteralRange(lit(300), 0, 255, { field: "r", typeName: "RGBColor" });
 * // Returns warning: "r value 300 is out of valid range 0-255 in RGBColor"
 * ```
 *
 * @public
 */
export function checkLiteralRange(
  value: CssValue,
  min: number,
  max: number,
  context: {
    field: string;
    unit?: string;
    typeName?: string;
    parentPath?: (string | number)[];
  },
): Issue | undefined {
  // Only validate literals
  if (value.kind !== "literal") return undefined;

  const numericValue = value.value;

  if (numericValue < min || numericValue > max) {
    const unit = context.unit ?? value.unit ?? "";
    const typeInfo = context.typeName ? ` in ${context.typeName}` : "";
    return createWarning(
      "invalid-value",
      `${context.field} value ${numericValue}${unit} is out of valid range ${min}-${max}${unit}${typeInfo}`,
      {
        suggestion: `Use a value between ${min}${unit} and ${max}${unit}`,
        path: [...(context.parentPath ?? []), context.field],
      },
    );
  }

  return undefined;
}

/**
 * Check RGB component (0-255 for integers, 0-100 for percentages).
 *
 * @param value - CssValue to check
 * @param field - Field name (e.g., "r", "g", "b")
 * @param typeName - Optional type name for error messages
 * @returns Warning issue if out of range, undefined otherwise
 *
 * @example
 * ```typescript
 * checkRGBComponent(lit(-255), "r", "RGBColor");
 * // Returns warning
 *
 * checkRGBComponent(lit(50, "%"), "r", "RGBColor");
 * // Returns undefined (valid percentage)
 * ```
 *
 * @public
 */
export function checkRGBComponent(
  value: CssValue,
  field: string,
  typeName?: string,
  parentPath?: (string | number)[],
): Issue | undefined {
  if (value.kind !== "literal") return undefined;

  // Percentage (0-100%)
  if (value.unit === "%") {
    return checkLiteralRange(value, 0, 100, { field, unit: "%", typeName, parentPath });
  }

  // Integer (0-255)
  return checkLiteralRange(value, 0, 255, { field, typeName, parentPath });
}

/**
 * Check alpha value (0-1 for numbers, 0-100% for percentages).
 *
 * @param value - CssValue to check
 * @param field - Field name (e.g., "alpha")
 * @param typeName - Optional type name for error messages
 * @returns Warning issue if out of range, undefined otherwise
 *
 * @example
 * ```typescript
 * checkAlpha(lit(1.5), "alpha", "RGBColor");
 * // Returns warning
 *
 * checkAlpha(lit(50, "%"), "alpha", "RGBColor");
 * // Returns undefined (valid percentage)
 * ```
 *
 * @public
 */
export function checkAlpha(
  value: CssValue,
  field: string,
  typeName?: string,
  parentPath?: (string | number)[],
): Issue | undefined {
  if (value.kind !== "literal") return undefined;

  // Percentage (0-100%)
  if (value.unit === "%") {
    return checkLiteralRange(value, 0, 100, { field, unit: "%", typeName, parentPath });
  }

  // Number (0-1)
  return checkLiteralRange(value, 0, 1, { field, typeName, parentPath });
}

/**
 * Check hue value (0-360 degrees, wraps around).
 * Note: Hue can technically be any value (wraps), but warn if unreasonable.
 *
 * @param value - CssValue to check
 * @param field - Field name (e.g., "h")
 * @param typeName - Optional type name for error messages
 * @returns Warning issue if unusual, undefined otherwise
 *
 * @example
 * ```typescript
 * checkHue(lit(720), "h", "HSLColor");
 * // Returns warning (unusually large)
 *
 * checkHue(lit(180), "h", "HSLColor");
 * // Returns undefined (valid)
 * ```
 *
 * @public
 */
export function checkHue(value: CssValue, field: string, typeName?: string): Issue | undefined {
  if (value.kind !== "literal") return undefined;

  const typeInfo = typeName ? ` in ${typeName}` : "";

  // Allow any degree unit
  if (value.unit && !["deg", "rad", "grad", "turn"].includes(value.unit)) {
    return createWarning("invalid-value", `${field} has unsupported unit '${value.unit}'${typeInfo}`, {
      suggestion: "Use deg, rad, grad, or turn units for hue",
      path: [field],
    });
  }

  // Warn if way outside 0-360 (even though it wraps)
  if (value.unit === "deg" || !value.unit) {
    if (value.value < -360 || value.value > 720) {
      return createWarning("invalid-value", `${field} value ${value.value}deg is unusually large${typeInfo}`, {
        suggestion: "Hue typically ranges from 0-360 degrees",
        path: [field],
      });
    }
  }

  return undefined;
}

/**
 * Check percentage (0-100%).
 *
 * @param value - CssValue to check
 * @param field - Field name (e.g., "s", "l")
 * @param typeName - Optional type name for error messages
 * @returns Warning issue if out of range, undefined otherwise
 *
 * @example
 * ```typescript
 * checkPercentage(lit(150, "%"), "s", "HSLColor");
 * // Returns warning
 *
 * checkPercentage(lit(50, "%"), "s", "HSLColor");
 * // Returns undefined (valid)
 * ```
 *
 * @public
 */
export function checkPercentage(value: CssValue, field: string, typeName?: string): Issue | undefined {
  if (value.kind !== "literal") return undefined;

  return checkLiteralRange(value, 0, 100, { field, unit: "%", typeName });
}

/**
 * Collect all warnings from validators.
 * Filters out undefined values.
 *
 * @param validators - Array of validation results
 * @returns Array of Issues (warnings only)
 *
 * @example
 * ```typescript
 * const warnings = collectWarnings(
 *   checkRGBComponent(r, "r"),
 *   checkRGBComponent(g, "g"),
 *   checkRGBComponent(b, "b"),
 * );
 * ```
 *
 * @public
 */
export function collectWarnings(...validators: (Issue | undefined)[]): Issue[] {
  return validators.filter((issue): issue is Issue => issue !== undefined);
}


=== File: packages/b_utils/tsup.config.ts ===
// b_path:: packages/b_utils/tsup.config.ts
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/index.ts", "src/parse/index.ts", "src/generate/index.ts"],
  format: ["esm"],
  dts: true,
  clean: true,
  sourcemap: true,
});


=== File: packages/b_utils/vite.config.ts ===
// b_path:: packages/b_utils/vite.config.ts
import { defineConfig } from "vite";

import tsconfigPaths from "vite-tsconfig-paths";

// https://vite.dev/config/
export default defineConfig({
  plugins: [tsconfigPaths()],
});


=== File: packages/b_values/src/color/index.ts ===
// b_path:: packages/b_values/src/color/index.ts
export {};


=== File: packages/b_values/src/index.ts ===
// b_path:: packages/b_values/src/index.ts
// @b/values - Main umbrella package

// Re-export all packages
export * as Keywords from "@b/keywords";
export * as Types from "@b/types";
export * as Units from "@b/units";
export * as Parse from "@b/parsers";
export * as Generate from "@b/generators";
export * as Declarations from "@b/declarations";


=== File: packages/b_values/src/test-bg-image-var.ts ===
// b_path:: packages/b_values/src/test-bg-image-var.ts
import * as decl from "@b/declarations";

console.log(
  JSON.stringify(
    decl.parseDeclarationList(`
    background-image: var(--gradient-overlay), url("pattern.svg"), none;
  `),
    null,
    2,
  ),
);


=== File: packages/b_values/src/test-original.ts ===
// b_path:: packages/b_values/src/test-original.ts
import * as decl from "@b/declarations";

console.log(
  JSON.stringify(
    decl.parseDeclarationList(`
    --brand-color: #0066cc;
    --default-size: 100px;
    --bg-repeat-val: no-repeat;

    background-size: var(--special-size, 50%);
    background-clip: var(--clip-type, border-box);
    background-repeat: var(--bg-repeat-val, var(--fallback-repeat, repeat));
  `),
    null,
    2,
  ),
);


=== File: packages/b_values/src/test-var-comparison.ts ===
// b_path:: packages/b_values/src/test-var-comparison.ts
import * as decl from "@b/declarations";

console.log("=== background-size (works) ===");
console.log(JSON.stringify(decl.parseDeclaration("background-size: var(--size)"), null, 2));

console.log("\n=== background-clip (fails) ===");
console.log(JSON.stringify(decl.parseDeclaration("background-clip: var(--clip)"), null, 2));

console.log("\n=== background-repeat (fails) ===");
console.log(JSON.stringify(decl.parseDeclaration("background-repeat: var(--repeat)"), null, 2));


=== File: packages/b_values/tsup.config.ts ===
// b_path:: packages/b_values/tsup.config.ts
import { defineConfig } from "tsup";

export default defineConfig({
  entry: ["src/index.ts"],
  format: ["cjs", "esm"],
  dts: true,
  splitting: false,
  sourcemap: true,
  clean: true,
  treeshake: true,
});


=== File: packages/b_values/vite.config.ts ===
// b_path:: packages/b_values/vite.config.ts
import path from "node:path";
import { defineConfig } from "vite";

import tsconfigPaths from "vite-tsconfig-paths";

// https://vite.dev/config/
export default defineConfig({
  plugins: [tsconfigPaths()],
  resolve: {
    alias: {
      "@": path.resolve(__dirname, "./src"),
    },
  },
});


