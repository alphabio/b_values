// b_path:: packages/b_declarations/src/properties/background-image/parser.ts
import { createError, parseErr, parseOk, forwardParseErr, type ParseResult } from "@b/types";
import * as Parsers from "@b/parsers";
import { isCSSWideKeyword, parseCSSWideKeyword } from "../../utils";
import * as Ast from "@b/utils/parse/ast";
import type { BackgroundImageIR, ImageLayer } from "./types";
import type * as csstree from "@eslint/css-tree";

/**
 * Parse a background-image value from AST node.
 *
 * Property syntax: background-image = <bg-image>#
 * Where <bg-image> = <image> | none
 * And <image> = <url> | <gradient> | <image()> | etc.
 *
 * AST-native approach:
 * 1. Handles CSS-wide keywords
 * 2. Splits by comma operators using AST structure
 * 3. Delegates each layer to appropriate VALUE parser
 */
export function parseBackgroundImage(valueNode: csstree.Value): ParseResult<BackgroundImageIR> {
  const children = Ast.nodeListToArray(valueNode.children);

  // Handle single keywords like 'none', 'inherit', 'initial'
  if (children.length === 1 && Ast.isIdentifier(children[0])) {
    const keyword = children[0].name.toLowerCase();

    // CSS-wide keywords
    if (isCSSWideKeyword(keyword)) {
      const keywordResult = parseCSSWideKeyword(keyword);
      if (keywordResult.ok) {
        return parseOk({
          kind: "keyword",
          value: keywordResult.value,
        });
      }
    }

    // 'none' keyword
    if (keyword === "none") {
      return parseOk({
        kind: "keyword",
        value: "none",
      });
    }
  }

  // Split by commas using AST utility
  const layerGroups = Ast.splitNodesByComma(children);
  const layerResults: ParseResult<ImageLayer>[] = [];

  for (const group of layerGroups) {
    if (group.length === 0) continue;

    const firstNode = group[0];

    // Handle 'none' as identifier
    if (Ast.isIdentifier(firstNode, "none")) {
      layerResults.push(parseOk({ kind: "none" }));
      continue;
    }

    // Handle url() function
    if (Ast.isFunctionNode(firstNode, "url")) {
      const urlResult = Parsers.Url.parseUrlFromNode(firstNode);
      if (urlResult.ok) {
        layerResults.push(
          parseOk({
            kind: "url",
            url: urlResult.value.value,
          }),
        );
      } else {
        layerResults.push(forwardParseErr<ImageLayer>(urlResult));
      }
      continue;
    }

    // Delegate to linear-gradient parser
    if (layer.startsWith("linear-gradient(") || layer.startsWith("repeating-linear-gradient(")) {
      const gradientResult = Parsers.Gradient.Linear.parse(layer);
      if (gradientResult.ok) {
        layerResults.push(
          parseOk({
            kind: "gradient",
            gradient: gradientResult.value,
          }),
        );
      } else {
        // Preserve partial gradient value for generator inspection
        if (gradientResult.value) {
          layerResults.push({
            ok: false,
            value: {
              kind: "gradient",
              gradient: gradientResult.value,
            },
            issues: gradientResult.issues,
          });
        } else {
          layerResults.push(forwardParseErr<ImageLayer>(gradientResult));
        }
      }
      continue;
    }

    // Delegate to radial-gradient parser
    if (layer.startsWith("radial-gradient(") || layer.startsWith("repeating-radial-gradient(")) {
      const gradientResult = Parsers.Gradient.Radial.parse(layer);
      if (gradientResult.ok) {
        layerResults.push(
          parseOk({
            kind: "gradient",
            gradient: gradientResult.value,
          }),
        );
      } else {
        // Preserve partial gradient value for generator inspection
        if (gradientResult.value) {
          layerResults.push({
            ok: false,
            value: {
              kind: "gradient",
              gradient: gradientResult.value,
            },
            issues: gradientResult.issues,
          });
        } else {
          layerResults.push(forwardParseErr<ImageLayer>(gradientResult));
        }
      }
      continue;
    }

    // Delegate to conic-gradient parser
    if (layer.startsWith("conic-gradient(") || layer.startsWith("repeating-conic-gradient(")) {
      const gradientResult = Parsers.Gradient.Conic.parse(layer);
      if (gradientResult.ok) {
        layerResults.push(
          parseOk({
            kind: "gradient",
            gradient: gradientResult.value,
          }),
        );
      } else {
        // Preserve partial gradient value for generator inspection
        if (gradientResult.value) {
          layerResults.push({
            ok: false,
            value: {
              kind: "gradient",
              gradient: gradientResult.value,
            },
            issues: gradientResult.issues,
          });
        } else {
          layerResults.push(forwardParseErr<ImageLayer>(gradientResult));
        }
      }
      continue;
    }

    // TODO: Handle other <image> types:
    // - image()
    // - image-set()
    // - cross-fade()
    // - element()

    layerResults.push(parseErr(createError("invalid-value", `Unsupported image type in background-image: ${layer}`)));
  }

  // Aggregate all issues from layer results
  const allIssues = layerResults.flatMap((r) => r.issues);
  const successfulLayers = layerResults.filter((r) => r.ok).map((r) => r.value as ImageLayer);
  // Also collect partial layers (failed but has value) to enable generator warnings
  const partialLayers = layerResults.filter((r) => !r.ok && r.value).map((r) => r.value as ImageLayer);
  const allLayers = [...successfulLayers, ...partialLayers];

  const finalValue: BackgroundImageIR = {
    kind: "layers",
    layers: allLayers,
  };

  // If there are any errors, return failure with all issues but still include successful layers
  if (allIssues.some((i) => i.severity === "error")) {
    const result: ParseResult<BackgroundImageIR> = {
      ok: false,
      value: finalValue,
      issues: allIssues,
      property: "background-image",
    };
    return result;
  }

  return parseOk(finalValue, "background-image");
}
